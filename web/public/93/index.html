<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Read BIPs like a pro." />
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="og:title" content="BIP 93: codex32: Checksummed SSSS-aware BIP32 seeds" />
    <meta property="og:description" content="Read BIPs like a pro." />
    <meta property="og:image" content="https://bips.dev/og-bips-dev.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="BIP 93: codex32: Checksummed SSSS-aware BIP32 seeds" />
    <meta name="twitter:description" content="Read BIPs like a pro." />
    <meta name="twitter:creator" content="@nickmonad" />
    <meta name="twitter:image" content="https://bips.dev/og-bips-dev.png" />

    <title>BIP 93: codex32: Checksummed SSSS-aware BIP32 seeds</title>

    
        <link rel="stylesheet" href="/style.css" />
    

    <link rel="stylesheet" href="/pagefind/pagefind-ui.css" />
    <script src="/pagefind/pagefind-ui.js"></script>

    <script defer data-domain="bips.dev" src="/js/script.js"></script>
    <script>
        // setup plausible function for custom events
        window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }

        // setup and initialize dark mode
        // https://tailwindcss.com/docs/dark-mode
        window.setTheme = function() {
            if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark')
            } else {
                document.documentElement.classList.remove('dark')
            }
        }
        window.setTheme();

        // searching via
        // https://pagefind.app
        window.addEventListener('DOMContentLoaded', function(event) {
            new PagefindUI({
                element: "#search",
                hightlightParam: "highlight",
                showImages: false,
                showSubResults: true,
                translations: {
                    placeholder: "Search BIPs"
                },
                processTerm: function(term) {
                    plausible('Search');
                    return term;
                }
            });
        });
    </script>

    <style>
        /* variables to override on pagefind */
        /* https://pagefind.app/docs/ui-usage/#customising-the-styles */
        /* values are from tailwind: https://tailwindcss.com/docs/customizing-colors */
        :root {
            --pagefind-ui-primary: #334155;
            --pagefind-ui-text: #334155;
            --pagefind-ui-background: #ffffff;
            --pagefind-ui-border-width: 1px;
            --pagefind-ui-border-radius: 4px;
        }

        html.dark {
            --pagefind-ui-primary: #d1d5db;
            --pagefind-ui-text: #d1d5db;
            --pagefind-ui-background: #18181b;
            --pagefind-ui-border: #152028;
        }

        mark {
            background-color: #ff9900 !important;
            color: #6b7280 !important;
        }
    </style>
</head>

<body class="bg-white dark:bg-zinc-900">
    <div class="container mx-auto flex justify-center">
        <div data-pagefind-body class="min-w-full max-w-full lg:min-w-[1000px] lg:max-w-[1000px] px-6 py-10 space-y-10 text-slate-700 dark:text-gray-300">
            
    <div class="flex flex-col space-y-4 pt-4 md:pt-8">
        <div class="flex justify-between">
            <a href="/">Back to BIPs</a>
            <div class="flex">
                <svg id="toggleDark_light" class="hidden dark:flex w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'light'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
                </svg>
                <svg id="toggleDark_dark" class="flex dark:hidden w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'dark'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
                </svg>
            </div>
        </div>
        <div class="flex flex-col space-y-2">
            <div data-pagefind-weight="10" class="text-2xl font-extrabold">BIP 93: codex32: Checksummed SSSS-aware BIP32 seeds</div>
            <div class="flex justify-between">
                <div class="text-xl font-semibold">2023-02-13</div>
                <a href="https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;blob&#x2F;master&#x2F;bip-0093.mediawiki" target="_blank">View on GitHub</a>
            </div>
        </div>

        <article class="max-w-none prose prose-lg prose-zinc prose-p:leading-relaxed prose-a:font-bold prose-a:underline prose-a:decoration-2 prose-a:decoration-bitcoin prose-pre:bg-zinc-200 prose-pre:text-zinc-800 dark:prose-invert dark:prose-pre:bg-zinc-600 dark:prose-pre:text-white">
            <pre><code>  BIP: 93
  Layer: Applications
  Title: codex32: Checksummed SSSS-aware BIP32 seeds
  Author: Leon Olsson Curr and Pearlwort Sneed &lt;pearlwort@wpsoftware.net&gt;
          Andrew Poelstra &lt;andrew.poelstra@gmail.com&gt;
  Comments-URI: https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;wiki&#x2F;Comments:BIP-0093
  Status: Draft
  Type: Informational
  Created: 2023-02-13
  License: BSD-3-Clause
  Post-History: https:&#x2F;&#x2F;lists.linuxfoundation.org&#x2F;pipermail&#x2F;bitcoin-dev&#x2F;2023-February&#x2F;021469.html
</code></pre>
<h2>Introduction</h2>
<h3>Abstract</h3>
<p>This document proposes a checksummed base32 format, &quot;codex32&quot;, and a standard for backing up and restoring the master seed of a
<a href="/32" target="_blank">BIP-0032</a> hierarchical deterministic wallet using it.
It includes an encoding format, a BCH error-correcting checksum, and optional Shamir's secret sharing algorithms for share generation and secret recovery.
Secret data can be encoded directly, or split into up to 31 shares.
A minimum threshold of shares, which can be between 2 and 9, is needed to recover the secret, whereas without sufficient shares, no information about the secret is recoverable.</p>
<h3>Copyright</h3>
<p>This document is licensed under the 3-clause BSD license.</p>
<h3>Motivation</h3>
<p>BIP-0032 master seed data is the source entropy used to derive all private keys in an HD wallet.
Safely storing this secret data is the hardest and most important part of self-custody.
However, there is a tension between security, which demands limiting the number of backups, and resilience, which demands widely replicated backups.
Encrypting the seed does not change this fundamental tradeoff, since it leaves essentially the same problem of how to back up the encryption key(s).</p>
<p>To allow users freedom to make this tradeoff, we use Shamir's secret sharing, which guarantees that any number of shares less than the threshold leaks no information about the secret.
This approach allows increasing safety by widely distributing the generated shares, while also providing security against the compromise of one or more shares (as long as fewer than the threshold have been compromised).</p>
<p><a href="https://github.com/satoshilabs/slips/blob/master/slip-0039.md" target="_blank">SLIP-0039</a> has essentially the same motivations as this standard.
However, unlike SLIP-0039,</p>
<ul>
<li>this standard aims to be simple enough for hand computation</li>
<li>we use the bech32 alphabet rather than a word list, resulting in fixed-length compact encodings</li>
<li>we do not support multi-level secret sharing (splitting of shares), although it is technically possible and may be added in a future BIP</li>
<li>because of the need to support hand computation, we <strong>do not</strong> support passphrases or key hardening</li>
</ul>
<p>Users who demand a higher level of security for particular secrets, or have a general distrust in digital electronic devices, have the option of using hand computation to backup and restore secret data in an interoperable manner.
In particular, all computations can be done with simple lookup tables.
<strong>It is therefore possible to compute and verify checksums, and to split and recover seeds, entirely using pen and paper.</strong>
For long-lived rarely-used seeds, the ability to hand-verify checksums has a significant benefit even for users who do not care to do any other part of this process by hand.
It means that they can verify the integrity (against non-malicious tampering) of their shares regularly, say, on an annual basis, without needing to continually expose secret data to new hardware.</p>
<p>The ability to compute properties by hand comes from our choice of a small field and our use of linear error correcting codes.
It does not come with any reduction in security, as long as users use high-quality randomness.
Note that hand computation is optional, the particular details of hand computation are outside the scope of this standard, and implementers do not need to be concerned with this possibility.</p>
<p><a href="/39" target="_blank">BIP-0039</a> serves the same purpose as this standard: encoding master seeds for storage by users.
However, BIP-0039 has no error-correcting ability, cannot sensibly be extended to support secret sharing, has no support for versioning or other metadata, and has many technical design decisions that make implementation and interoperability difficult (for example, the use of SHA-512 to derive seeds, or the use of 11-bit words).</p>
<h2>Specification</h2>
<p>We first describe the general checksummed base32<ref><strong>Why use base32 at all?</strong> The lack of mixed case makes it more
efficient to read out loud, write, type or to put into QR codes.</ref> format called
<em>codex32</em> and then define a BIP-0032 master seed encoding using it.</p>
<h3>codex32</h3>
<p>A codex32 string is similar to a bech32 string defined in <a href="/173" target="_blank">BIP-0173</a>.
It reuses the base-32 character set from BIP-0173, and consists of:</p>
<ul>
<li>A human-readable part, which is the string &quot;ms&quot; (or &quot;MS&quot;).</li>
<li>A separator, which is always &quot;1&quot;.</li>
<li>A data part which is in turn subdivided into:
<ul>
<li>A threshold parameter, which MUST be a single digit between &quot;2&quot; and &quot;9&quot;, or the digit &quot;0&quot;.
<ul>
<li>If the threshold parameter is &quot;0&quot; then the share index, defined below, MUST have a value of &quot;s&quot; (or &quot;S&quot;).</li>
</ul>
</li>
<li>An identifier consisting of 4 bech32 characters.</li>
<li>A share index, which is any bech32 character. Note that a share index value of &quot;s&quot; (or &quot;S&quot;) is special and denotes the unshared secret (see section &quot;Unshared Secret&quot;).</li>
<li>A payload which is a sequence of up to 74 bech32 characters. (However, see <strong>Long codex32 Strings</strong> below for an exception to this limit.)</li>
<li>A checksum which consists of 13 bech32 characters as described below.</li>
</ul>
</li>
</ul>
<p>As with bech32 strings, a codex32 string MUST be entirely uppercase or entirely lowercase.
Note that per BIP-0173, the lowercase form is used when determining a character's value for checksum purposes.
In particular, given an all uppercase codex32 string, we still use lowercase <code>ms</code> as the human-readable part during checksum construction.
For presentation, lowercase is usually preferable, but uppercase SHOULD be used for handwritten codex32 strings.
If a codex32 string is encoded in a QR code, it SHOULD use the uppercase form, as this is encoded more compactly.</p>
<h4>Checksum</h4>
<p>The last thirteen characters of the data part form a checksum and contain no information.
Valid strings MUST pass the criteria for validity specified by the Python 3 code snippet below.
The function <code>ms32_verify_checksum</code> must return true when its argument is the data part as a list of integers representing the characters converted using the bech32 character table from BIP-0173.</p>
<p>To construct a valid checksum given the data-part characters (excluding the checksum), the <code>ms32_create_checksum</code> function can be used.</p>
<pre><code>MS32_CONST = 0x10ce0795c2fd1e62a

def ms32_polymod(values):
    GEN = [
        0x19dc500ce73fde210,
        0x1bfae00def77fe529,
        0x1fbd920fffe7bee52,
        0x1739640bdeee3fdad,
        0x07729a039cfc75f5a,
    ]
    residue = 0x23181b3
    for v in values:
        b = (residue &gt;&gt; 60)
        residue = (residue &amp; 0x0fffffffffffffff) &lt;&lt; 5 ^ v
        for i in range(5):
            residue ^= GEN[i] if ((b &gt;&gt; i) &amp; 1) else 0
    return residue

def ms32_verify_checksum(data):
    if len(data) &gt;= 96:                      # See Long codex32 Strings
        return ms32_verify_long_checksum(data)
    if len(data) &lt;= 93:
        return ms32_polymod(data) == MS32_CONST
    return False

def ms32_create_checksum(data):
    if len(data) &gt; 80:                       # See Long codex32 Strings
        return ms32_create_long_checksum(data)
    values = data
    polymod = ms32_polymod(values + [0] * 13) ^ MS32_CONST
    return [(polymod &gt;&gt; 5 * (12 - i)) &amp; 31 for i in range(13)]
</code></pre>
<p>This implements a <a href="https://en.wikipedia.org/wiki/BCH_code" target="_blank">BCH code</a> that
guarantees detection of <strong>any error affecting at most 8 characters</strong>
and has less than a 3 in 10<sup>20</sup> chance of failing to detect more
random errors.</p>
<h4>Error Correction</h4>
<p>A codex32 string without a valid checksum MUST NOT be used.
The checksum is designed to be an error correcting code that can correct up to 4 character substitutions, up to 8 unreadable characters (called erasures), or up to 13 consecutive erasures.
Implementations SHOULD provide the user with a corrected valid codex32 string if possible.
However, implementations SHOULD NOT automatically proceed with a corrected codex32 string without user confirmation of the corrected string, either by prompting the user, or returning a corrected string in an error message and allowing the user to repeat their action.
We do not specify how an implementation should implement error correction. However, we recommend that:</p>
<ul>
<li>Implementations make suggestions to substitute non-bech32 characters with bech32 characters in some situations, such as replacing &quot;B&quot; with &quot;8&quot;, &quot;O&quot; with &quot;0&quot;, &quot;I&quot; with &quot;l&quot;, etc.</li>
<li>Implementations interpret &quot;?&quot; as an erasure.</li>
<li>Implementations optionally interpret other non-bech32 characters, or characters with incorrect case, as erasures.</li>
<li>If a string with 8 or fewer erasures can have those erasures filled in to make a valid codex32 string, then the implementation suggests such a string as a correction.</li>
<li>If a string consisting of valid bech32 characters in the proper case can be made valid by substituting 4 or fewer characters, then the implementation suggests such a string as a correction.</li>
</ul>
<h3>Unshared Secret</h3>
<p>When the share index of a valid codex32 string (converted to lowercase) is the letter &quot;s&quot;, we call the string a codex32 secret.</p>
<p>The secret is decoded by converting the payload to bytes:</p>
<ul>
<li>Translate the characters to 5 bits values using the bech32 character table from BIP-0173, most significant bit first.</li>
<li>Re-arrange those bits into groups of 8 bits. Any incomplete group at the end MUST be 4 bits or less, and is discarded.</li>
</ul>
<p>Note that unlike the decoding process in BIP-0173, we do NOT require that the incomplete group be all zeros.</p>
<p>For an unshared secret, the threshold parameter (the first character of the data part) is ignored (beyond the fact it must be a digit for the codex32 string to be valid).
We recommend using the digit &quot;0&quot; for the threshold parameter in this case.
The 4 character identifier also has no effect beyond aiding users in distinguishing between multiple different secrets in cases where they have more than one.</p>
<p>The function <code>ms32_encode</code> constructs a codex32 string when its argument is the converted data-part characters (excluding the checksum).</p>
<p>To validate a codex32 string and determine the data-part (excluding the checksum) as a list of 5-bit values, the <code>ms32_decode</code> function can be used.</p>
<pre><code>CHARSET = &quot;qpzry9x8gf2tvdw0s3jn54khce6mua7l&quot;

def ms32_encode(data):
    combined = data + ms32_create_checksum(data)
    return &quot;ms&quot; + &quot;1&quot; + &#x27;&#x27;.join([CHARSET[d] for d in combined])

def ms32_decode(codex):
    if ((any(ord(x) &lt; 33 or ord(x) &gt; 126 for x in codex)) or
            (codex.lower() != codex and codex.upper() != codex)):
        return None
    codex = codex.lower()
    pos = codex.rfind(&quot;1&quot;)
    if pos &lt; 2 or not (48 &lt;= len(codex) &lt;= 127):
        return None
    if not all(x in CHARSET for x in codex[pos+1:]):
        return None
    if codex[:pos] != &quot;ms&quot; or codex[pos+1].isalpha() or codex[pos+1] == &quot;0&quot; and codex[pos+6] != &quot;s&quot;:
        return None
    data = [CHARSET.index(x) for x in codex[pos+1:]]
    if not ms32_verify_checksum(data):
        return None
    return data[:-13 if len(data) &lt; 94 else -15]  # See Long codex32 Strings
</code></pre>
<h3>Master seed format</h3>
<p>When the human-readable part of a valid codex32 secret (converted to lowercase) is the string &quot;ms&quot;, we call it a codex32-encoded master seed or secret seed. The payload in this case is a direct encoding of a BIP-0032 HD master seed.</p>
<p>A secret seed is a codex32 encoding of:</p>
<ul>
<li>The human-readable part &quot;ms&quot; for master seed.</li>
<li>The data-part values:
<ul>
<li>A threshold parameter, which MUST be a single digit between &quot;2&quot; and &quot;9&quot;, or the digit &quot;0&quot;.</li>
<li>An identifier consisting of 4 bech32 characters.
<ul>
<li>We do not define how to choose the identifier, beyond noting that it SHOULD be distinct for every master seed and share set the user may need to disambiguate.</li>
</ul>
</li>
<li>The share index &quot;s&quot;.</li>
<li>A conversion of the 16-to-64-byte BIP-0032 HD master seed to bech32:
<ul>
<li>Start with the bits of the master seed, most significant bit per byte first.</li>
<li>Re-arrange those bits into groups of 5, and pad with arbitrary bits at the end if needed.</li>
<li>Translate those bits to characters using the bech32 character table from BIP-0173.</li>
</ul>
</li>
<li>A valid checksum in accordance with the Checksum section.</li>
</ul>
</li>
</ul>
<h3>Recovering Secret</h3>
<p>When the share index of a valid codex32 string (converted to lowercase) is not the letter &quot;s&quot;, we call the string a codex32 share.
The first character of the data part indicates the threshold of the share, and it is required to be a non-&quot;0&quot; digit.</p>
<p>In order to recover a secret, one needs a set of valid shares such that:</p>
<ul>
<li>All shares have the same threshold value, the same identifier, and the same length.</li>
<li>All of the share index values are distinct.</li>
<li>The number of shares is exactly equal to the (common) threshold value.</li>
</ul>
<p>If all the above conditions are satisfied, the <code>ms32_recover</code> function will return a codex32 secret when its argument is the list of codex32 shares with each share represented as a list of integers representing the characters converted using the bech32 character table from BIP-0173. </p>
<pre><code>BECH32_INV = [
    0, 1, 20, 24, 10, 8, 12, 29, 5, 11, 4, 9, 6, 28, 26, 31,
    22, 18, 17, 23, 2, 25, 16, 19, 3, 21, 14, 30, 13, 7, 27, 15,
]

def bech32_mul(a, b):
    res = 0
    for i in range(5):
        res ^= a if ((b &gt;&gt; i) &amp; 1) else 0
        a *= 2
        a ^= 41 if (32 &lt;= a) else 0
    return res

def bech32_lagrange(l, x):
    n = 1
    c = []
    for i in l:
        n = bech32_mul(n, i ^ x)
        m = 1
        for j in l:
            m = bech32_mul(m, (x if i == j else i) ^ j)
        c.append(m)
    return [bech32_mul(n, BECH32_INV[i]) for i in c]

def ms32_interpolate(l, x):
    w = bech32_lagrange([s[5] for s in l], x)
    res = []
    for i in range(len(l[0])):
        n = 0
        for j in range(len(l)):
            n ^= bech32_mul(w[j], l[j][i])
        res.append(n)
    return res

def ms32_recover(shares):
    return ms32_interpolate(shares, 16)
</code></pre>
<h3>Generating Shares</h3>
<p>If we already have <em>k</em> valid codex32 strings such that:</p>
<ul>
<li>All strings have the same threshold value <em>k</em>, the same identifier, and the same length</li>
<li>All of the share index values are distinct</li>
</ul>
<p>Then we can derive additional shares with the <code>ms32_interpolate</code> function by passing it a list of exactly <em>k</em> of these codex32 strings, together with a fresh share index distinct from all of the existing share indexes.
The newly derived share will have the provided share index.</p>
<p>Once a user has generated <em>n</em> shares, they may discard the codex32 secret (if it exists).
The <em>n</em> shares form a <em>k</em> of <em>n</em> Shamir's secret sharing scheme of a codex32 secret.</p>
<p>There are two ways to create an initial set of <em>k</em> valid codex32 strings, depending on whether the user already has an existing secret to split.</p>
<h4>For a fresh secret</h4>
<p>In the case that the user wishes to generate a fresh secret, the user generates random initial shares, as follows:</p>
<ol>
<li>Choose a bitsize, between 128 and 512, which must be a multiple of 8</li>
<li>Choose a threshold value <em>k</em> between 2 and 9, inclusive</li>
<li>Choose a 4 bech32 character identifier
<ul>
<li>We do not define how to choose the identifier, beyond noting that it SHOULD be distinct for every secret the user may need to disambiguate</li>
</ul>
</li>
<li><em>k</em> many times, generate a random share by:
<ol>
<li>Take the next available letter from the bech32 alphabet, in alphabetical order, as <code>a</code>, <code>c</code>, <code>d</code>, ..., to be the share index</li>
<li>Set the first nine characters to be the prefix <code>ms1</code>, the threshold value <em>t</em>, the 4-character identifier, and then the share index</li>
<li>Choose the next ceil(<em>bitlength / 5</em>) characters uniformly at random</li>
<li>Generate a valid checksum in accordance with the Checksum section, and append this to the resulting shares</li>
</ol>
</li>
</ol>
<p>The result will be <em>k</em> distinct shares, all with the same initial 8 characters, and a distinct share index as the 9th character.</p>
<p>With this set of <em>k</em> shares, new shares can be derived as discussed above. This process generates a fresh secret, whose value can be retrieved by running the recovery process on any <em>k</em> of these shares.</p>
<h4>For an existing secret</h4>
<p>Before generating shares for an existing secret, it first must be codex32-encoded.
The conversion process consists of:</p>
<ol>
<li>Choose a threshold value <em>k</em> between 2 and 9, inclusive</li>
<li>Choose a 4 bech32 character identifier
<ul>
<li>We do not define how to choose the identifier, beyond noting that it SHOULD be distinct for every set of shares the user may need to disambiguate</li>
</ul>
</li>
<li>Set the share index to <code>s</code></li>
<li>Set the payload to a bech32 encoding of the secret data, padded with arbitrary bits</li>
<li>Generate a valid checksum in accordance with the Checksum section</li>
</ol>
<p>Along with the codex32 secret, the user must generate <em>k</em>-1 other codex32 shares, each with the same threshold value, the same identifier, and a distinct share index.
These shares should be generated as described in the &quot;fresh secret&quot; section.</p>
<p>The codex32 secret and the <em>k</em>-1 codex32 shares form a set of <em>k</em> valid initial codex32 strings from which additional shares can be derived as described above.</p>
<h3>Long codex32</h3>
<p>The 13 character checksum design only supports up to 80 data characters.
Excluding the threshold, identifier and index characters, this limits the payload to 74 characters or 46 bytes.
While this is enough to support the 32-byte advised size of BIP-0032 master seeds, BIP-0032 allows seeds to be up to 64 bytes in size.
We define a long codex32 format to support these longer seeds by defining an alternative checksum.</p>
<pre><code>MS32_LONG_CONST = 0x43381e570bf4798ab26

def ms32_long_polymod(values):
    GEN = [
        0x3d59d273535ea62d897,
        0x7a9becb6361c6c51507,
        0x543f9b7e6c38d8a2a0e,
        0x0c577eaeccf1990d13c,
        0x1887f74f8dc71b10651,
    ]
    residue = 0x23181b3
    for v in values:
        b = (residue &gt;&gt; 70)
        residue = (residue &amp; 0x3fffffffffffffffff) &lt;&lt; 5 ^ v
        for i in range(5):
            residue ^= GEN[i] if ((b &gt;&gt; i) &amp; 1) else 0
    return residue

def ms32_verify_long_checksum(data):
    return ms32_long_polymod(data) == MS32_LONG_CONST

def ms32_create_long_checksum(data):
    values = data
    polymod = ms32_long_polymod(values + [0] * 15) ^ MS32_LONG_CONST
    return [(polymod &gt;&gt; 5 * (14 - i)) &amp; 31 for i in range(15)]
</code></pre>
<p>This implements a <a href="https://en.wikipedia.org/wiki/BCH_code" target="_blank">BCH code</a> that
guarantees detection of <strong>any error affecting at most 8 characters</strong>
and has less than a 3 in 10<sup>23</sup> chance of failing to detect more
random errors.</p>
<p>A long codex32 string follows the same specification as a regular codex32 string with the following changes.</p>
<ul>
<li>The payload is a sequence of between 75 and 103 bech32 characters.</li>
<li>The checksum consists of 15 bech32 characters as defined above.</li>
</ul>
<p>A codex32 string with a data part of 94 or 95 characters is never legal as a regular codex32 string is limited to 93 data characters and a long codex32 string is at least 96 data characters.</p>
<p>Generation of long shares and recovery of the long secret from long shares proceeds in exactly the same way as for regular shares with the <code>ms32_interpolate</code> function.</p>
<p>The long checksum is designed to be an error correcting code that can correct up to 4 character substitutions, up to 8 unreadable characters (called erasures), or up to 15 consecutive erasures.
As with regular checksums we do not specify how an implementation should implement error correction, and all our recommendations for error correction of regular codex32 strings also apply to long codex32 strings.</p>
<h2>Rationale</h2>
<p>This scheme is based on the observation that the Lagrange interpolation of valid codewords in a BCH code will always be a valid codeword.
This means that derived shares will always have valid checksum, and a sufficient threshold of shares with valid checksums will derive a secret with a valid checksum.</p>
<p>The header system is also compatible with Lagrange interpolation, meaning all derived shares will have the same identifier and will have the appropriate share index.
This fact allows the header data to be covered by the checksum.</p>
<p>The checksum size and identifier size have been chosen so that the encoding of 128-bit master seeds and shares fit within 48 characters.
This is a standard size for many common seed storage formats, which has been popularized by the 12 four-letter word format of the BIP-0039 mnemonic.</p>
<p>The 13 character checksum is adequate to correct 4 errors in up to 93 characters (80 characters of data and 13 characters of the checksum).
We can correct up to 8 erasures (errors with known locations), and up to 13 consecutive errors (burst errors).
Beyond that, our code is guaranteed to detect up to 8 errors.
More generally, any number of random errors will be detected with overwhelming (1 - 2^65) probability. However, the checksum does not protect against maliciously constructed errors.
These parameters are slightly better than those of the checksum used in SLIP-0039.</p>
<p>For 256-bit seeds and shares our strings are 74 characters, which fits into the 96 character format of the 24 four-letter word format of the BIP-0039 mnemonic, with plenty of room to spare.</p>
<p>A longer checksum is needed to support up to 512-bit seeds, the longest seed length specified in BIP-0032, as the 13 character checksum isn't adequate for more than 80 data characters.
While we could use the 15 character checksum for both cases, we prefer to keep the strings as short as possible for the more common cases of 128-bit and 256-bit master seeds.
We only guarantee to correct 4 characters no matter how long the string is.
Longer strings mean more chances for transcription errors, so shorter strings are better.</p>
<p>The longest data part using the regular 13 character checksum is 93 characters and corresponds to a 368-bit secret.
At this length, the prefix <code>MS1</code> is not covered by the checksum.
This is acceptable because the checksum scheme itself requires you to know that the <code>MS1</code> prefix is being used in the first place.
If the prefix is damaged and a user is guessing that the data might be using this scheme, then the user can enter the available data explicitly using the suspected <code>MS1</code> prefix.</p>
<h3>Not BIP-0039 Entropy</h3>
<p>Instead of encoding a BIP-0032 master seed, an alternative would be to encode BIP-0039 entropy.
However this alternative approach is fraught with difficulties.</p>
<p>On approach would be to encode the BIP-0039 entropy along with the BIP-0039 checksum data.
This data can directly be recovered from the BIP-0039 mnemonic, and the process can be reversed if one knows the target language.
However, for a 128-bit seed, there is a 4 bit checksum yielding 132 bits of data that needs to be encoded.
This exceeds the 130-bits of room that we have for storing 128 bit seeds.
We would have to compromise on the 48 character size, or the size of the headers, or the size of the checksum in order to add room for an additional character of data.</p>
<p>This approach would also eliminate our short cut generation of a fresh master secret from generating random shares.
One would be required to first generate BIP-0039 entropy, and then add a BIP-0039 checksum, before adding a Codex32 checksum and then generate other shares.
In particular, this process could no longer be performed by hand since it is effectively impossible to hand compute a BIP-0039 checksum.</p>
<p>An alternative approach is to discard the BIP-0039 checksum, since it is inadequate for error correction anyways, and rely on the Codex32 checksum.
However, this approach ends up eliminating the benefits of BIP-0039 compatibility.
While it is now possible to hand generate fresh shares, it is impossible to recover compatible BIP-0039 words by hand because, again, the BIP-0039 checksum is not hand computable.
The only way of generating the compatible BIP-0039 mnemonic is to use wallet software.
But if the wallet software is need to support this approach to decoding entropy, we may as well bypass all of the overhead of BIP-0039 and directly encode the entropy of a BIP-0032 master seed, which is what we do in our Codex32 proposal.</p>
<p>Beyond the problems above, BIP-0039 does not define a single transformation from entropy to BIP-0032 master seed.
Instead every different language has it own word list (or word lists) and each choice of word list yields a different transformation from entropy to master seed.
We would need to encode the choice of word list in our share's meta-data, which takes up even more room, and is difficult to specify due to the ever-evolving choice of word lists.</p>
<p>Alternatively we could standardize on the choice of the English word list, something that is nearly a de facto standard, and simply be incompatible with BIP-0039 wallets of other languages.
Such a choice also risks users of BIP-0039 recovering their entropy from their language, encoding it in Codex32 and then failing to recover their wallet because the English word lists has replaced their language's word list.</p>
<p>The main advantage of this alternative approach would be that wallets could give users an option switch between backing up their entropy as a BIP-0039 mnemonic and in Codex32 format, but again, only if their language choice happens to be the English word list.
In practice, we do not expect users in switch back and forth between backup formats, and instead just generate a fresh master seed using Codex32.</p>
<p>Seeing little value with BIP-0039 compatibility (English-only), all the difficulties with BIP-0039 language choice, not to mention the PBKDF2 overhead of using BIP-0039, we think it is best to abandon BIP-0039 and encode BIP-0032 master seeds directly.
Our approach is semi-convertible with BIP-0039's 512-bit master seeds (in all languages, see Backwards Compatibility) and fully interconvertible with SLIP-39 encoded master seeds or any other encoding of BIP-0032 master seeds.</p>
<h2>Backwards Compatibility</h2>
<p>codex32 is an alternative to BIP-0039 and SLIP-0039.
It is technically possible to derive the BIP32 master seed from seed words encoded in one of these schemes, and then to encode this seed in codex32.
For BIP-0039 this process is irreversible, since it involves hashing the original words.
Furthermore, the resulting seed will be 512 bits long, which may be too large to be safely and conveniently handled.</p>
<p>SLIP-0039 seed words can be reversibly converted to master seeds, so it is possible to interconvert between SLIP-0039 and codex32.
However, SLIP-0039 <strong>shares</strong> cannot be converted to codex32 shares because the two schemes use a different underlying field.</p>
<p>The authors of this BIP do not recommend interconversion.
Instead, users who wish to switch to codex32 should generate a fresh seed and sweep their coins.</p>
<h2>Reference Implementation</h2>
<p>Our <a href="https://github.com/BlockstreamResearch/codex32" target="_blank"> reference implementation repository</a> contains implementations in Rust and PostScript.
The inline code in this BIP text can be used as a Python reference.</p>
<h2>Test Vectors</h2>
<h3>Test vector 1</h3>
<p>This example shows the codex32 format, when used without splitting the secret into any shares.
The payload contains 26 bech32 characters, which corresponds to 130 bits. We truncate the last two bits in order to obtain a 128-bit master seed.</p>
<p>codex32 secret (bech32): <code>ms10testsxxxxxxxxxxxxxxxxxxxxxxxxxx4nzvca9cmczlw</code></p>
<p>Master seed (hex): <code>318c6318c6318c6318c6318c6318c631</code></p>
<ul>
<li>human-readable part: <code>ms</code></li>
<li>separator: <code>1</code></li>
<li>k value: <code>0</code> (no secret splitting)</li>
<li>identifier: <code>test</code></li>
<li>share index: <code>s</code> (the secret)</li>
<li>payload: <code>xxxxxxxxxxxxxxxxxxxxxxxxxx</code></li>
<li>checksum: <code>4nzvca9cmczlw</code></li>
<li>master node xprv: <code>xprv9s21ZrQH143K3taPNekMd9oV5K6szJ8ND7vVh6fxicRUMDcChr3bFFzuxY8qP3xFFBL6DWc2uEYCfBFZ2nFWbAqKPhtCLRjgv78EZJDEfpL</code></li>
</ul>
<h3>Test vector 2</h3>
<p>This example shows generating a new master seed using &quot;random&quot; shares, as well as deriving an additional share, using <em>k</em>=2 and an identifier of <code>NAME</code>.
Although codex32 strings are canonically all lowercase, it's also valid to use all uppercase.</p>
<p>Share with index <code>A</code>: <code>MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM</code></p>
<p>Share with index <code>C</code>: <code>MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN</code></p>
<ul>
<li>Derived share with index <code>D</code>: <code>MS12NAMEDLL4F8JLH4E5VDVULDLFXU2JHDNLSM97XVENRXEG</code></li>
<li>Recovered secret seed with index <code>S</code>: <code>MS12NAMES6XQGUZTTXKEQNJSJZV4JV3NZ5K3KWGSPHUH6EVW</code></li>
<li>Master seed (hex): <code>d1808e096b35b209ca12132b264662a5</code></li>
<li>master node xprv: <code>xprv9s21ZrQH143K2NkobdHxXeyFDqE44nJYvzLFtsriatJNWMNKznGoGgW5UMTL4fyWtajnMYb5gEc2CgaKhmsKeskoi9eTimpRv2N11THhPTU</code></li>
</ul>
<h3>Test vector 3</h3>
<p>This example shows splitting an existing 128-bit master seed into &quot;random&quot; shares, using <em>k</em>=3 and an identifier of <code>cash</code>.
We appended two zero bits in order to obtain 26 bech32 characters (130 bits of data) from the 128-bit master seed.</p>
<p>Master seed (hex): <code>ffeeddccbbaa99887766554433221100</code></p>
<p>codex32-encoded master seed with index <code>s</code>: <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code></p>
<p>Share with index <code>a</code>: <code>ms13casha320zyxwvutsrqpnmlkjhgfedca2a8d0zehn8a0t</code></p>
<p>Share with index <code>c</code>: <code>ms13cashcacdefghjklmnpqrstuvwxyz023949xq35my48dr</code></p>
<ul>
<li>Derived share with index <code>d</code>: <code>ms13cashd0wsedstcdcts64cd7wvy4m90lm28w4ffupqs7rm</code></li>
<li>Derived share with index <code>e</code>: <code>ms13casheekgpemxzshcrmqhaydlp6yhms3ws7320xyxsar9</code></li>
<li>Derived share with index <code>f</code>: <code>ms13cashf8jh6sdrkpyrsp5ut94pj8ktehhw2hfvyrj48704</code></li>
<li>master node xprv: <code>xprv9s21ZrQH143K266qUcrDyYJrSG7KA3A7sE5UHndYRkFzsPQ6xwUhEGK1rNuyyA57Vkc1Ma6a8boVqcKqGNximmAe9L65WsYNcNitKRPnABd</code></li>
</ul>
<p>Any three of the five shares among <code>acdef</code> can be used to recover the secret.</p>
<p>Note that the choice to append two zero bits was arbitrary, and any of the following four codex32 secrets would have been valid choices.
However, each choice would have resulted in a different set of derived shares.</p>
<ul>
<li><code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code></li>
<li><code>ms13cashsllhdmn9m42vcsamx24zrxgs3qpte35dvzkjpt0r</code></li>
<li><code>ms13cashsllhdmn9m42vcsamx24zrxgs3qzfatvdwq5692k6</code></li>
<li><code>ms13cashsllhdmn9m42vcsamx24zrxgs3qrsx6ydhed97jx2</code></li>
</ul>
<h3>Test vector 4</h3>
<p>This example shows converting a 256-bit secret into a codex32 secret, without splitting the secret into any shares.
We appended four zero bits in order to obtain 52 bech32 characters (260 bits of data) from the 256-bit secret.</p>
<p>Master seed (hex): <code>ffeeddccbbaa99887766554433221100ffeeddccbbaa99887766554433221100</code></p>
<ul>
<li>codex32 secret: <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code></li>
<li>master node xprv: <code>xprv9s21ZrQH143K3s41UCWxXTsU4TRrhkpD1t21QJETan3hjo8DP5LFdFcB5eaFtV8x6Y9aZotQyP8KByUjgLTbXCUjfu2iosTbMv98g8EQoqr</code></li>
</ul>
<p>Note that the choice to append four zero bits was arbitrary, and any of the following sixteen codex32 secrets would have been valid:</p>
<ul>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqpj82dp34u6lqtd</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqzsrs4pnh7jmpj5</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqrfcpap2w8dqezy</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqy5tdvphn6znrf0</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq9dsuypw2ragmel</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqx05xupvgp4v6qx</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq8k0h5p43c2hzsk</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqgum7hplmjtr8ks</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqf9q0lpxzt5clxq</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq28y48pyqfuu7le</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqt7ly0paesr8x0f</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqvrvg7pqydv5uyz</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqd6hekpea5n0y5j</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqwcnrwpmlkmt9dt</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq0pgjxpzx0ysaam</code></li>
</ul>
<h3>Test vector 5</h3>
<p>This example shows generating a new 512-bit master seed using &quot;random&quot; bech32 characters and appending a checksum.
The payload contains 103 bech32 characters, which corresponds to 515 bits. The last three bits are discarded when converting to a 512-bit master seed.</p>
<p>This is an example of a <strong>Long codex32</strong> string.</p>
<p>k value (bech32): <code>0</code></p>
<p>identifier (bech32): <code>0C8V</code></p>
<p>payload (bech32): <code>M32ZXFGUHPCHTLUPZRY9X8GF2TVDW0S3JN54KHCE6MUA7LQPZYGSFJD6AN074RXVCEMLH8WU3TK925ACDEFGHJKLMNPQRSTUVWXY06F</code></p>
<ul>
<li>checksum: <code>HPV80UNDVARHRAK</code></li>
<li>codex32 secret: <code>MS100C8VSM32ZXFGUHPCHTLUPZRY9X8GF2TVDW0S3JN54KHCE6MUA7LQPZYGSFJD6AN074RXVCEMLH8WU3TK925ACDEFGHJKLMNPQRSTUVWXY06FHPV80UNDVARHRAK</code></li>
<li>Master seed (hex): <code>dc5423251cb87175ff8110c8531d0952d8d73e1194e95b5f19d6f9df7c01111104c9baecdfea8cccc677fb9ddc8aec5553b86e528bcadfdcc201c17c638c47e9</code></li>
<li>master node xprv: <code>xprv9s21ZrQH143K4UYT4rP3TZVKKbmRVmfRqTx9mG2xCy2JYipZbkLV8rwvBXsUbEv9KQiUD7oED1Wyi9evZzUn2rqK9skRgPkNaAzyw3YrpJN</code></li>
</ul>
<h3>Invalid test vectors</h3>
<p>These examples have incorrect checksums.</p>
<ul>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxve740yyge2ghq</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxve740yyge2ghp</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxlk3yepcstwr</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx6pgnv7jnpcsp</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxx0cpvr7n4geq</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxm5252y7d3lr</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxrd9sukzl05ej</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxc55srw5jrm0</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxgc7rwhtudwc</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx4gy22afwghvs</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxe8yfm0</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxvm597d</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxme084q0vpht7pe0</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxme084q0vpht7pew</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxqyadsp3nywm8a</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxzvg7ar4hgaejk</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcznau0advgxqe</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxch3jrc6j5040j</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx52gxl6ppv40mcv</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx7g4g2nhhle8fk</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx63m45uj8ss4x8</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy4r708q7kg65x</code></li>
</ul>
<p>These examples use the wrong checksum for their given data sizes.</p>
<ul>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxurfvwmdcmymdufv</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxcsyppjkd8lz4hx3</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxu6hwvl5p0l9xf3c</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwqey9rfs6smenxa</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxv70wkzrjr4ntqet</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx3hmlrmpa4zl0v</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxrfggf88znkaup</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxpt7l4aycv9qzj</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxus27z9xtyxyw3</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcwm4re8fs78vn</code></li>
</ul>
<p>These examples have improper lengths.
They are either too short, too long, or would decode to byte sequence with an incomplete group greater than 4 bits.</p>
<ul>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxw0a4c70rfefn4</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxk4pavy5n46nea</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx9lrwar5zwng4w</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxr335l5tv88js3</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxvu7q9nz8p7dj68v</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxpq6k542scdxndq3</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxkmfw6jm270mz6ej</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxzhddxw99w7xws</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxx42cux6um92rz</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxarja5kqukdhy9</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxky0ua3ha84qk8</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx9eheesxadh2n2n9</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx9llwmgesfulcj2z</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx02ev7caq6n9fgkf</code></li>
</ul>
<p>This example uses a &quot;0&quot; threshold with a non-&quot;s&quot; index</p>
<ul>
<li><code>ms10fauxxxxxxxxxxxxxxxxxxxxxxxxxxxx0z26tfn0ulw3p</code></li>
</ul>
<p>This example has a threshold that is not a digit.</p>
<ul>
<li><code>ms1fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxda3kr3s0s2swg</code></li>
</ul>
<p>These examples do not begin with the required &quot;ms&quot; or &quot;MS&quot; prefix and/or are missing the &quot;1&quot; separator.</p>
<ul>
<li><code>0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>ms0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>m10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>s10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxhkd4f70m8lgws</code></li>
<li><code>10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxhkd4f70m8lgws</code></li>
<li><code>m10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxx8t28z74x8hs4l</code></li>
<li><code>s10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxh9d0fhnvfyx3x</code></li>
</ul>
<p>These examples all incorrectly mix upper and lower case characters.</p>
<ul>
<li><code>Ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>mS10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>MS10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>ms10FAUXsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>ms10fauxSxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>ms10fauxsXXXXXXXXXXXXXXXXXXXXXXXXXXuqxkk05lyf3x2</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxUQXKK05LYF3X2</code></li>
</ul>
<h2>Appendix</h2>
<h3>Mathematical Companion</h3>
<p>Below we use the bech32 character set to denote values in GF[32].
In bech32, the letter <code>Q</code> denotes zero and the letter <code>P</code> denotes one.
The digits <code>0</code> and <code>2</code> through <code>9</code> do <em>not</em> denote their numeric values.
They are simply elements of GF[32].</p>
<p>The generating polynomial for our BCH code is as follows.</p>
<p>We extend GF[32] to GF[1024] by adjoining a primitive cube root of unity, <code></code>, satisfying <code>^2 =  + P</code>.</p>
<p>We select <code> := G </code> which has order 93, and construct the product <code>(x - ^i)</code> for <code>i</code> in <code>{17, 20, 46, 49, 52, 77, 78, 79, 80, 81, 82, 83, 84}</code>.
The resulting polynomial is our generating polynomial for our 13 character checksum:</p>
<pre><code>    x^13 + E x^12 + M x^11 + 3 x^10 + G x^9 + Q x^8 + E x^7 + E x^6 + E x^5 + L x^4 + M x^3 + C x^2 + S x + S
</code></pre>
<p>For our long checksum, we select <code> := E + X </code>, which has order 1023, and construct the product <code>(x - ^i)</code> for <code>i</code> in <code>{32, 64, 96, 895, 927, 959, 991, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026}</code>.
The resulting polynomial is our generating polynomial for our 15 character checksum for long strings:</p>
<pre><code>    x^15 + 0 x^14 + 2 x^13 + E x^12 + 6 x^11 + F x^10 + E x^9 + 4 x^8 + X x^7 + H x^6 + 4 x^5 + X x^4 + 9 x^3 + K x^2 + Y x^1 + H
</code></pre>
<p>(Reminder: the character <code>0</code> does <em>not</em> denote the zero of the field.)</p>

        </article>
    </div>


            <hr class="border-slate-700" />

            <div data-pagefind-ignore class="w-full flex flex-col items-center space-y-2 text-center">
                <div class="flex items-center space-x-2">
                    <p class="font-bold">Updated</p>
                    <p class="font-bold">2026-01-04</p>
                </div>
                <p>See an issue with rendering or formatting? Submit an issue on <a href="https://github.com/nickmonad/bips.dev" target="_blank">GitHub</a></p>
                <p>Do you find this site useful? Please consider <a href="https://buy.tryspeed.com/plink_live_lyek4a2yW2Sn2wfA" target="_blank">donating</a> some sats to support ongoing development.</p>
                <p><a href="/">bips.dev</a> is presented by <a href="https://nickmonad.blog" target="_blank">nickmonad</a></p>
                <p class="pt-4 text-sm">All content is owned and licensed by the respective author(s). This website makes no claim of ownership.</p>
            </div>
        </div>
    </div>
</body>
</html>
