<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="share and save bitcoin BIPs">
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="/style.css" />

    <title>bips.dev - BIP 93</title>
</head>

<body>
    <section class="section">
        <div class="container">
            
    <div class="level">
        <div class="level-left">
            <div class="level-item">
                <a href="/"><img src="/bips-dev-header.png" width="375", height="100" /></a>
            </div>
        </div>
        <div class="level-right">
            <div class="level-item">
                <a href="/">Back to BIPs</a>
            </div>
        </div>
    </div>

    <p class="is-size-3 has-text-weight-bold mb-0">
      BIP 93: codex32: Checksummed SSSS-aware BIP32 seeds
    </p>
    <div class="level is-mobile">
        <div class="level-left">
            <div class="level-item">
                <p class="subtitle"><strong>2023-02-13</strong></p>
            </div>
        </div>
        <div class="level-right">
            <div class="level-item">
                <a href="https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;blob&#x2F;master&#x2F;bip-0093.mediawiki">View on GitHub</a>
            </div>
        </div>
    </div>

    <div class="content">
      <pre style="background-color:#fafafa;color:#61676c;"><code><span>  BIP: 93
</span><span>  Layer: Applications
</span><span>  Title: codex32: Checksummed SSSS-aware BIP32 seeds
</span><span>  Author: Leon Olsson Curr and Pearlwort Sneed &lt;pearlwort@wpsoftware.net&gt;
</span><span>          Andrew Poelstra &lt;andrew.poelstra@gmail.com&gt;
</span><span>  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0093
</span><span>  Status: Draft
</span><span>  Type: Informational
</span><span>  Created: 2023-02-13
</span><span>  License: BSD-3-Clause
</span><span>  Post-History: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021469.html
</span></code></pre>
<h2 id="Introduction">Introduction</h2>
<h3 id="Abstract">Abstract</h3>
<p>This document describes a standard for backing up and restoring the
master seed of a
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-0032</a>
hierarchical deterministic wallet, using Shamir's secret sharing. It
includes an encoding format, a BCH error-correcting checksum, and
algorithms for share generation and secret recovery. Secret data can be
split into up to 31 shares. A minimum threshold of shares, which can be
between 1 and 9, is needed to recover the secret, whereas without
sufficient shares, no information about the secret is recoverable.</p>
<h3 id="Copyright">Copyright</h3>
<p>This document is licensed under the 3-clause BSD license.</p>
<h3 id="Motivation">Motivation</h3>
<p>BIP-0032 master seed data is the source entropy used to derive all
private keys in an HD wallet. Safely storing this secret data is the
hardest and most important part of self-custody. However, there is a
tension between security, which demands limiting the number of backups,
and resilience, which demands widely replicated backups. Encrypting the
seed does not change this fundamental tradeoff, since it leaves
essentially the same problem of how to back up the encryption key(s).</p>
<p>To allow users freedom to make this tradeoff, we use Shamir's secret
sharing, which guarantees that any number of shares less than the
threshold leaks no information about the secret. This approach allows
increasing safety by widely distributing the generated shares, while
also providing security against the compromise of one or more shares (as
long as fewer than the threshold have been compromised).</p>
<p><a rel="noopener" target="_blank" href="https://github.com/satoshilabs/slips/blob/master/slip-0039.md">SLIP-0039</a>
has essentially the same motivations as this standard. However, unlike
SLIP-0039,</p>
<ul>
<li>this standard aims to be simple enough for hand computation</li>
<li>we use the bech32 alphabet rather than a word list, resulting in
fixed-length compact encodings</li>
<li>we do not support multi-level secret sharing (splitting of shares),
although it is technically possible and may be added in a future BIP</li>
<li>because of the need to support hand computation, we <strong>do not</strong>
support passphrases or key hardening</li>
</ul>
<p>Users who demand a higher level of security for particular secrets, or
have a general distrust in digital electronic devices, have the option
of using hand computation to backup and restore secret data in an
interoperable manner. In particular, all computations can be done with
simple lookup tables. <strong>It is therefore possible to compute and verify
checksums, and to split and recover seeds, entirely using pen and
paper.</strong> For long-lived rarely-used seeds, the ability to hand-verify
checksums has a significant benefit even for users who do not care to do
any other part of this process by hand. It means that they can verify
the integrity (against non-malicious tampering) of their shares
regularly, say, on an annual basis, without needing to continually
expose secret data to new hardware.</p>
<p>The ability to compute properties by hand comes from our choice of a
small field and our use of linear error correcting codes. It does not
come with any reduction in security, as long as users use high-quality
randomness. Note that hand computation is optional, the particular
details of hand computation are outside the scope of this standard, and
implementers do not need to be concerned with this possibility.</p>
<p><a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-0039</a>
serves the same purpose as this standard: encoding master seeds for
storage by users. However, BIP-0039 has no error-correcting ability,
cannot sensibly be extended to support secret sharing, has no support
for versioning or other metadata, and has many technical design
decisions that make implementation and interoperability difficult (for
example, the use of SHA-512 to derive seeds, or the use of 11-bit
words).</p>
<h2 id="Specification">Specification</h2>
<h3 id="codex32">codex32</h3>
<p>A codex32 string is similar to a bech32 string defined in
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>.
It reuses the base-32 character set from BIP-0173, and consists of:</p>
<ul>
<li>A human-readable part, which is the string &quot;ms&quot; (or &quot;MS&quot;).</li>
<li>A separator, which is always &quot;1&quot;.</li>
<li>A data part which is in turn subdivided into:
<ul>
<li>A threshold parameter, which MUST be a single digit between &quot;2&quot;
and &quot;9&quot;, or the digit &quot;0&quot;.
<ul>
<li>If the threshold parameter is &quot;0&quot; then the share index,
defined below, MUST have a value of &quot;s&quot; (or &quot;S&quot;).</li>
</ul>
</li>
<li>An identifier consisting of 4 bech32 characters.</li>
<li>A share index, which is any bech32 character. Note that a share
index value of &quot;s&quot; (or &quot;S&quot;) is special and denotes the unshared
secret (see section &quot;Unshared Secret&quot;).</li>
<li>A payload which is a sequence of up to 74 bech32 characters.
(However, see <strong>Long codex32 Strings</strong> below for an exception to
this limit.)</li>
<li>A checksum which consists of 13 bech32 characters as described
below.</li>
</ul>
</li>
</ul>
<p>As with bech32 strings, a codex32 string MUST be entirely uppercase or
entirely lowercase. For presentation, lowercase is usually preferable,
but uppercase SHOULD be used for handwritten codex32 strings. If a
codex32 string is encoded in a QR code, it SHOULD use the uppercase
form, as this is encoded more compactly.</p>
<h3 id="Checksum">Checksum</h3>
<p>The last thirteen characters of the data part form a checksum and
contain no information. Valid strings MUST pass the criteria for
validity specified by the Python 3 code snippet below. The function
<code>ms32_verify_checksum</code> must return true when its argument is the data
part as a list of integers representing the characters converted using
the bech32 character table from BIP-0173.</p>
<p>To construct a valid checksum given the data-part characters (excluding
the checksum), the <code>ms32_create_checksum</code> function can be used.</p>
<pre data-lang="python" style="background-color:#fafafa;color:#61676c;" class="language-python "><code class="language-python" data-lang="python"><span>MS32_CONST </span><span style="color:#ed9366;">= </span><span style="color:#ff8f40;">0x10ce0795c2fd1e62a
</span><span>
</span><span style="color:#fa6e32;">def </span><span style="color:#f29718;">ms32_polymod</span><span>(</span><span style="color:#ff8f40;">values</span><span>):
</span><span>    GEN </span><span style="color:#ed9366;">= </span><span>[
</span><span>        </span><span style="color:#ff8f40;">0x19dc500ce73fde210</span><span style="color:#61676ccc;">,
</span><span>        </span><span style="color:#ff8f40;">0x1bfae00def77fe529</span><span style="color:#61676ccc;">,
</span><span>        </span><span style="color:#ff8f40;">0x1fbd920fffe7bee52</span><span style="color:#61676ccc;">,
</span><span>        </span><span style="color:#ff8f40;">0x1739640bdeee3fdad</span><span style="color:#61676ccc;">,
</span><span>        </span><span style="color:#ff8f40;">0x07729a039cfc75f5a</span><span style="color:#61676ccc;">,
</span><span>    ]
</span><span>    residue </span><span style="color:#ed9366;">= </span><span style="color:#ff8f40;">0x23181b3
</span><span>    </span><span style="color:#fa6e32;">for </span><span>v </span><span style="color:#fa6e32;">in </span><span>values:
</span><span>        b </span><span style="color:#ed9366;">= </span><span>(residue </span><span style="color:#ed9366;">&gt;&gt; </span><span style="color:#ff8f40;">60</span><span>)
</span><span>        residue </span><span style="color:#ed9366;">= </span><span>(residue </span><span style="color:#ed9366;">&amp; </span><span style="color:#ff8f40;">0x0fffffffffffffff</span><span>) </span><span style="color:#ed9366;">&lt;&lt; </span><span style="color:#ff8f40;">5 </span><span style="color:#ed9366;">^ </span><span>v
</span><span>        </span><span style="color:#fa6e32;">for </span><span>i </span><span style="color:#fa6e32;">in </span><span style="color:#f07171;">range</span><span>(</span><span style="color:#ff8f40;">5</span><span>):
</span><span>            residue </span><span style="color:#ed9366;">^= </span><span>GEN[i] </span><span style="color:#fa6e32;">if </span><span>((b </span><span style="color:#ed9366;">&gt;&gt; </span><span>i) </span><span style="color:#ed9366;">&amp; </span><span style="color:#ff8f40;">1</span><span>) </span><span style="color:#fa6e32;">else </span><span style="color:#ff8f40;">0
</span><span>    </span><span style="color:#fa6e32;">return </span><span>residue
</span><span>
</span><span style="color:#fa6e32;">def </span><span style="color:#f29718;">ms32_verify_checksum</span><span>(</span><span style="color:#ff8f40;">data</span><span>):
</span><span>    </span><span style="color:#fa6e32;">if </span><span style="color:#f07171;">len</span><span>(data) </span><span style="color:#ed9366;">&gt;= </span><span style="color:#ff8f40;">96</span><span>:                      </span><span style="font-style:italic;color:#abb0b6;"># See Long codex32 Strings
</span><span>        </span><span style="color:#fa6e32;">return </span><span style="color:#f29718;">ms32_verify_long_checksum</span><span>(data)
</span><span>    </span><span style="color:#fa6e32;">if </span><span style="color:#f07171;">len</span><span>(data) </span><span style="color:#ed9366;">&lt;= </span><span style="color:#ff8f40;">93</span><span>:
</span><span>        </span><span style="color:#fa6e32;">return </span><span style="color:#f29718;">ms32_polymod</span><span>(data) </span><span style="color:#ed9366;">== </span><span>MS32_CONST
</span><span>    </span><span style="color:#fa6e32;">return </span><span style="color:#ff8f40;">False
</span><span>
</span><span style="color:#fa6e32;">def </span><span style="color:#f29718;">ms32_create_checksum</span><span>(</span><span style="color:#ff8f40;">data</span><span>):
</span><span>    </span><span style="color:#fa6e32;">if </span><span style="color:#f07171;">len</span><span>(data) </span><span style="color:#ed9366;">&gt; </span><span style="color:#ff8f40;">80</span><span>:                       </span><span style="font-style:italic;color:#abb0b6;"># See Long codex32 Strings
</span><span>        </span><span style="color:#fa6e32;">return </span><span style="color:#f29718;">ms32_create_long_checksum</span><span>(data)
</span><span>    values </span><span style="color:#ed9366;">= </span><span>data
</span><span>    polymod </span><span style="color:#ed9366;">= </span><span style="color:#f29718;">ms32_polymod</span><span>(values </span><span style="color:#ed9366;">+ </span><span>[</span><span style="color:#ff8f40;">0</span><span>] </span><span style="color:#ed9366;">* </span><span style="color:#ff8f40;">13</span><span>) </span><span style="color:#ed9366;">^ </span><span>MS32_CONST
</span><span>    </span><span style="color:#fa6e32;">return </span><span>[(polymod </span><span style="color:#ed9366;">&gt;&gt; </span><span style="color:#ff8f40;">5 </span><span style="color:#ed9366;">* </span><span>(</span><span style="color:#ff8f40;">12 </span><span style="color:#ed9366;">- </span><span>i)) </span><span style="color:#ed9366;">&amp; </span><span style="color:#ff8f40;">31 </span><span style="color:#fa6e32;">for </span><span>i </span><span style="color:#fa6e32;">in </span><span style="color:#f07171;">range</span><span>(</span><span style="color:#ff8f40;">13</span><span>)]
</span></code></pre>
<h3 id="Error_Correction">Error Correction</h3>
<p>A codex32 string without a valid checksum MUST NOT be used. The checksum
is designed to be an error correcting code that can correct up to 4
character substitutions, up to 8 unreadable characters (called
erasures), or up to 13 consecutive erasures. Implementations SHOULD
provide the user with a corrected valid codex32 string if possible.
However, implementations SHOULD NOT automatically proceed with a
corrected codex32 string without user confirmation of the corrected
string, either by prompting the user, or returning a corrected string in
an error message and allowing the user to repeat their action. We do not
specify how an implementation should implement error correction.
However, we recommend that:</p>
<ul>
<li>Implementations make suggestions to substitute non-bech32 characters
with bech32 characters in some situations, such as replacing &quot;B&quot;
with &quot;8&quot;, &quot;O&quot; with &quot;0&quot;, &quot;I&quot; with &quot;l&quot;, etc.</li>
<li>Implementations interpret &quot;?&quot; as an erasure.</li>
<li>Implementations optionally interpret other non-bech32 characters, or
characters with incorrect case, as erasures.</li>
<li>If a string with 8 or fewer erasures can have those erasures filled
in to make a valid codex32 string, then the implementation suggests
such a string as a correction.</li>
<li>If a string consisting of valid bech32 characters in the proper case
can be made valid by substituting 4 or fewer characters, then the
implementation suggests such a string as a correction.</li>
</ul>
<h3 id="Unshared_Secret">Unshared Secret</h3>
<p>When the share index of a valid codex32 string (converted to lowercase)
is the letter &quot;s&quot;, we call the string a codex32 secret. The payload in a
codex32 secret is a direct encoding of a BIP-0032 HD master seed.</p>
<p>The master seed is decoded by converting the payload to bytes:</p>
<ul>
<li>Translate the characters to 5 bits values using the bech32 character
table from BIP-0173, most significant bit first.</li>
<li>Re-arrange those bits into groups of 8 bits. Any incomplete group at
the end MUST be 4 bits or less, and is discarded.</li>
</ul>
<p>Note that unlike the decoding process in BIP-0173, we do NOT require
that the incomplete group be all zeros.</p>
<p>For an unshared secret, the threshold parameter (the first character of
the data part) is ignored (beyond the fact it must be a digit for the
codex32 string to be valid). We recommend using the digit &quot;0&quot; for the
threshold parameter in this case. The 4 character identifier also has no
effect beyond aiding users in distinguishing between multiple different
master seeds in cases where they have more than one.</p>
<h3 id="Recovering_Master_Seed">Recovering Master Seed</h3>
<p>When the share index of a valid codex32 string (converted to lowercase)
is not the letter &quot;s&quot;, we call the string an codex32 share. The first
character of the data part indicates the threshold of the share, and it
is required to be a non-&quot;0&quot; digit.</p>
<p>In order to recover a master seed, one needs a set of valid codex32
shares such that:</p>
<ul>
<li>All shares have the same threshold value, the same identifier, and
the same length.</li>
<li>All of the share index values are distinct.</li>
<li>The number of codex32 shares is exactly equal to the (common)
threshold value.</li>
</ul>
<p>If all the above conditions are satisfied, the <code>ms32_recover</code> function
will return a codex32 secret when its argument is the list of codex32
shares with each share represented as a list of integers representing
the characters converted using the bech32 character table from BIP-0173.</p>
<pre data-lang="python" style="background-color:#fafafa;color:#61676c;" class="language-python "><code class="language-python" data-lang="python"><span>bech32_inv </span><span style="color:#ed9366;">= </span><span>[
</span><span>    </span><span style="color:#ff8f40;">0</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">1</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">20</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">24</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">10</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">8</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">12</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">29</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">5</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">11</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">4</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">9</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">6</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">28</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">26</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">31</span><span style="color:#61676ccc;">,
</span><span>    </span><span style="color:#ff8f40;">22</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">18</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">17</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">23</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">2</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">25</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">16</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">19</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">3</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">21</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">14</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">30</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">13</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">7</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">27</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">15</span><span style="color:#61676ccc;">,
</span><span>]
</span><span>
</span><span style="color:#fa6e32;">def </span><span style="color:#f29718;">bech32_mul</span><span>(</span><span style="color:#ff8f40;">a</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">b</span><span>):
</span><span>    res </span><span style="color:#ed9366;">= </span><span style="color:#ff8f40;">0
</span><span>    </span><span style="color:#fa6e32;">for </span><span>i </span><span style="color:#fa6e32;">in </span><span style="color:#f07171;">range</span><span>(</span><span style="color:#ff8f40;">5</span><span>):
</span><span>        res </span><span style="color:#ed9366;">^= </span><span>a </span><span style="color:#fa6e32;">if </span><span>((b </span><span style="color:#ed9366;">&gt;&gt; </span><span>i) </span><span style="color:#ed9366;">&amp; </span><span style="color:#ff8f40;">1</span><span>) </span><span style="color:#fa6e32;">else </span><span style="color:#ff8f40;">0
</span><span>        a </span><span style="color:#ed9366;">*= </span><span style="color:#ff8f40;">2
</span><span>        a </span><span style="color:#ed9366;">^= </span><span style="color:#ff8f40;">41 </span><span style="color:#fa6e32;">if </span><span>(</span><span style="color:#ff8f40;">32 </span><span style="color:#ed9366;">&lt;= </span><span>a) </span><span style="color:#fa6e32;">else </span><span style="color:#ff8f40;">0
</span><span>    </span><span style="color:#fa6e32;">return </span><span>res
</span><span>
</span><span style="color:#fa6e32;">def </span><span style="color:#f29718;">bech32_lagrange</span><span>(</span><span style="color:#ff8f40;">l</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">x</span><span>):
</span><span>    n </span><span style="color:#ed9366;">= </span><span style="color:#ff8f40;">1
</span><span>    c </span><span style="color:#ed9366;">= </span><span>[]
</span><span>    </span><span style="color:#fa6e32;">for </span><span>i </span><span style="color:#fa6e32;">in </span><span>l:
</span><span>        n </span><span style="color:#ed9366;">= </span><span style="color:#f29718;">bech32_mul</span><span>(n</span><span style="color:#61676ccc;">, </span><span>i </span><span style="color:#ed9366;">^ </span><span>x)
</span><span>        m </span><span style="color:#ed9366;">= </span><span style="color:#ff8f40;">1
</span><span>        </span><span style="color:#fa6e32;">for </span><span>j </span><span style="color:#fa6e32;">in </span><span>l:
</span><span>            m </span><span style="color:#ed9366;">= </span><span style="color:#f29718;">bech32_mul</span><span>(m</span><span style="color:#61676ccc;">, </span><span>(x </span><span style="color:#fa6e32;">if </span><span>i </span><span style="color:#ed9366;">== </span><span>j </span><span style="color:#fa6e32;">else </span><span>i) </span><span style="color:#ed9366;">^ </span><span>j)
</span><span>        c</span><span style="color:#ed9366;">.</span><span style="color:#f29718;">append</span><span>(m)
</span><span>    </span><span style="color:#fa6e32;">return </span><span>[</span><span style="color:#f29718;">bech32_mul</span><span>(n</span><span style="color:#61676ccc;">, </span><span>bech32_inv[i]) </span><span style="color:#fa6e32;">for </span><span>i </span><span style="color:#fa6e32;">in </span><span>c]
</span><span>
</span><span style="color:#fa6e32;">def </span><span style="color:#f29718;">ms32_interpolate</span><span>(</span><span style="color:#ff8f40;">l</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">x</span><span>):
</span><span>    w </span><span style="color:#ed9366;">= </span><span style="color:#f29718;">bech32_lagrange</span><span>([s[</span><span style="color:#ff8f40;">5</span><span>] </span><span style="color:#fa6e32;">for </span><span>s </span><span style="color:#fa6e32;">in </span><span>l]</span><span style="color:#61676ccc;">, </span><span>x)
</span><span>    res </span><span style="color:#ed9366;">= </span><span>[]
</span><span>    </span><span style="color:#fa6e32;">for </span><span>i </span><span style="color:#fa6e32;">in </span><span style="color:#f07171;">range</span><span>(</span><span style="color:#f07171;">len</span><span>(l[</span><span style="color:#ff8f40;">0</span><span>])):
</span><span>        n </span><span style="color:#ed9366;">= </span><span style="color:#ff8f40;">0
</span><span>        </span><span style="color:#fa6e32;">for </span><span>j </span><span style="color:#fa6e32;">in </span><span style="color:#f07171;">range</span><span>(</span><span style="color:#f07171;">len</span><span>(l)):
</span><span>            n </span><span style="color:#ed9366;">^= </span><span style="color:#f29718;">bech32_mul</span><span>(w[j]</span><span style="color:#61676ccc;">, </span><span>l[j][i])
</span><span>        res</span><span style="color:#ed9366;">.</span><span style="color:#f29718;">append</span><span>(n)
</span><span>    </span><span style="color:#fa6e32;">return </span><span>res
</span><span>
</span><span style="color:#fa6e32;">def </span><span style="color:#f29718;">ms32_recover</span><span>(</span><span style="color:#ff8f40;">l</span><span>):
</span><span>    </span><span style="color:#fa6e32;">return </span><span style="color:#f29718;">ms32_interpolate</span><span>(l</span><span style="color:#61676ccc;">, </span><span style="color:#ff8f40;">16</span><span>)
</span></code></pre>
<h3 id="Generating_Shares">Generating Shares</h3>
<p>If we already have <em>t</em> valid codex32 strings such that:</p>
<ul>
<li>All strings have the same threshold value <em>t</em>, the same identifier,
and the same length</li>
<li>All of the share index values are distinct</li>
</ul>
<p>Then we can derive additional shares with the <code>ms32_interpolate</code>
function by passing it a list of exactly <em>t</em> of these codex32 strings,
together with a fresh share index distinct from all of the existing
share indexes. The newly derived share will have the provided share
index.</p>
<p>Once a user has generated <em>n</em> codex32 shares, they may discard the
codex32 secret (if it exists). The <em>n</em> shares form a <em>t</em> of <em>n</em> Shamir's
secret sharing scheme of a codex32 secret.</p>
<p>There are two ways to create an initial set of <em>t</em> valid codex32
strings, depending on whether the user already has an existing master
seed to split.</p>
<h4 id="For_a_fresh_master_seed">For a fresh master seed</h4>
<p>In the case that the user wishes to generate a fresh master seed, the
user generates random initial shares, as follows:</p>
<ol>
<li>Choose a bitsize, between 128 and 512, which must be a multiple of
8.</li>
<li>Choose a threshold value <em>t</em> between 2 and 9, inclusive</li>
<li>Choose a 4 bech32 character identifier
<ul>
<li>We do not define how to choose the identifier, beyond noting
that it SHOULD be distinct for every master seed the user may
need to disambiguate.</li>
</ul>
</li>
<li><em>t</em> many times, generate a random share by:
<ol>
<li>Take the next available letter from the bech32 alphabet, in
alphabetical order, as <code>a</code>, <code>c</code>, <code>d</code>, ..., to be the share index</li>
<li>Set the first nine characters to be the prefix <code>ms1</code>, the
threshold value <em>t</em>, the 4-character identifier, and then the
share index</li>
<li>Choose the next ceil(<em>bitlength / 5</em>) characters uniformly at
random</li>
<li>Generate a valid checksum in accordance with the Checksum
section, and append this to the resulting shares</li>
</ol>
</li>
</ol>
<p>The result will be <em>t</em> distinct shares, all with the same initial 8
characters, and a distinct share index as the 9th character.</p>
<p>With this set of <em>t</em> codex32 shares, new shares can be derived as
discussed above. This process generates a fresh master seed, whose value
can be retrieved by running the recovery process on any <em>t</em> of these
shares.</p>
<h4 id="For_an_existing_master_seed">For an existing master seed</h4>
<p>Before generating shares for an existing master seed, it first must be
converted into a codex32 secret, as described above. The conversion
process consists of:</p>
<ol>
<li>Choose a threshold value <em>t</em> between 2 and 9, inclusive</li>
<li>Choose a 4 bech32 character identifier
<ul>
<li>We do not define how to choose the identifier, beyond noting
that it SHOULD be distinct for every master seed the user may
need to disambiguate.</li>
</ul>
</li>
<li>Set the share index to <code>s</code></li>
<li>Set the payload to a bech32 encoding of the master seed, padded with
arbitrary bits</li>
<li>Generating a valid checksum in accordance with the Checksum section</li>
</ol>
<p>Along with the codex32 secret, the user must generate <em>t</em>-1 other
codex32 shares, each with the same threshold value, the same identifier,
and a distinct share index. These shares should be generated as
described in the &quot;fresh master seed&quot; section.</p>
<p>The codex32 secret and the <em>t</em>-1 codex32 shares form a set of <em>t</em> valid
codex32 strings from which additional shares can be derived as described
above.</p>
<h3 id="Long_codex32_Strings">Long codex32 Strings</h3>
<p>The 13 character checksum design only supports up to 80 data characters.
Excluding the threshold, identifier and index characters, this limits
the payload to 74 characters or 46 bytes. While this is enough to
support the 32-byte advised size of BIP-0032 master seeds, BIP-0032
allows seeds to be up to 64 bytes in size. We define a long codex32
string format to support these longer seeds by defining an alternative
checksum.</p>
<pre data-lang="python" style="background-color:#fafafa;color:#61676c;" class="language-python "><code class="language-python" data-lang="python"><span>MS32_LONG_CONST </span><span style="color:#ed9366;">= </span><span style="color:#ff8f40;">0x43381e570bf4798ab26
</span><span>
</span><span style="color:#fa6e32;">def </span><span style="color:#f29718;">ms32_long_polymod</span><span>(</span><span style="color:#ff8f40;">values</span><span>):
</span><span>    GEN </span><span style="color:#ed9366;">= </span><span>[
</span><span>        </span><span style="color:#ff8f40;">0x3d59d273535ea62d897</span><span style="color:#61676ccc;">,
</span><span>        </span><span style="color:#ff8f40;">0x7a9becb6361c6c51507</span><span style="color:#61676ccc;">,
</span><span>        </span><span style="color:#ff8f40;">0x543f9b7e6c38d8a2a0e</span><span style="color:#61676ccc;">,
</span><span>        </span><span style="color:#ff8f40;">0x0c577eaeccf1990d13c</span><span style="color:#61676ccc;">,
</span><span>        </span><span style="color:#ff8f40;">0x1887f74f8dc71b10651</span><span style="color:#61676ccc;">,
</span><span>    ]
</span><span>    residue </span><span style="color:#ed9366;">= </span><span style="color:#ff8f40;">0x23181b3
</span><span>    </span><span style="color:#fa6e32;">for </span><span>v </span><span style="color:#fa6e32;">in </span><span>values:
</span><span>        b </span><span style="color:#ed9366;">= </span><span>(residue </span><span style="color:#ed9366;">&gt;&gt; </span><span style="color:#ff8f40;">70</span><span>)
</span><span>        residue </span><span style="color:#ed9366;">= </span><span>(residue </span><span style="color:#ed9366;">&amp; </span><span style="color:#ff8f40;">0x3fffffffffffffffff</span><span>) </span><span style="color:#ed9366;">&lt;&lt; </span><span style="color:#ff8f40;">5 </span><span style="color:#ed9366;">^ </span><span>v
</span><span>        </span><span style="color:#fa6e32;">for </span><span>i </span><span style="color:#fa6e32;">in </span><span style="color:#f07171;">range</span><span>(</span><span style="color:#ff8f40;">5</span><span>):
</span><span>            residue </span><span style="color:#ed9366;">^= </span><span>GEN[i] </span><span style="color:#fa6e32;">if </span><span>((b </span><span style="color:#ed9366;">&gt;&gt; </span><span>i) </span><span style="color:#ed9366;">&amp; </span><span style="color:#ff8f40;">1</span><span>) </span><span style="color:#fa6e32;">else </span><span style="color:#ff8f40;">0
</span><span>    </span><span style="color:#fa6e32;">return </span><span>residue
</span><span>
</span><span style="color:#fa6e32;">def </span><span style="color:#f29718;">ms32_verify_long_checksum</span><span>(</span><span style="color:#ff8f40;">data</span><span>):
</span><span>    </span><span style="color:#fa6e32;">return </span><span style="color:#f29718;">ms32_long_polymod</span><span>(data) </span><span style="color:#ed9366;">== </span><span>MS32_LONG_CONST
</span><span>
</span><span style="color:#fa6e32;">def </span><span style="color:#f29718;">ms32_create_long_checksum</span><span>(</span><span style="color:#ff8f40;">data</span><span>):
</span><span>    values </span><span style="color:#ed9366;">= </span><span>data
</span><span>    polymod </span><span style="color:#ed9366;">= </span><span style="color:#f29718;">ms32_long_polymod</span><span>(values </span><span style="color:#ed9366;">+ </span><span>[</span><span style="color:#ff8f40;">0</span><span>] </span><span style="color:#ed9366;">* </span><span style="color:#ff8f40;">15</span><span>) </span><span style="color:#ed9366;">^ </span><span>MS32_LONG_CONST
</span><span>    </span><span style="color:#fa6e32;">return </span><span>[(polymod </span><span style="color:#ed9366;">&gt;&gt; </span><span style="color:#ff8f40;">5 </span><span style="color:#ed9366;">* </span><span>(</span><span style="color:#ff8f40;">14 </span><span style="color:#ed9366;">- </span><span>i)) </span><span style="color:#ed9366;">&amp; </span><span style="color:#ff8f40;">31 </span><span style="color:#fa6e32;">for </span><span>i </span><span style="color:#fa6e32;">in </span><span style="color:#f07171;">range</span><span>(</span><span style="color:#ff8f40;">15</span><span>)]
</span></code></pre>
<p>A long codex32 string follows the same specification as a regular
codex32 string with the following changes.</p>
<ul>
<li>The payload is a sequence of between 75 and 103 bech32 characters.</li>
<li>The checksum consists of 15 bech32 characters as defined above.</li>
</ul>
<p>A codex32 string with a data part of 94 or 95 characters is never legal
as a regular codex32 string is limited to 93 data characters and a long
codex32 string is at least 96 characters.</p>
<p>Generation of long shares and recovery of the master seed from long
shares proceeds in exactly the same way as for regular shares with the
<code>ms32_interpolate</code> function.</p>
<p>The long checksum is designed to be an error correcting code that can
correct up to 4 character substitutions, up to 8 unreadable characters
(called erasures), or up to 15 consecutive erasures. As with regular
checksums we do not specify how an implementation should implement error
correction, and all our recommendations for error correction of regular
codex32 strings also apply to long codex32 strings.</p>
<h2 id="Rationale">Rationale</h2>
<p>This scheme is based on the observation that the Lagrange interpolation
of valid codewords in a BCH code will always be a valid codeword. This
means that derived shares will always have valid checksum, and a
sufficient threshold of shares with valid checksums will derive a secret
with a valid checksum.</p>
<p>The header system is also compatible with Lagrange interpolation,
meaning all derived shares will have the same identifier and will have
the appropriate share index. This fact allows the header data to be
covered by the checksum.</p>
<p>The checksum size and identifier size have been chosen so that the
encoding of 128-bit seeds and shares fit within 48 characters. This is a
standard size for many common seed storage formats, which has been
popularized by the 12 four-letter word format of the BIP-0039 mnemonic.</p>
<p>The 13 character checksum is adequate to correct 4 errors in up to 93
characters (80 characters of data and 13 characters of the checksum). We
can correct up to 8 erasures (errors with known locations), and up to 13
consecutive errors (burst errors). Beyond that, our code is guaranteed
to detect up to 8 errors. More generally, any number of random errors
will be detected with overwhelming (1 - 2^65) probability. However, the
checksum does not protect against maliciously constructed errors. These
parameters are slightly better than those of the checksum used in
SLIP-0039.</p>
<p>For 256-bit seeds and shares our strings are 74 characters, which fits
into the 96 character format of the 24 four-letter word format of the
BIP-0039 mnemonic, with plenty of room to spare.</p>
<p>A longer checksum is needed to support up to 512-bit seeds, the longest
seed length specified in BIP-0032, as the 13 character checksum isn't
adequate for more than 80 data characters. While we could use the 15
character checksum for both cases, we prefer to keep the strings as
short as possible for the more common cases of 128-bit and 256-bit
master seeds. We only guarantee to correct 4 characters no matter how
long the string is. Longer strings mean more chances for transcription
errors, so shorter strings are better.</p>
<p>The longest data part using the regular 13 character checksum is 93
characters and corresponds to a 400-bit secret. At this length, the
prefix <code>MS1</code> is not covered by the checksum. This is acceptable because
the checksum scheme itself requires you to know that the <code>MS1</code> prefix is
being used in the first place. If the prefix is damaged and a user is
guessing that the data might be using this scheme, then the user can
enter the available data explicitly using the suspected <code>MS1</code> prefix.</p>
<h3 id="Not_BIP-0039_Entropy">Not BIP-0039 Entropy</h3>
<p>Instead of encoding a BIP-0032 master seed, an alternative would be to
encode BIP-0039 entropy. However this alternative approach is fraught
with difficulties.</p>
<p>On approach would be to encode the BIP-0039 entropy along with the
BIP-0039 checksum data. This data can directly be recovered from the
BIP-0039 mnemonic, and the process can be reversed if one knows the
target language. However, for a 128-bit seed, there is a 4 bit checksum
yielding 132 bits of data that needs to be encoded. This exceeds the
130-bits of room that we have for storing 128 bit seeds. We would have
to compromise on the 48 character size, or the size of the headers, or
the size of the checksum in order to add room for an additional
character of data.</p>
<p>This approach would also eliminate our short cut generation of a fresh
master secret from generating random shares. One would be required to
first generate BIP-0039 entropy, and then add a BIP-0039 checksum,
before adding a Codex32 checksum and then generate other shares. In
particular, this process could no longer be performed by hand since it
is effectively impossible to hand compute a BIP-0039 checksum.</p>
<p>An alternative approach is to discard the BIP-0039 checksum, since it is
inadequate for error correction anyways, and rely on the Codex32
checksum. However, this approach ends up eliminating the benefits of
BIP-0039 compatibility. While it is now possible to hand generate fresh
shares, it is impossible to recover compatible BIP-0039 words by hand
because, again, the BIP-0039 checksum is not hand computable. The only
way of generating the compatible BIP-0039 mnemonic is to use wallet
software. But if the wallet software is need to support this approach to
decoding entropy, we may as well bypass all of the overhead of BIP-0039
and directly encode the entropy of a BIP-0032 master seed, which is what
we do in our Codex32 proposal.</p>
<p>Beyond the problems above, BIP-0039 does not define a single
transformation from entropy to BIP-0032 master seed. Instead every
different language has it own word list (or word lists) and each choice
of word list yields a different transformation from entropy to master
seed. We would need to encode the choice of word list in our share's
meta-data, which takes up even more room, and is difficult to specify
due to the ever-evolving choice of word lists.</p>
<p>Alternatively we could standardize on the choice of the English word
list, something that is nearly a de facto standard, and simply be
incompatible with BIP-0039 wallets of other languages. Such a choice
also risks users of BIP-0039 recovering their entropy from their
language, encoding it in in Codex32 and then failing to recover their
wallet because the English word lists has replaced their language's word
list.</p>
<p>The main advantage of this alternative approach would be that wallets
could give users an option switch between backing up their entropy as a
BIP-0039 mnemonic and in Codex32 format, but again, only if their
language choice happens to be the English word list. In practice, we do
not expect users in switch back and forth between backup formats, and
instead just generate a fresh master seed using Codex32.</p>
<p>Seeing little value with BIP-0039 compatibility (English-only), all the
difficulties with BIP-0039 language choice, not to mention the PBKDF2
overhead of using BIP-0039, we think it is best to abandon BIP-0039 and
encode BIP-0032 master seeds directly. Our approach is semi-convertible
with BIP-0039's 512-bit master seeds (in all languages, see Backwards
Compatibility) and fully interconvertible with SLIP-39 encoded master
seeds or any other encoding of BIP-0032 master seeds.</p>
<h2 id="Backwards_Compatibility">Backwards Compatibility</h2>
<p>codex32 is an alternative to BIP-0039 and SLIP-0039. It is technically
possible to derive the BIP32 master seed from seed words encoded in one
of these schemes, and then to encode this seed in codex32. For BIP-0039
this process is irreversible, since it involves hashing the original
words. Furthermore, the resulting seed will be 512 bits long, which may
be too large to be safely and conveniently handled.</p>
<p>SLIP-0039 seed words can be reversibly converted to master seeds, so it
is possible to interconvert between SLIP-0039 and codex32. However,
SLIP-0039 <strong>shares</strong> cannot be converted to codex32 shares because the
two schemes use a different underlying field.</p>
<p>The authors of this BIP do not recommend interconversion. Instead, users
who wish to switch to codex32 should generate a fresh seed and sweep
their coins.</p>
<h2 id="Reference_Implementation">Reference Implementation</h2>
<p>Our <a rel="noopener" target="_blank" href="https://github.com/BlockstreamResearch/codex32">reference implementation
repository</a> contains
implementations in Rust and PostScript. The inline code in this BIP text
can be used as a Python reference.</p>
<h2 id="Test_Vectors">Test Vectors</h2>
<h3 id="Test_vector_1">Test vector 1</h3>
<p>This example shows the codex32 format, when used without splitting the
secret into any shares. The payload contains 26 bech32 characters, which
corresponds to 130 bits. We truncate the last two bits in order to
obtain a 128-bit master seed.</p>
<p>codex32 secret (bech32):
<code>ms10testsxxxxxxxxxxxxxxxxxxxxxxxxxx4nzvca9cmczlw</code></p>
<p>Master secret (hex): <code>318c6318c6318c6318c6318c6318c631</code></p>
<ul>
<li>human-readable part: <code>ms</code></li>
<li>separator: <code>1</code></li>
<li>k value: <code>0</code> (no secret splitting)</li>
<li>identifier: <code>test</code></li>
<li>share index: <code>s</code> (the secret)</li>
<li>payload: <code>xxxxxxxxxxxxxxxxxxxxxxxxxx</code></li>
<li>checksum: <code>4nzvca9cmczlw</code></li>
<li>master node xprv:
<code>xprv9s21ZrQH143K3taPNekMd9oV5K6szJ8ND7vVh6fxicRUMDcChr3bFFzuxY8qP3xFFBL6DWc2uEYCfBFZ2nFWbAqKPhtCLRjgv78EZJDEfpL</code></li>
</ul>
<h3 id="Test_vector_2">Test vector 2</h3>
<p>This example shows generating a new master seed using &quot;random&quot; codex32
shares, as well as deriving an additional codex32 share, using <em>k</em>=2 and
an identifier of <code>NAME</code>. Although codex32 strings are canonically all
lowercase, it's also valid to use all uppercase.</p>
<p>Share with index <code>A</code>: <code>MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM</code></p>
<p>Share with index <code>C</code>: <code>MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN</code></p>
<ul>
<li>Derived share with index <code>D</code>:
<code>MS12NAMEDLL4F8JLH4E5VDVULDLFXU2JHDNLSM97XVENRXEG</code></li>
<li>Secret share with index <code>S</code>:
<code>MS12NAMES6XQGUZTTXKEQNJSJZV4JV3NZ5K3KWGSPHUH6EVW</code></li>
<li>Master secret (hex): <code>d1808e096b35b209ca12132b264662a5</code></li>
<li>master node xprv:
<code>xprv9s21ZrQH143K2NkobdHxXeyFDqE44nJYvzLFtsriatJNWMNKznGoGgW5UMTL4fyWtajnMYb5gEc2CgaKhmsKeskoi9eTimpRv2N11THhPTU</code></li>
</ul>
<p>Note that per BIP-0173, the lowercase form is used when determining a
character's value for checksum purposes. In particular, given an all
uppercase codex32 string, we still use lowercase <code>ms</code> as the
human-readable part during checksum construction.</p>
<h3 id="Test_vector_3">Test vector 3</h3>
<p>This example shows splitting an existing 128-bit master seed into
&quot;random&quot; codex32 shares, using <em>k</em>=3 and an identifier of <code>cash</code>. We
appended two zero bits in order to obtain 26 bech32 characters (130 bits
of data) from the 128-bit master seed.</p>
<p>Master secret (hex): <code>ffeeddccbbaa99887766554433221100</code></p>
<p>Secret share with index <code>s</code>:
<code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code></p>
<p>Share with index <code>a</code>: <code>ms13casha320zyxwvutsrqpnmlkjhgfedca2a8d0zehn8a0t</code></p>
<p>Share with index <code>c</code>: <code>ms13cashcacdefghjklmnpqrstuvwxyz023949xq35my48dr</code></p>
<ul>
<li>Derived share with index <code>d</code>:
<code>ms13cashd0wsedstcdcts64cd7wvy4m90lm28w4ffupqs7rm</code></li>
<li>Derived share with index <code>e</code>:
<code>ms13casheekgpemxzshcrmqhaydlp6yhms3ws7320xyxsar9</code></li>
<li>Derived share with index <code>f</code>:
<code>ms13cashf8jh6sdrkpyrsp5ut94pj8ktehhw2hfvyrj48704</code></li>
<li>master node xprv:
<code>xprv9s21ZrQH143K266qUcrDyYJrSG7KA3A7sE5UHndYRkFzsPQ6xwUhEGK1rNuyyA57Vkc1Ma6a8boVqcKqGNximmAe9L65WsYNcNitKRPnABd</code></li>
</ul>
<p>Any three of the five shares among <code>acdef</code> can be used to recover the
secret.</p>
<p>Note that the choice to append two zero bits was arbitrary, and any of
the following four secret shares would have been valid choices. However,
each choice would have resulted in a different set of derived shares.</p>
<ul>
<li><code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code></li>
<li><code>ms13cashsllhdmn9m42vcsamx24zrxgs3qpte35dvzkjpt0r</code></li>
<li><code>ms13cashsllhdmn9m42vcsamx24zrxgs3qzfatvdwq5692k6</code></li>
<li><code>ms13cashsllhdmn9m42vcsamx24zrxgs3qrsx6ydhed97jx2</code></li>
</ul>
<h3 id="Test_vector_4">Test vector 4</h3>
<p>This example shows converting a 256-bit secret into a codex32 secret,
without splitting the secret into any shares. We appended four zero bits
in order to obtain 52 bech32 characters (260 bits of data) from the
256-bit secret.</p>
<p>256-bit secret (hex):
<code>ffeeddccbbaa99887766554433221100ffeeddccbbaa99887766554433221100</code></p>
<ul>
<li>codex32 secret:
<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code></li>
<li>master node xprv:
<code>xprv9s21ZrQH143K3s41UCWxXTsU4TRrhkpD1t21QJETan3hjo8DP5LFdFcB5eaFtV8x6Y9aZotQyP8KByUjgLTbXCUjfu2iosTbMv98g8EQoqr</code></li>
</ul>
<p>Note that the choice to append four zero bits was arbitrary, and any of
the following sixteen codex32 secrets would have been valid:</p>
<ul>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqpj82dp34u6lqtd</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqzsrs4pnh7jmpj5</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqrfcpap2w8dqezy</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqy5tdvphn6znrf0</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq9dsuypw2ragmel</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqx05xupvgp4v6qx</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq8k0h5p43c2hzsk</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqgum7hplmjtr8ks</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqf9q0lpxzt5clxq</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq28y48pyqfuu7le</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqt7ly0paesr8x0f</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqvrvg7pqydv5uyz</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqd6hekpea5n0y5j</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqwcnrwpmlkmt9dt</code></li>
<li><code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq0pgjxpzx0ysaam</code></li>
</ul>
<h3 id="Test_vector_5">Test vector 5</h3>
<p>This example shows generating a new 512-bit master seed using &quot;random&quot;
codex32 characters and appending a checksum. The payload contains 103
bech32 characters, which corresponds to 515 bits. The last three bits
are discarded when converting to a 512-bit master seed.</p>
<p>This is an example of a <strong>Long codex32 String</strong>.</p>
<ul>
<li>Secret share with index <code>S</code>:
<code>MS100C8VSM32ZXFGUHPCHTLUPZRY9X8GF2TVDW0S3JN54KHCE6MUA7LQPZYGSFJD6AN074RXVCEMLH8WU3TK925ACDEFGHJKLMNPQRSTUVWXY06FHPV80UNDVARHRAK</code></li>
<li>Master secret (hex):
<code>dc5423251cb87175ff8110c8531d0952d8d73e1194e95b5f19d6f9df7c01111104c9baecdfea8cccc677fb9ddc8aec5553b86e528bcadfdcc201c17c638c47e9</code></li>
<li>master node xprv:
<code>xprv9s21ZrQH143K4UYT4rP3TZVKKbmRVmfRqTx9mG2xCy2JYipZbkLV8rwvBXsUbEv9KQiUD7oED1Wyi9evZzUn2rqK9skRgPkNaAzyw3YrpJN</code></li>
</ul>
<h3 id="Invalid_test_vectors">Invalid test vectors</h3>
<p>These examples have incorrect checksums.</p>
<ul>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxve740yyge2ghq</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxve740yyge2ghp</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxlk3yepcstwr</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx6pgnv7jnpcsp</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxx0cpvr7n4geq</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxm5252y7d3lr</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxrd9sukzl05ej</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxc55srw5jrm0</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxgc7rwhtudwc</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx4gy22afwghvs</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxe8yfm0</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxvm597d</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxme084q0vpht7pe0</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxme084q0vpht7pew</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxqyadsp3nywm8a</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxzvg7ar4hgaejk</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcznau0advgxqe</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxch3jrc6j5040j</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx52gxl6ppv40mcv</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx7g4g2nhhle8fk</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx63m45uj8ss4x8</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy4r708q7kg65x</code></li>
</ul>
<p>These examples use the wrong checksum for their given data sizes.</p>
<ul>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxurfvwmdcmymdufv</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxcsyppjkd8lz4hx3</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxu6hwvl5p0l9xf3c</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwqey9rfs6smenxa</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxv70wkzrjr4ntqet</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx3hmlrmpa4zl0v</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxrfggf88znkaup</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxpt7l4aycv9qzj</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxus27z9xtyxyw3</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcwm4re8fs78vn</code></li>
</ul>
<p>These examples have improper lengths. They are either too short, too
long, or would decode to byte sequence with an incomplete group greater
than 4 bits.</p>
<ul>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxw0a4c70rfefn4</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxk4pavy5n46nea</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx9lrwar5zwng4w</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxr335l5tv88js3</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxvu7q9nz8p7dj68v</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxpq6k542scdxndq3</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxkmfw6jm270mz6ej</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxzhddxw99w7xws</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxx42cux6um92rz</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxarja5kqukdhy9</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxky0ua3ha84qk8</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx9eheesxadh2n2n9</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx9llwmgesfulcj2z</code></li>
<li><code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx02ev7caq6n9fgkf</code></li>
</ul>
<p>This example uses a &quot;0&quot; threshold with a non-&quot;s&quot; index</p>
<ul>
<li><code>ms10fauxxxxxxxxxxxxxxxxxxxxxxxxxxxx0z26tfn0ulw3p</code></li>
</ul>
<p>This example has a threshold that is not a digit.</p>
<ul>
<li><code>ms1fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxda3kr3s0s2swg</code></li>
</ul>
<p>These examples do not begin with the required &quot;ms&quot; or &quot;MS&quot; prefix and/or
are missing the &quot;1&quot; separator.</p>
<ul>
<li><code>0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>ms0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>m10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>s10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxhkd4f70m8lgws</code></li>
<li><code>10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxhkd4f70m8lgws</code></li>
<li><code>m10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxx8t28z74x8hs4l</code></li>
<li><code>s10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxh9d0fhnvfyx3x</code></li>
</ul>
<p>These examples all incorrectly mix upper and lower case characters.</p>
<ul>
<li><code>Ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>mS10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>MS10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>ms10FAUXsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>ms10fauxSxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code></li>
<li><code>ms10fauxsXXXXXXXXXXXXXXXXXXXXXXXXXXuqxkk05lyf3x2</code></li>
<li><code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxUQXKK05LYF3X2</code></li>
</ul>
<h2 id="Appendix">Appendix</h2>
<h3 id="Mathematical_Companion">Mathematical Companion</h3>
<p>Below we use the bech32 character set to denote values in GF[32]. In
bech32, the letter <code>Q</code> denotes zero and the letter <code>P</code> denotes one. The
digits <code>0</code> and <code>2</code> through <code>9</code> do <em>not</em> denote their numeric values.
They are simply elements of GF[32].</p>
<p>The generating polynomial for our BCH code is as follows.</p>
<p>We extend GF[32] to GF[1024] by adjoining a primitive cube root of
unity, <code></code>, satisfying <code>^2 =  + P</code>.</p>
<p>We select <code> := G </code> which has order 93, and construct the product <code>(x - ^i)</code> for <code>i</code> in <code>{17, 20, 46, 49, 52, 77, 78, 79, 80, 81, 82, 83, 84}</code>.
The resulting polynomial is our generating polynomial for our 13
character checksum:</p>
<p><code>x^13+Ex^12+Mx^11+3x^10+Gx^9+Qx^8+Ex^7+Ex^6+Ex^5+Lx^4+Mx^3+Cx^2+Sx+S</code></p>
<p>For our long checksum, we select <code> := E + X </code>, which has order 1023,
and construct the product <code>(x - ^i)</code> for <code>i</code> in
<code>{32, 64, 96, 895, 927, 959, 991, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026}</code>.
The resulting polynomial is our generating polynomial for our 15
character checksum for long strings:</p>
<p><code>x^15+0x^14+2x^13+Ex^12+6x^11+Fx^10+Ex^9+4x^8+Xx^7+Hx^6+4x^5+Xx^4+9x^3+Kx^2+Yx^1+H</code></p>
<p>(Reminder: the character <code>0</code> does <em>not</em> denote the zero of the field.)</p>

    </div>

        </div>
    </section>
    <footer class="footer">
        <div class="container has-text-centered has-text-weight-bold is-family-monospace">
            <p class="mb-1">Updated <span class="tag is-medium is-warning is-light">2024-02-27</span></p>
            <p>bips.dev - Made with &#x2615; by <a href="https://nickmonad.blog">nickmonad</a></p>
            <p>Check it out on <a href="https://github.com/nickmonad/bips-dev">GitHub</a></p>
            <p>Stay humble. Stack sats. &#x20bf;</p>
        </div>
    </footer>

     
</body>
</html>
