<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="share and save bitcoin BIPs">
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="/style.css" />

    <title>bips.dev - BIP 327</title>
</head>

<body>
    <section class="section">
        <div class="container">
            
    <div class="level">
        <div class="level-left">
            <div class="level-item">
                <a href="/"><img src="/bips-dev-header.png" width="375", height="100" /></a>
            </div>
        </div>
        <div class="level-right">
            <div class="level-item">
                <a href="/">Back to BIPs</a>
            </div>
        </div>
    </div>

    <p class="is-size-3 has-text-weight-bold mb-0">
      BIP 327: MuSig2 for BIP340-compatible Multi-Signatures
    </p>
    <div class="level is-mobile">
        <div class="level-left">
            <div class="level-item">
                <p class="subtitle"><strong>2022-03-22</strong></p>
            </div>
        </div>
        <div class="level-right">
            <div class="level-item">
                <a href="https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;blob&#x2F;master&#x2F;bip-0327.mediawiki">View on GitHub</a>
            </div>
        </div>
    </div>

    <div class="content">
      <pre style="background-color:#fafafa;color:#61676c;"><code><span>  BIP: 327
</span><span>  Title: MuSig2 for BIP340-compatible Multi-Signatures
</span><span>  Author: Jonas Nick &lt;jonasd.nick@gmail.com&gt;
</span><span>          Tim Ruffing &lt;crypto@timruffing.de&gt;
</span><span>          Elliott Jin &lt;elliott.jin@gmail.com&gt;
</span><span>  Status: Draft
</span><span>  License: BSD-3-Clause
</span><span>  Type: Informational
</span><span>  Created: 2022-03-22
</span><span>  Post-History: 2022-04-05: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020198.html [bitcoin-dev] MuSig2 BIP
</span><span>                2022-10-11: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html [bitcoin-dev] MuSig2 BIP
</span><span>  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0327
</span></code></pre>
<h2 id="Introduction">Introduction</h2>
<h3 id="Abstract">Abstract</h3>
<p>This document proposes a standard for the
<a rel="noopener" target="_blank" href="https://eprint.iacr.org/2020/1261.pdf">MuSig2</a> multi-signature scheme.
The standard is compatible with
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP340</a>
public keys and signatures. It supports <em>tweaking</em>, which allows
deriving
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a>
child keys from aggregate public keys and creating
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP341</a>
Taproot outputs with key and script paths.</p>
<h3 id="Copyright">Copyright</h3>
<p>This document is licensed under the 3-clause BSD license.</p>
<h3 id="Motivation">Motivation</h3>
<p>MuSig2 is a multi-signature scheme that allows multiple signers to
create a single aggregate public key and cooperatively create ordinary
Schnorr signatures valid under the aggregate public key. Signing
requires interaction between <em>all</em> signers involved in key aggregation.
(MuSig2 is a <em>n-of-n</em> multi-signature scheme and not a <em>t-of-n</em>
threshold-signature scheme.)</p>
<p>The primary motivation is to create a standard that allows users of
different software projects to jointly control Taproot outputs
(<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP341</a>).
Such an output contains a public key which, in this case, would be the
aggregate of all users' individual public keys. It can be spent using
MuSig2 to produce a signature for the key-based spending path.</p>
<p>The on-chain footprint of a MuSig2 Taproot output is essentially a
single BIP340 public key, and a transaction spending the output only
requires a single signature cooperatively produced by all signers. This
is <strong>more compact</strong> and has <strong>lower verification cost</strong> than each signer
providing an individual public key and signature, as would be required
by an <em>n-of-n</em> policy implemented using <code>OP_CHECKSIGADD</code> as introduced
in
(<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki">BIP342</a>).
As a side effect, the number <em>n</em> of signers is not limited by any
consensus rules when using MuSig2.</p>
<p>Moreover, MuSig2 offers a <strong>higher level of privacy</strong> than
<code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a
blockchain observer from regular, single-signer Taproot outputs even
though they are actually controlled by multiple signers. By tweaking an
aggregate public key, the shared Taproot output can have script spending
paths that are hidden unless used.</p>
<p>There are multi-signature schemes other than MuSig2 that are fully
compatible with Schnorr signatures. The MuSig2 variant proposed below
stands out by combining all the following features:</p>
<ul>
<li><strong>Simple Key Setup</strong>: Key aggregation is non-interactive and fully
compatible with BIP340 public keys.</li>
<li><strong>Two Communication Rounds</strong>: MuSig2 is faster in practice than
previous three-round multi-signature schemes such as
<a rel="noopener" target="_blank" href="https://eprint.iacr.org/2018/068.pdf">MuSig1</a>, particularly when
signers are connected through high-latency anonymous links.
Moreover, the need for fewer communication rounds simplifies the
algorithms and reduces the probability that implementations and
users make security-relevant mistakes.</li>
<li><strong>Provable security</strong>: MuSig2 has been <a rel="noopener" target="_blank" href="https://eprint.iacr.org/2020/1261.pdf">proven existentially
unforgeable</a> under the
algebraic one-more discrete logarithm (AOMDL) assumption (instead of
the discrete logarithm assumption required for single-signer Schnorr
signatures). AOMDL is a falsifiable and weaker variant of the
well-studied OMDL problem.</li>
<li><strong>Low complexity</strong>: MuSig2 has a substantially lower computational
and implementation complexity than alternative schemes like
<a rel="noopener" target="_blank" href="https://eprint.iacr.org/2020/1057">MuSig-DN</a>. However, this comes
at the cost of having no ability to generate nonces
deterministically and the requirement to securely handle signing
state.</li>
</ul>
<h3 id="Design">Design</h3>
<ul>
<li><strong>Compatibility with BIP340</strong>: In this proposal, the aggregate
public key is a BIP340 X-only public key, and the signature output
at the end of the signing protocol is a BIP340 signature that passes
BIP340 verification for the aggregate public key and a message. The
individual public keys that are input to the key aggregation
algorithm are <em>plain</em> public keys in compressed format.</li>
<li><strong>Tweaking for BIP32 derivations and Taproot</strong>: This proposal
supports tweaking aggregate public keys and signing for tweaked
aggregate public keys. We distinguish two modes of tweaking: <em>Plain</em>
tweaking can be used to derive child aggregate public keys per
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a>.
<em>X-only</em> tweaking, on the other hand, allows creating a
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP341</a>
tweak to add script paths to a Taproot output. See
<a href="https://bips.dev/327/#tweaking-the-aggregate-public-key" title="wikilink">below</a> for details.</li>
<li><strong>Non-interactive signing with preprocessing</strong>: The first
communication round, exchanging the nonces, can happen before the
message or the exact set of signers is determined. Once the
parameters of the signing session are finalized, the signers can
send partial signatures without additional interaction.</li>
<li><strong>Key aggregation optionally independent of order</strong>: The output of
the key aggregation algorithm depends on the order in which the
individual public keys are provided as input. Key aggregation does
not sort the individual public keys by default because applications
often already have a canonical order of signers. Nonetheless,
applications can mandate sorting before aggregation,[1] and this
proposal specifies a canonical order to sort the individual public
keys before key aggregation. Sorting will ensure the same output,
independent of the initial order.</li>
<li><strong>Third-party nonce and partial signature aggregation</strong>: Instead of
every signer sending their nonce and partial signature to every
other signer, it is possible to use an untrusted third-party
<em>aggregator</em> in order to reduce the communication complexity from
quadratic to linear in the number of signers. In each of the two
rounds, the aggregator collects all signers' contributions (nonces
or partial signatures), aggregates them, and broadcasts the
aggregate back to the signers. A malicious aggregator can force the
signing session to fail to produce a valid Schnorr signature but
cannot negatively affect the unforgeability of the scheme.</li>
<li><strong>Partial signature verification</strong>: If any signer sends a partial
signature contribution that was not created by honestly following
the signing protocol, the signing session will fail to produce a
valid Schnorr signature. This proposal specifies a partial signature
verification algorithm to identify disruptive signers. It is
incompatible with third-party nonce aggregation because the
individual nonce is required for partial verification.</li>
<li><strong>MuSig2* optimization</strong>: This proposal uses an optimized scheme
MuSig2*, which allows saving a point multiplication in key
aggregation as compared to MuSig2. MuSig2* is proven secure in the
appendix of the <a rel="noopener" target="_blank" href="https://eprint.iacr.org/2020/1261">MuSig2 paper</a>.
The optimization consists of assigning the constant key aggregation
coefficient <em>1</em> to the second distinct key in the list of individual
public keys to be aggregated (as well as to any key identical to
this key).</li>
<li><strong>Size of the nonce and security</strong>: In this proposal, each signer's
nonce consists of two elliptic curve points. The <a rel="noopener" target="_blank" href="https://eprint.iacr.org/2020/1261">MuSig2
paper</a> gives distinct security
proofs depending on the number of points that constitute a nonce.
See section <a href="https://bips.dev/327/#choosing-the-size-of-the-nonce" title="wikilink">Choosing the Size of the
Nonce</a> for a discussion.</li>
</ul>
<h2 id="Overview">Overview</h2>
<p>Implementers must make sure to understand this section thoroughly to
avoid subtle mistakes that may lead to catastrophic failure.</p>
<h3 id="Optionality_of_Features">Optionality of Features</h3>
<p>The goal of this proposal is to support a wide range of possible
application scenarios. Given a specific application scenario, some
features may be unnecessary or not desirable, and implementers can
choose not to support them. Such optional features include:</p>
<ul>
<li>Applying plain tweaks after x-only tweaks.</li>
<li>Applying tweaks at all.</li>
<li>Dealing with messages that are not exactly 32 bytes.</li>
<li>Identifying a disruptive signer after aborting (aborting itself
remains mandatory).</li>
<li>Dealing with duplicate individual public keys in key aggregation.</li>
</ul>
<p>If applicable, the corresponding algorithms should simply fail when
encountering inputs unsupported by a particular implementation. (For
example, the signing algorithm may fail when given a message which is
not 32 bytes.) Similarly, the test vectors that exercise the
unimplemented features should be re-interpreted to expect an error, or
be skipped if appropriate.</p>
<h3 id="General_Signing_Flow">General Signing Flow</h3>
<p>The signers start by exchanging their individual public keys and
computing an aggregate public key using the <em>KeyAgg</em> algorithm. Whenever
they want to sign a message, the basic order of operations to create a
multi-signature is as follows:</p>
<p><strong>First broadcast round:</strong> The signers start the signing session by
running <em>NonceGen</em> to compute <em>secnonce</em> and <em>pubnonce</em>.[2] Then, the
signers broadcast their <em>pubnonce</em> to each other and run <em>NonceAgg</em> to
compute an aggregate nonce.</p>
<p><strong>Second broadcast round:</strong> At this point, every signer has the required
data to sign, which, in the algorithms specified below, is stored in a
data structure called <a href="https://bips.dev/327/#session-context" title="wikilink">Session Context</a>.
Every signer computes a partial signature by running <em>Sign</em> with the
secret signing key, the <em>secnonce</em> and the session context. Then, the
signers broadcast their partial signatures to each other and run
<em>PartialSigAgg</em> to obtain the final signature. If all signers behaved
honestly, the result passes
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP340</a>
verification.</p>
<p>Both broadcast rounds can be optimized by using an aggregator who
collects all signers' nonces or partial signatures, aggregates them
using <em>NonceAgg</em> or <em>PartialSigAgg</em>, respectively, and broadcasts the
aggregate result back to the signers. A malicious aggregator can force
the signing session to fail to produce a valid Schnorr signature but
cannot negatively affect the unforgeability of the scheme, i.e., even a
malicious aggregator colluding with all but one signer cannot forge a
signature.</p>
<p><strong>IMPORTANT</strong>: The <em>Sign</em> algorithm must <strong>not</strong> be executed twice with
the same <em>secnonce</em>. Otherwise, it is possible to extract the secret
signing key from the two partial signatures output by the two executions
of <em>Sign</em>. To avoid accidental reuse of <em>secnonce</em>, an implementation
may securely erase the <em>secnonce</em> argument by overwriting it with 64
zero bytes after it has been read by <em>Sign</em>. A <em>secnonce</em> consisting of
only zero bytes is invalid for <em>Sign</em> and will cause it to fail.</p>
<p>To simplify the specification of the algorithms, some intermediary
values are unnecessarily recomputed from scratch, e.g., when executing
<em>GetSessionValues</em> multiple times. Actual implementations can cache
these values. As a result, the <a href="https://bips.dev/327/#session-context" title="wikilink">Session
Context</a> may look very different in
implementations or may not exist at all. However, computation of
<em>GetSessionValues</em> and storage of the result must be protected against
modification from an untrusted third party. This party would have
complete control over the aggregate public key and message to be signed.</p>
<h3 id="Public_Key_Aggregation">Public Key Aggregation</h3>
<p>We distinguish between two public key types, namely <em>plain public keys</em>,
the key type traditionally used in Bitcoin, and <em>X-only public keys</em>.
Plain public keys are byte strings of length 33 (often called
<em>compressed</em> format). In contrast, X-only public keys are 32-byte
strings defined in
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP340</a>.</p>
<p>The individual public keys of signers as input to the key aggregation
algorithm <em>KeyAgg</em> (and to <em>GetSessionValues</em> and <em>PartialSigVerify</em>)
are plain public keys. The output of <em>KeyAgg</em> is a <a href="https://bips.dev/327/#keyagg-context" title="wikilink">KeyAgg
Context</a> which stores information required
for tweaking the aggregate public key (see
<a href="https://bips.dev/327/#tweaking-the-aggregate-public-key" title="wikilink">below</a>), and it can be
used to produce an X-only aggregate public key, or a plain aggregate
public key. In order to obtain an X-only public key compatible with
BIP340 verification, implementations call the <em>GetXonlyPubkey</em> function
with the KeyAgg Context. To get the plain aggregate public key, which is
required for some applications of
<a href="https://bips.dev/327/#tweaking-the-aggregate-public-key" title="wikilink">tweaking</a>,
implementations call <em>GetPlainPubkey</em> instead.</p>
<p>The aggregate public key produced by <em>KeyAgg</em> (regardless of the type)
depends on the order of the individual public keys. If the application
does not have a canonical order of the signers, the individual public
keys can be sorted with the <em>KeySort</em> algorithm to ensure that the
aggregate public key is independent of the order of signers.</p>
<p>The same individual public key is allowed to occur more than once in the
input of <em>KeyAgg</em> and <em>KeySort</em>. This is by design: All algorithms in
this proposal handle multiple signers who (claim to) have identical
individual public keys properly, and applications are not required to
check for duplicate individual public keys. In fact, applications are
recommended to omit checks for duplicate individual public keys in order
to simplify error handling. Moreover, it is often impossible to tell at
key aggregation which signer is to blame for the duplicate, i.e., which
signer came up with an individual public key honestly and which
disruptive signer copied it. In contrast, MuSig2 is designed to identify
disruptive signers at signing time (see <a href="https://bips.dev/327/#identifiying-disruptive-signers" title="wikilink">Identifiying Disruptive
Signers</a>).</p>
<p>While the algorithms in this proposal are able to handle duplicate
individual public keys, there are scenarios where applications may
choose to abort when encountering duplicates. For example, we can
imagine a scenario where a single entity creates a MuSig2 setup with
multiple signing devices. In that case, duplicates may not result from a
malicious signing device copying an individual public key of another
signing device but from accidental initialization of two devices with
the same seed. Since MuSig2 key aggregation would accept the duplicate
keys and not error out, which would in turn reduce the security compared
to the intended key setup, applications may reject duplicate individual
public keys before passing them to MuSig2 key aggregation and ask the
user to investigate.</p>
<h3 id="Nonce_Generation">Nonce Generation</h3>
<p><strong>IMPORTANT</strong>: <em>NonceGen</em> must have access to a high-quality random
generator to draw an unbiased, uniformly random value ''rand' ''. In
contrast to BIP340 signing, the values <em>k<sub>1</sub></em> and
<em>k<sub>2</sub></em> <strong>must not be derived deterministically</strong> from the
session parameters because otherwise active adversaries can <a rel="noopener" target="_blank" href="https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6">trick the
victim into reusing a
nonce</a>.</p>
<p>The optional arguments to <em>NonceGen</em> enable a defense-in-depth mechanism
that may prevent secret key exposure if ''rand' '' is accidentally not
drawn uniformly at random. If the value ''rand' '' was identical in two
<em>NonceGen</em> invocations, but any other argument was different, the
<em>secnonce</em> would still be guaranteed to be different as well (with
overwhelming probability), and thus accidentally using the same
<em>secnonce</em> for <em>Sign</em> in both sessions would be avoided. Therefore, it
is recommended to provide the optional arguments <em>sk</em>, <em>aggpk</em>, and <em>m</em>
if these session parameters are already determined during nonce
generation. The auxiliary input <em>extra_in</em> can contain additional
contextual data that has a chance of changing between <em>NonceGen</em> runs,
e.g., a supposedly unique session id (taken from the application), a
session counter wide enough not to repeat in practice, any nonces by
other signers (if already known), or the serialization of a data
structure containing multiple of the above. However, the protection
provided by the optional arguments should only be viewed as a last
resort. In most conceivable scenarios, the assumption that the arguments
are different between two executions of <em>NonceGen</em> is relatively strong,
particularly when facing an active adversary.</p>
<p>In some applications, it is beneficial to generate and send a <em>pubnonce</em>
before the other signers, their individual public keys, or the message
to sign is known. In this case, only the available arguments are
provided to the <em>NonceGen</em> algorithm. After this preprocessing phase,
the <em>Sign</em> algorithm can be run immediately when the message and set of
signers is determined. This way, the final signature is created quicker
and with fewer round trips. However, applications that use this method
presumably store the nonces for a longer time and must therefore be even
more careful not to reuse them. Moreover, this method is not compatible
with the defense-in-depth mechanism described in the previous paragraph.</p>
<p>Instead of every signer broadcasting their <em>pubnonce</em> to every other
signer, the signers can send their <em>pubnonce</em> to a single aggregator
node that runs <em>NonceAgg</em> and sends the <em>aggnonce</em> back to the signers.
This technique reduces the overall communication. A malicious aggregator
can force the signing session to fail to produce a valid Schnorr
signature but cannot negatively affect the unforgeability of the scheme.</p>
<p>In general, MuSig2 signers are stateful in the sense that they first
generate <em>secnonce</em> and then need to store it until they receive the
other signers' <em>pubnonces</em> or the <em>aggnonce</em>. However, it is possible
for one of the signers to be stateless. This signer waits until it
receives the <em>pubnonce</em> of all the other signers and until session
parameters such as a message to sign, individual public keys, and tweaks
are determined. Then, the signer can run <em>NonceGen</em>, <em>NonceAgg</em> and
<em>Sign</em> in sequence and send out its <em>pubnonce</em> along with its partial
signature. Stateless signers may want to consider signing
deterministically (see <a href="https://bips.dev/327/#modifications-to-nonce-generation" title="wikilink">Modifications to Nonce
Generation</a>) to remove
the reliance on the random number generator in the <em>NonceGen</em> algorithm.</p>
<h3 id="Identifying_Disruptive_Signers">Identifying Disruptive Signers</h3>
<p>The signing protocol makes it possible to identify malicious signers who
send invalid contributions to a signing session in order to make the
signing session abort and prevent the honest signers from obtaining a
valid signature. This property is called &quot;identifiable aborts&quot; and
ensures that honest parties can assign blame to malicious signers who
cause an abort in the signing protocol.</p>
<p>Aborts are identifiable for an honest party if the following conditions
hold in a signing session:</p>
<ul>
<li>The contributions received from all signers have not been tampered
with (e.g., because they were sent over authenticated connections).</li>
<li>Nonce aggregation is performed honestly (e.g., because the honest
signer performs nonce aggregation on its own or because the
aggregator is trusted).</li>
<li>The partial signatures received from all signers are verified using
the algorithm <em>PartialSigVerify</em>.</li>
</ul>
<p>If these conditions hold and an honest party (signer or aggregator) runs
an algorithm that fails due to invalid protocol contributions from
malicious signers, then the algorithm run by the honest party will
output the index of exactly one malicious signer. Additionally, if the
honest parties agree on the contributions sent by all signers in the
signing session, all the honest parties who run the aborting algorithm
will identify the same malicious signer.</p>
<h4 id="Further_Remarks">Further Remarks</h4>
<p>Some of the algorithms specified below may also assign blame to a
malicious aggregator. While this is possible for some particular
misbehavior of the aggregator, it is not guaranteed that a malicious
aggregator can be identified. More specifically, a malicious aggregator
(whose existence violates the second condition above) can always make
signing abort and wrongly hold honest signers accountable for the abort
(e.g., by claiming to have received an invalid contribution from a
particular honest signer).</p>
<p>The only purpose of the algorithm <em>PartialSigVerify</em> is to ensure
identifiable aborts, and it is not necessary to use it when identifiable
aborts are not desired. In particular, partial signatures are <em>not</em>
signatures. An adversary can forge a partial signature, i.e., create a
partial signature without knowing the secret key for the claimed
individual public key.[3] However, if <em>PartialSigVerify</em> succeeds for
all partial signatures then <em>PartialSigAgg</em> will return a valid Schnorr
signature.[4]</p>
<h3 id="Tweaking_the_Aggregate_Public_Key">Tweaking the Aggregate Public Key</h3>
<p>The aggregate public key can be <em>tweaked</em>, which modifies the key as
defined in the <a href="https://bips.dev/327/#tweaking-definition" title="wikilink">Tweaking Definition</a>
subsection. In order to apply a tweak, the KeyAgg Context output by
<em>KeyAgg</em> is provided to the <em>ApplyTweak</em> algorithm with the
<em>is_xonly_t</em> argument set to false for plain tweaking and true for
X-only tweaking. The resulting KeyAgg Context can be used to apply
another tweak with <em>ApplyTweak</em> or obtain the aggregate public key with
<em>GetXonlyPubkey</em> or <em>GetPlainPubkey</em>.</p>
<p>In addition to individual public keys, the <em>KeyAgg</em> algorithm accepts
tweaks, which modify the aggregate public key as defined in the
<a href="https://bips.dev/327/#tweaking-definition" title="wikilink">Tweaking Definition</a> subsection. For
example, if <em>KeyAgg</em> is run with <em>v = 2</em>, <em>is_xonly_t<sub>1</sub> =
false</em>, <em>is_xonly_t<sub>2</sub> = true</em>, then the aggregate key is
first plain tweaked with <em>tweak<sub>1</sub></em> and then X-only tweaked
with <em>tweak<sub>2</sub></em>.</p>
<p>The purpose of supporting tweaking is to ensure compatibility with
existing uses of tweaking, i.e., that the result of signing is a valid
signature for the tweaked public key. The MuSig2 algorithms take
arbitrary tweaks as input but accepting arbitrary tweaks may negatively
affect the security of the scheme.[5] Instead, signers should obtain
the tweaks according to other specifications. This typically involves
deriving the tweaks from a hash of the aggregate public key and some
other information. Depending on the specific scheme that is used for
tweaking, either the plain or the X-only aggregate public key is
required. For example, to do
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a>
derivation, you call <em>GetPlainPubkey</em> to be able to compute the tweak,
whereas
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP341</a>
TapTweaks require X-only public keys that are obtained with
<em>GetXonlyPubkey</em>.</p>
<p>The tweak mode provided to <em>ApplyTweak</em> depends on the application:
Plain tweaking can be used to derive child public keys from an aggregate
public key using
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a>.
On the other hand, X-only tweaking is required for Taproot tweaking per
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP341</a>.
A Taproot-tweaked public key commits to a <em>script path</em>, allowing users
to create transaction outputs that are spendable either with a MuSig2
multi-signature or by providing inputs that satisfy the script path.
Script path spends require a control block that contains a parity bit
for the tweaked X-only public key. The bit can be obtained with
<em>GetPlainPubkey(keyagg_ctx)[0] &amp; 1</em>.</p>
<h2 id="Algorithms">Algorithms</h2>
<p>The following specification of the algorithms has been written with a
focus on clarity. As a result, the specified algorithms are not always
optimal in terms of computation and space. In particular, some values
are recomputed but can be cached in actual implementations (see <a href="https://bips.dev/327/#signing-flow" title="wikilink">Signing
Flow</a>).</p>
<h3 id="Notation">Notation</h3>
<p>The following conventions are used, with constants as defined for
<a rel="noopener" target="_blank" href="https://www.secg.org/sec2-v2.pdf">secp256k1</a>. We note that adapting
this proposal to other elliptic curves is not straightforward and can
result in an insecure scheme.</p>
<ul>
<li>Lowercase variables represent integers or byte arrays.
<ul>
<li>The constant <em>p</em> refers to the field size,
<em>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F</em>.</li>
<li>The constant <em>n</em> refers to the curve order,
<em>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</em>.</li>
</ul>
</li>
<li>Uppercase variables refer to points on the curve with equation
<em>y<sup>2</sup> = x<sup>3</sup> + 7</em> over the integers modulo <em>p</em>.
<ul>
<li><em>is_infinite(P)</em> returns whether <em>P</em> is the point at infinity.</li>
<li><em>x(P)</em> and <em>y(P)</em> are integers in the range <em>0..p-1</em> and refer
to the X and Y coordinates of a point <em>P</em> (assuming it is not
infinity).</li>
<li>The constant <em>G</em> refers to the base point, for which <em>x(G) =
0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</em>
and <em>y(G) =
0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8</em>.</li>
<li>Addition of points refers to the usual <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law">elliptic curve group
operation</a>.</li>
<li><a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication">Multiplication (⋅) of an integer and a
point</a>
refers to the repeated application of the group operation.</li>
</ul>
</li>
<li>Functions and operations:
<ul>
<li><em>||</em> refers to byte array concatenation.</li>
<li>The function <em>x[i:j]</em>, where <em>x</em> is a byte array and <em>i, j ≥
0</em>, returns a <em>(j - i)</em>-byte array with a copy of the <em>i</em>-th
byte (inclusive) to the <em>j</em>-th byte (exclusive) of <em>x</em>.</li>
<li>The function <em>bytes(n, x)</em>, where <em>x</em> is an integer, returns the
n-byte encoding of <em>x</em>, most significant byte first.</li>
<li>The constant <em>empty_bytestring</em> refers to the empty byte array.
It holds that <em>len(empty_bytestring) = 0</em>.</li>
<li>The function <em>xbytes(P)</em>, where <em>P</em> is a point for which <em>not
is_infinite(P)</em>, returns <em>bytes(32, x(P))</em>.</li>
<li>The function <em>len(x)</em> where <em>x</em> is a byte array returns the
length of the array.</li>
<li>The function <em>has_even_y(P)</em>, where <em>P</em> is a point for which
<em>not is_infinite(P)</em>, returns <em>y(P) mod 2 == 0</em>.</li>
<li>The function <em>with_even_y(P)</em>, where <em>P</em> is a point, returns
<em>P</em> if <em>is_infinite(P)</em> or <em>has_even_y(P)</em>. Otherwise,
<em>with_even_y(P)</em> returns <em>-P</em>.</li>
<li>The function <em>cbytes(P)</em>, where <em>P</em> is a point for which <em>not
is_infinite(P)</em>, returns <em>a || xbytes(P)</em> where <em>a</em> is a byte
that is <em>2</em> if <em>has_even_y(P)</em> and <em>3</em> otherwise.</li>
<li>The function <em>cbytes_ext(P)</em>, where <em>P</em> is a point, returns
<em>bytes(33, 0)</em> if <em>is_infinite(P)</em>. Otherwise, it returns
<em>cbytes(P)</em>.</li>
<li>The function <em>int(x)</em>, where <em>x</em> is a 32-byte array, returns the
256-bit unsigned integer whose most significant byte first
encoding is <em>x</em>.</li>
<li>The function <em>lift_x(x)</em>, where <em>x</em> is an integer in range
<em>0..2<sup>256</sup>-1</em>, returns the point <em>P</em> for which <em>x(P) =
x</em><ref></li>
</ul>
</li>
</ul>
<p><code>   Given a candidate X coordinate </code><em><code>x</code></em><code> in the range </code><em><code>0..p-1</code></em><code>, there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then </code><em><code>x</code></em><code> is not a valid X coordinate either, i.e., no point </code><em><code>P</code></em><code> exists for which </code><em><code>x(P)``  ``=``  ``x</code></em><code>. The valid Y coordinates for a given candidate </code><em><code>x</code></em><code> are the square roots of </code><em><code>c``  ``=``   ``x</code><sup><code>3</code></sup><code>   ``+``   ``7``   ``mod``  ``p</code></em><code> and they can be computed as </code><em><code>y``   ``=``  ``±c</code><sup><code>(p+1)/4</code></sup><code>   ``mod``   ``p</code></em><code> (see </code><a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus"><code>Quadratic``  ``residue</code></a><code>) if they exist, which can be checked by squaring and comparing with </code><em><code>c</code></em><code>.</code></ref><code> and </code><em><code>has_even_y(P)</code></em><code>, or fails if </code><em><code>x</code></em><code> is greater than </code><em><code>p-1</code></em><code> or no such point exists. The function </code><em><code>lift_x(x)</code></em><code> is equivalent to the following pseudocode:</code></p>
<ul>
<li>
<ul>
<li>Fail if <em>x &gt; p-1</em>.</li>
<li>Let <em>c = x<sup>3</sup> + 7 mod p</em>.</li>
<li>Let <em>y' = c<sup>(p+1)/4</sup> mod p</em>.</li>
<li>Fail if <em>c ≠ y'<sup>2</sup> mod p</em>.</li>
<li>Let ''y = y' '' if <em>y' mod 2 = 0</em>, otherwise let ''y = p - y'
''.</li>
<li>Return the unique point <em>P</em> such that <em>x(P) = x</em> and <em>y(P) = y</em>.</li>
</ul>
</li>
<li>
<ul>
<li>The function <em>cpoint(x)</em>, where <em>x</em> is a 33-byte array
(compressed serialization), sets <em>P = lift_x(int(x[1:33]))</em>
and fails if that fails. If <em>x[0] = 2</em> it returns <em>P</em> and if
<em>x[0] = 3</em> it returns <em>-P</em>. Otherwise, it fails.</li>
<li>The function <em>cpoint_ext(x)</em>, where <em>x</em> is a 33-byte array
(compressed serialization), returns the point at infinity if <em>x
= bytes(33, 0)</em>. Otherwise, it returns <em>cpoint(x)</em> and fails if
that fails.</li>
<li>The function <em>hash<sub>tag</sub>(x)</em> where <em>tag</em> is a UTF-8
encoded tag name and <em>x</em> is a byte array returns the 32-byte
hash <em>SHA256(SHA256(tag) || SHA256(tag) || x)</em>.</li>
</ul>
</li>
<li>
<p>Other:</p>
<ul>
<li>Tuples are written by listing the elements within parentheses
and separated by commas. For example, <em>(2, 3, 1)</em> is a tuple.</li>
</ul>
</li>
</ul>
<h3 id="Key_Generation_and_Aggregation">Key Generation and Aggregation</h3>
<h4 id="Key_Generation_of_an_Individual_Signer">Key Generation of an Individual Signer</h4>
<div>
<p>Algorithm <em>IndividualPubkey(sk)</em>:[6]</p>
<ul>
<li>Inputs:
<ul>
<li>The secret key <em>sk</em>: a 32-byte array, freshly generated
uniformly at random</li>
</ul>
</li>
<li>Let <em>d' = int(sk)</em>.</li>
<li>Fail if <em>d' = 0</em> or <em>d' ≥ n</em>.</li>
<li>Return <em>cbytes(d'⋅G)</em>.</li>
</ul>
</div>
<h4 id="KeyAgg_Context">KeyAgg Context</h4>
<p>The KeyAgg Context is a data structure consisting of the following
elements:</p>
<ul>
<li>The point <em>Q</em> representing the potentially tweaked aggregate public
key: an elliptic curve point</li>
<li>The accumulated tweak <em>tacc</em>: an integer with <em>0 ≤ tacc &lt; n</em></li>
<li>The value <em>gacc</em> : 1 or -1 mod n</li>
</ul>
<p>We write &quot;Let <em>(Q, gacc, tacc) = keyagg_ctx</em>&quot; to assign names to the
elements of a KeyAgg Context.</p>
<div>
<p>Algorithm <em>GetXonlyPubkey(keyagg_ctx)</em>:</p>
<ul>
<li>Let <em>(Q, _, _) = keyagg_ctx</em></li>
<li>Return <em>xbytes(Q)</em></li>
</ul>
</div>
<div>
<p>Algorithm <em>GetPlainPubkey(keyagg_ctx)</em>:</p>
<ul>
<li>Let <em>(Q, _, _) = keyagg_ctx</em></li>
<li>Return <em>cbytes(Q)</em></li>
</ul>
</div>
<h4 id="Key_Sorting">Key Sorting</h4>
<div>
<p>Algorithm <em>KeySort(pk<sub>1..u</sub>)</em>:</p>
<ul>
<li>Inputs:
<ul>
<li>The number <em>u</em> of individual public keys with <em>0 &lt; u &lt; 2^32</em></li>
<li>The individual public keys <em>pk<sub>1..u</sub></em>: <em>u</em> 33-byte
arrays</li>
</ul>
</li>
<li>Return <em>pk<sub>1..u</sub></em> sorted in lexicographical order.</li>
</ul>
</div>
<h4 id="Key_Aggregation">Key Aggregation</h4>
<div>
<p>Algorithm <em>KeyAgg(pk<sub>1..u</sub>)</em>:</p>
<ul>
<li>Inputs:
<ul>
<li>The number <em>u</em> of individual public keys with <em>0 &lt; u &lt; 2^32</em></li>
<li>The individual public keys <em>pk<sub>1..u</sub></em>: <em>u</em> 33-byte
arrays</li>
</ul>
</li>
<li>Let <em>pk2 = GetSecondKey(pk<sub>1..u</sub>)</em></li>
<li>For <em>i = 1 .. u</em>:
<ul>
<li>Let <em>P<sub>i</sub> = cpoint(pk<sub>i</sub>)</em>; fail if that fails
and blame signer <em>i</em> for invalid individual public key.</li>
<li>Let <em>a<sub>i</sub> = KeyAggCoeffInternal(pk<sub>1..u</sub>,
pk<sub>i</sub>, pk2)</em>.</li>
</ul>
</li>
<li>Let <em>Q = a<sub>1</sub>⋅P<sub>1</sub> + a<sub>2</sub>⋅P<sub>2</sub> +
... + a<sub>u</sub>⋅P<sub>u</sub></em></li>
<li>Fail if <em>is_infinite(Q)</em>.</li>
<li>Let <em>gacc = 1</em></li>
<li>Let <em>tacc = 0</em></li>
<li>Return <em>keyagg_ctx = (Q, gacc, tacc)</em>.</li>
</ul>
</div>
<div>
<p>Internal Algorithm <em>HashKeys(pk<sub>1..u</sub>)</em>:</p>
<ul>
<li>Return <em>hash<sub>KeyAgg list</sub>(pk<sub>1</sub> || pk<sub>2</sub>
|| ... || pk<sub>u</sub>)</em></li>
</ul>
</div>
<div>
<p>Internal Algorithm <em>GetSecondKey(pk<sub>1..u</sub>)</em>:</p>
<ul>
<li>For <em>j = 1 .. u</em>:
<ul>
<li>If <em>pk<sub>j</sub> ≠ pk<sub>1</sub></em>:
<ul>
<li>Return <em>pk<sub>j</sub></em></li>
</ul>
</li>
</ul>
</li>
<li>Return <em>bytes(33, 0)</em></li>
</ul>
</div>
<div>
<p>Internal Algorithm <em>KeyAggCoeff(pk<sub>1..u</sub>, pk')</em>:</p>
<ul>
<li>Let <em>pk2 = GetSecondKey(pk<sub>1..u</sub>)</em>:</li>
<li>Return <em>KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)</em></li>
</ul>
</div>
<div>
<p>Internal Algorithm <em>KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)</em>:</p>
<ul>
<li>Let <em>L = HashKeys(pk<sub>1..u</sub>)</em></li>
<li>If <em>pk' = pk2</em>:
<ul>
<li>Return 1</li>
</ul>
</li>
<li>Return <em>int(hash<sub>KeyAgg coefficient</sub>(L || pk')) mod n</em>[7]</li>
</ul>
</div>
<h4 id="Applying_Tweaks">Applying Tweaks</h4>
<div>
<p>Algorithm <em>ApplyTweak(keyagg_ctx, tweak, is_xonly_t)</em>:</p>
<ul>
<li>Inputs:
<ul>
<li>The <em>keyagg_ctx</em>: a <a href="https://bips.dev/327/#keyagg-context" title="wikilink">KeyAgg
Context</a> data structure</li>
<li>The <em>tweak</em>: a 32-byte array</li>
<li>The tweak mode <em>is_xonly_t</em>: a boolean</li>
</ul>
</li>
<li>Let <em>(Q, gacc, tacc) = keyagg_ctx</em></li>
<li>If <em>is_xonly_t</em> and <em>not has_even_y(Q)</em>:
<ul>
<li>Let <em>g = -1 mod n</em></li>
</ul>
</li>
<li>Else:
<ul>
<li>Let <em>g = 1</em></li>
</ul>
</li>
<li>Let <em>t = int(tweak)</em>; fail if <em>t ≥ n</em></li>
<li>Let <em>Q' = g⋅Q + t⋅G</em>
<ul>
<li>Fail if <em>is_infinite(Q')</em></li>
</ul>
</li>
<li>Let <em>gacc' = g⋅gacc mod n</em></li>
<li>Let <em>tacc' = t + g⋅tacc mod n</em></li>
<li>Return <em>keyagg_ctx' = (Q', gacc', tacc')</em></li>
</ul>
</div>
<h3 id="Nonce_Generation-1">Nonce Generation</h3>
<div>
<p>Algorithm <em>NonceGen(sk, pk, aggpk, m, extra_in)</em>:</p>
<ul>
<li>Inputs:
<ul>
<li>The secret signing key <em>sk</em>: a 32-byte array (optional argument)</li>
<li>The individual public key <em>pk</em>: a 33-byte array (see
<a href="https://bips.dev/327/#modifications-to-nonce-generation" title="wikilink">Modifications to Nonce
Generation</a> for
the reason that this argument is mandatory)</li>
<li>The x-only aggregate public key <em>aggpk</em>: a 32-byte array
(optional argument)</li>
<li>The message <em>m</em>: a byte array (optional argument)[8]</li>
<li>The auxiliary input <em>extra_in</em>: a byte array with <em>0 ≤
len(extra_in) ≤ 2<sup>32</sup>-1</em> (optional argument)</li>
</ul>
</li>
<li>Let ''rand' '' be a 32-byte array freshly drawn uniformly at random</li>
<li>If the optional argument <em>sk</em> is present:
<ul>
<li>Let <em>rand</em> be the byte-wise xor of <em>sk</em> and
<em>hash<sub>MuSig/aux</sub>(rand')</em>[9]</li>
</ul>
</li>
<li>Else:
<ul>
<li>Let ''rand = rand' ''</li>
</ul>
</li>
<li>If the optional argument <em>aggpk</em> is not present:
<ul>
<li>Let <em>aggpk = empty_bytestring</em></li>
</ul>
</li>
<li>If the optional argument <em>m</em> is not present:
<ul>
<li>Let <em>m_prefixed = bytes(1, 0)</em></li>
</ul>
</li>
<li>Else:
<ul>
<li>Let <em>m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m</em></li>
</ul>
</li>
<li>If the optional argument <em>extra_in</em> is not present:
<ul>
<li>Let <em>extra_in = empty_bytestring</em></li>
</ul>
</li>
<li>Let <em>k<sub>i</sub> = int(hash<sub>MuSig/nonce</sub>(rand || bytes(1,
len(pk)) || pk || bytes(1, len(aggpk)) || aggpk || m_prefixed ||
bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1))) mod n</em>
for <em>i = 1,2</em></li>
<li>Fail if <em>k<sub>1</sub> = 0</em> or <em>k<sub>2</sub> = 0</em></li>
<li>Let <em>R<sub>⁎,1</sub> = k<sub>1</sub>⋅G, R<sub>⁎,2</sub> =
k<sub>2</sub>⋅G</em></li>
<li>Let <em>pubnonce = cbytes(R<sub>⁎,1</sub>) || cbytes(R<sub>⁎,2</sub>)</em></li>
<li>Let <em>secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)
|| pk</em><ref name="secnonce">The algorithms as specified here assume
that the <em>secnonce</em> is stored as a 97-byte array using the
serialization <em>secnonce = bytes(32, k<sub>1</sub>) || bytes(32,
k<sub>2</sub>) || pk</em>. The same format is used in the reference
implementation and in the test vectors. However, since the
<em>secnonce</em> is (obviously) not meant to be sent over the wire,
compatibility between implementations is not a concern, and this
method of storing the <em>secnonce</em> is merely a suggestion.</li>
</ul>
<p>The <em>secnonce</em> is effectively a local data structure of the signer which
comprises the value triple <em>(k<sub>1</sub>, k<sub>2</sub>, pk)</em>, and
implementations may choose any suitable method to carry it from
<em>NonceGen</em> (first communication round) to <em>Sign</em> (second communication
round). In particular, implementations may choose to hide the <em>secnonce</em>
in internal state without exposing it in an API explicitly, e.g., in an
effort to prevent callers from reusing a <em>secnonce</em> accidentally.</ref></p>
<ul>
<li>Return <em>(secnonce, pubnonce)</em></li>
</ul>
</div>
<h3 id="Nonce_Aggregation">Nonce Aggregation</h3>
<div>
<p>Algorithm <em>NonceAgg(pubnonce<sub>1..u</sub>)</em>:</p>
<ul>
<li>Inputs:
<ul>
<li>The number <em>u</em> of <em>pubnonces</em> with <em>0 &lt; u &lt; 2^32</em></li>
<li>The public nonces <em>pubnonce<sub>1..u</sub></em>: <em>u</em> 66-byte arrays</li>
</ul>
</li>
<li>For <em>j = 1 .. 2</em>:
<ul>
<li>For <em>i = 1 .. u</em>:
<ul>
<li>Let <em>R<sub>i,j</sub> =
cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])</em>; fail if
that fails and blame signer <em>i</em> for invalid <em>pubnonce</em>.</li>
</ul>
</li>
<li>Let <em>R<sub>j</sub> = R<sub>1,j</sub> + R<sub>2,j</sub> + ... +
R<sub>u,j</sub></em></li>
</ul>
</li>
<li>Return <em>aggnonce = cbytes_ext(R<sub>1</sub>) ||
cbytes_ext(R<sub>2</sub>)</em></li>
</ul>
</div>
<h3 id="Session_Context">Session Context</h3>
<p>The Session Context is a data structure consisting of the following
elements:</p>
<ul>
<li>The aggregate public nonce <em>aggnonce</em>: a 66-byte array</li>
<li>The number <em>u</em> of individual public keys with <em>0 &lt; u &lt; 2^32</em></li>
<li>The individual public keys <em>pk<sub>1..u</sub></em>: <em>u</em> 33-byte arrays</li>
<li>The number <em>v</em> of tweaks with <em>0 ≤ v &lt; 2^32</em></li>
<li>The tweaks <em>tweak<sub>1..v</sub></em>: <em>v</em> 32-byte arrays</li>
<li>The tweak modes <em>is_xonly_t<sub>1..v</sub></em> : <em>v</em> booleans</li>
<li>The message <em>m</em>: a byte array[10]</li>
</ul>
<p>We write &quot;Let <em>(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>,
is_xonly_t<sub>1..v</sub>, m) = session_ctx</em>&quot; to assign names to the
elements of a Session Context.</p>
<div>
<p>Algorithm <em>GetSessionValues(session_ctx)</em>:</p>
<ul>
<li>Let <em>(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>,
is_xonly_t<sub>1..v</sub>, m) = session_ctx</em></li>
<li>Let <em>keyagg_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)</em>; fail if
that fails</li>
<li>For <em>i = 1 .. v</em>:
<ul>
<li>Let <em>keyagg_ctx<sub>i</sub> =
ApplyTweak(keyagg_ctx<sub>i-1</sub>, tweak<sub>i</sub>,
is_xonly_t<sub>i</sub>)</em>; fail if that fails</li>
</ul>
</li>
<li>Let <em>(Q, gacc, tacc) = keyagg_ctx<sub>v</sub></em></li>
<li>Let <em>b = int(hash<sub>MuSig/noncecoef</sub>(aggnonce || xbytes(Q) ||
m)) mod n</em></li>
<li>Let <em>R<sub>1</sub> = cpoint_ext(aggnonce[0:33]), R<sub>2</sub> =
cpoint_ext(aggnonce[33:66])</em>; fail if that fails and blame nonce
aggregator for invalid <em>aggnonce</em>.</li>
<li>Let <em>R' = R<sub>1</sub> + b⋅R<sub>2</sub></em></li>
<li>If ''is_infinite(R'):
<ul>
<li>Let final nonce <em>R = G</em> (see <a href="https://bips.dev/327/#dealing-with-infinity-in-nonce-aggregation" title="wikilink">Dealing with Infinity in Nonce
Aggregation</a>)</li>
</ul>
</li>
<li>Else:
<ul>
<li>Let final nonce ''R = R' ''</li>
</ul>
</li>
<li>Let <em>e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q)
|| m)) mod n</em></li>
<li>Return <em>(Q, gacc, tacc, b, R, e)</em></li>
</ul>
</div>
<div>
<p>Algorithm <em>GetSessionKeyAggCoeff(session_ctx, P)</em>:</p>
<ul>
<li>Let <em>(_, u, pk<sub>1..u</sub>, _, _, _, _) = session_ctx</em></li>
<li>Let <em>pk = cbytes(P)</em></li>
<li>Fail if <em>pk</em> not in <em>pk<sub>1..u</sub></em></li>
<li>Return <em>KeyAggCoeff(pk<sub>1..u</sub>, pk)</em></li>
</ul>
</div>
<h3 id="Signing">Signing</h3>
<div>
<p>Algorithm <em>Sign(secnonce, sk, session_ctx)</em>:</p>
<ul>
<li>
<p>Inputs:</p>
<ul>
<li>The secret nonce <em>secnonce</em> that has never been used as input to
<em>Sign</em> before: a 97-byte array[11]</li>
<li>The secret key <em>sk</em>: a 32-byte array</li>
<li>The <em>session_ctx</em>: a <a href="https://bips.dev/327/#session-context" title="wikilink">Session
Context</a> data structure</li>
</ul>
</li>
<li>
<p>Let <em>(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)</em>; fail
if that fails</p>
</li>
<li>
<p>Let <em>k<sub>1</sub>' = int(secnonce[0:32]), k<sub>2</sub>' =
int(secnonce[32:64])</em></p>
</li>
<li>
<p>Fail if <em>k<sub>i</sub>' = 0</em> or <em>k<sub>i</sub>' ≥ n</em> for <em>i = 1..2</em></p>
</li>
<li>
<p>Let ''k<sub>1</sub> = k<sub>1</sub>', k<sub>2</sub> = k<sub>2</sub>'
'' if <em>has_even_y(R)</em>, otherwise let ''k<sub>1</sub> = n -
k<sub>1</sub>', k<sub>2</sub> = n - k<sub>2</sub>' ''</p>
</li>
<li>
<p>Let <em>d' = int(sk)</em></p>
</li>
<li>
<p>Fail if <em>d' = 0</em> or <em>d' ≥ n</em></p>
</li>
<li>
<p>Let <em>P = d'⋅G</em></p>
</li>
<li>
<p>Let <em>pk = cbytes(P)</em></p>
</li>
<li>
<p>Fail if <em>pk ≠ secnonce[64:97]</em></p>
</li>
<li>
<p>Let <em>a = GetSessionKeyAggCoeff(session_ctx, P)</em>; fail if that
fails[12]</p>
</li>
<li>
<p>Let <em>g = 1</em> if <em>has_even_y(Q)</em>, otherwise let <em>g = -1 mod n</em></p>
</li>
<li></li>
</ul>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>&lt;div id=&quot;Sign negation&quot;&gt;
</span><span>
</span><span>&lt;/div&gt;
</span><span>
</span><span>Let *d = g⋅gacc⋅d&#39; mod n* (See [Negation Of The Secret Key When
</span><span>Signing](negation-of-the-secret-key-when-signing &quot;wikilink&quot;))
</span></code></pre>
<ul>
<li>
<p>Let <em>s = (k<sub>1</sub> + b⋅k<sub>2</sub> + e⋅a⋅d) mod n</em></p>
</li>
<li>
<p>Let <em>psig = bytes(32, s)</em></p>
</li>
<li>
<p>Let <em>pubnonce = cbytes(k<sub>1</sub>'⋅G) ||
cbytes(k<sub>2</sub>'⋅G)</em></p>
</li>
<li>
<p>If <em>PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)</em> (see
below) returns failure, fail[13]</p>
</li>
<li>
<p>Return partial signature <em>psig</em></p>
</li>
</ul>
</div>
<h3 id="Partial_Signature_Verification">Partial Signature Verification</h3>
<div>
<p>Algorithm <em>PartialSigVerify(psig, pubnonce<sub>1..u</sub>,
pk<sub>1..u</sub>, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m,
i)</em>:</p>
<ul>
<li>Inputs:
<ul>
<li>The partial signature <em>psig</em>: a 32-byte array</li>
<li>The number <em>u</em> of public nonces and individual public keys with
<em>0 &lt; u &lt; 2^32</em></li>
<li>The public nonces <em>pubnonce<sub>1..u</sub></em>: <em>u</em> 66-byte arrays</li>
<li>The individual public keys <em>pk<sub>1..u</sub></em>: <em>u</em> 33-byte
arrays</li>
<li>The number <em>v</em> of tweaks with <em>0 ≤ v &lt; 2^32</em></li>
<li>The tweaks <em>tweak<sub>1..v</sub></em>: <em>v</em> 32-byte arrays</li>
<li>The tweak modes <em>is_xonly_t<sub>1..v</sub></em> : <em>v</em> booleans</li>
<li>The message <em>m</em>: a byte array[14]</li>
<li>The index of the signer <em>i</em> in the of public nonces and
individual public keys with <em>0 &lt; i ≤ u</em></li>
</ul>
</li>
<li>Let <em>aggnonce = NonceAgg(pubnonce<sub>1..u</sub>)</em>; fail if that
fails</li>
<li>Let <em>session_ctx = (aggnonce, u, pk<sub>1..u</sub>, v,
tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)</em></li>
<li>Run <em>PartialSigVerifyInternal(psig, pubnonce<sub>i</sub>,
pk<sub>i</sub>, session_ctx)</em></li>
<li>Return success iff no failure occurred before reaching this point.</li>
</ul>
</div>
<div>
<p>Internal Algorithm <em>PartialSigVerifyInternal(psig, pubnonce, pk,
session_ctx)</em>:</p>
<ul>
<li>
<p>Let <em>(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)</em>; fail
if that fails</p>
</li>
<li>
<p>Let <em>s = int(psig)</em>; fail if <em>s ≥ n</em></p>
</li>
<li>
<p>Let <em>R<sub>⁎,1</sub> = cpoint(pubnonce[0:33]), R<sub>⁎,2</sub> =
cpoint(pubnonce[33:66])</em></p>
</li>
<li>
<p>Let <em>Re<sub>⁎</sub>' = R<sub>⁎,1</sub> + b⋅R<sub>⁎,2</sub></em></p>
</li>
<li>
<p>Let effective nonce ''Re<sub>⁎</sub> = Re<sub>⁎</sub>' '' if
<em>has_even_y(R)</em>, otherwise let ''Re<sub>⁎</sub> = -Re<sub>⁎</sub>'
''</p>
</li>
<li>
<p>Let <em>P = cpoint(pk)</em>; fail if that fails</p>
</li>
<li>
<p>Let <em>a = GetSessionKeyAggCoeff(session_ctx, P)</em>[15]</p>
</li>
<li>
<p>Let <em>g = 1</em> if <em>has_even_y(Q)</em>, otherwise let <em>g = -1 mod n</em></p>
</li>
<li></li>
</ul>
<pre style="background-color:#fafafa;color:#61676c;"><code><span>&lt;div id=&quot;SigVerify negation&quot;&gt;
</span><span>
</span><span>&lt;/div&gt;
</span><span>
</span><span>Let *g&#39; = g⋅gacc mod n* (See [Negation Of The Individual Public Key
</span><span>When Partially
</span><span>Verifying](#negation-of-the-individual-public-key-when-partially-verifying &quot;wikilink&quot;))
</span></code></pre>
<ul>
<li>
<p>Fail if <em>s⋅G ≠ Re<sub>⁎</sub> + e⋅a⋅g'⋅P</em></p>
</li>
<li>
<p>Return success iff no failure occurred before reaching this point.</p>
</li>
</ul>
</div>
<h3 id="Partial_Signature_Aggregation">Partial Signature Aggregation</h3>
<div>
<p>Algorithm <em>PartialSigAgg(psig<sub>1..u</sub>, session_ctx)</em>:</p>
<ul>
<li>Inputs:
<ul>
<li>The number <em>u</em> of signatures with <em>0 &lt; u &lt; 2^32</em></li>
<li>The partial signatures <em>psig<sub>1..u</sub></em>: <em>u</em> 32-byte arrays</li>
<li>The <em>session_ctx</em>: a <a href="https://bips.dev/327/#session-context" title="wikilink">Session
Context</a> data structure</li>
</ul>
</li>
<li>Let <em>(Q, _, tacc, _, _, R, e) = GetSessionValues(session_ctx)</em>;
fail if that fails</li>
<li>For <em>i = 1 .. u</em>:
<ul>
<li>Let <em>s<sub>i</sub> = int(psig<sub>i</sub>)</em>; fail if
<em>s<sub>i</sub> ≥ n</em> and blame signer <em>i</em> for invalid partial
signature.</li>
</ul>
</li>
<li>Let <em>g = 1</em> if <em>has_even_y(Q)</em>, otherwise let <em>g = -1 mod n</em></li>
<li>Let <em>s = s<sub>1</sub> + ... + s<sub>u</sub> + e⋅g⋅tacc mod n</em></li>
<li>Return ''sig = <em>xbytes(R) || bytes(32, s)</em></li>
</ul>
</div>
<h3 id="Test_Vectors_and_Reference_Code">Test Vectors and Reference Code</h3>
<p>We provide a naive, highly inefficient, and non-constant time <a href="bip-0327/reference.py" title="wikilink">pure
Python 3 reference implementation of the key aggregation, partial
signing, and partial signature verification
algorithms</a>.</p>
<p>Standalone JSON test vectors are also available in the <a href="bip-0327" title="wikilink">same
directory</a>, to facilitate porting the test vectors
into other implementations.</p>
<p>The reference implementation is for demonstration purposes only and not
to be used in production environments.</p>
<h2 id="Remarks_on_Security_and_Correctness">Remarks on Security and Correctness</h2>
<h3 id="Signing_with_Tweaked_Individual_Keys">Signing with Tweaked Individual Keys</h3>
<p>The scheme in this proposal has been designed to be secure even if
signers tweak their individual secret keys with tweaks known to the
adversary (e.g., as in BIP32 unhardened derivation) before providing the
corresponding individual public keys as input to key aggregation. In
particular, the scheme as specified above requires each signer to
provide a final individual public key <em>pk</em> already to <em>NonceGen</em>, which
writes it into the <em>secnonce</em> array so that it can be checked against
<em>IndividualPubkey(sk)</em> in the <em>Sign</em> algorithm. The purpose of this
check in <em>Sign</em> is to ensure that <em>pk</em>, and thus the secret key <em>sk</em>
that will be provided to <em>Sign</em>, is determined before the signer sends
out the <em>pubnonce</em>.</p>
<p>If the check in <em>Sign</em> was omitted, and a signer supported signing with
at least two different secret keys <em>sk<sub>1</sub></em> and <em>sk<sub>2</sub></em>
which have been obtained via tweaking another secret key with tweaks
known to the adversary, then the adversary could, after having seen the
<em>pubnonce</em>, influence whether <em>sk<sub>1</sub></em> or <em>sk<sub>2</sub></em> is
provided to <em>Sign</em>. This degree of freedom may allow the adversary to
perform a generalized birthday attack and thereby forge a signature (see
<a rel="noopener" target="_blank" href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html">bitcoin-dev mailing list
post</a>
and <a rel="noopener" target="_blank" href="https://github.com/jonasnick/musig2-tweaking">writeup</a> for
details).</p>
<p>Checking <em>pk</em> against <em>InvidualPubkey(sk)</em> is a simple way to ensure
that the secret key provided to <em>Sign</em> is fully determined already when
<em>NonceGen</em> is invoked. This removes the adversary's ability to influence
the secret key after having seen the <em>pubnonce</em> and thus rules out the
attack.[16] Note that the scheme as given in the <a rel="noopener" target="_blank" href="https://eprint.iacr.org/2020/1261">MuSig2
paper</a> does not perform the check in
<em>Sign</em>. However, the security model in the paper does not cover tweaking
at all and assumes a single fixed secret key.</p>
<h3 id="Modifications_to_Nonce_Generation">Modifications to Nonce Generation</h3>
<p>Implementers must avoid modifying the <em>NonceGen</em> algorithm without being
fully aware of the implications. We provide two modifications to
<em>NonceGen</em> that are secure when applied correctly and may be useful in
special circumstances, summarized in the following table.</p>
<table><thead><tr><th></th><th>needs secure randomness</th><th>needs secure counter</th><th>needs to keep state securely</th><th>needs aggregate nonce of all other signers (only possible for one signer)</th></tr></thead><tbody>
<tr><td>NonceGen</td><td>✓</td><td></td><td>✓</td><td></td></tr>
<tr><td>CounterNonceGen</td><td></td><td>✓</td><td>✓</td><td></td></tr>
<tr><td>DeterministicSign</td><td></td><td></td><td></td><td>✓</td></tr>
</tbody></table>
<p>First, on systems where obtaining uniformly random values is much harder
than maintaining a global atomic counter, it can be beneficial to modify
<em>NonceGen</em>. The resulting algorithm <em>CounterNonceGen</em> does not draw
''rand' '' uniformly at random but instead sets ''rand' '' to the value
of an atomic counter that is incremented whenever it is read. With this
modification, the secret signing key <em>sk</em> of the signer generating the
nonce is <strong>not</strong> an optional argument and must be provided to
<em>NonceGen</em>. The security of the resulting scheme then depends on the
requirement that reading the counter must never yield the same counter
value in two <em>NonceGen</em> invocations with the same <em>sk</em>.</p>
<p>Second, if there is a unique signer who is supposed to send the
<em>pubnonce</em> last, it is possible to modify nonce generation for this
single signer to not require high-quality randomness. Such a nonce
generation algorithm <em>DeterministicSign</em> is specified below. Note that
the only optional argument is <em>rand</em>, which can be omitted if randomness
is entirely unavailable. <em>DeterministicSign</em> requires the argument
<em>aggothernonce</em> which should be set to the output of <em>NonceAgg</em> run on
the <em>pubnonce</em> value of <strong>all</strong> other signers (but can be provided by an
untrusted party). Hence, using <em>DeterministicSign</em> is only possible for
the last signer to generate a nonce and makes the signer stateless,
similar to the stateless signer described in the <a href="https://bips.dev/327/#nonce-generation" title="wikilink">Nonce
Generation</a> section.</p>
<h4 id="Deterministic_and_Stateless_Signing_for_a_Single_Signer">Deterministic and Stateless Signing for a Single Signer</h4>
<div>
<p>Algorithm <em>DeterministicSign(sk, aggothernonce, pk<sub>1..u</sub>,
tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, rand)</em>:</p>
<ul>
<li>Inputs:
<ul>
<li>The secret signing key <em>sk</em>: a 32-byte array</li>
<li>The aggregate public nonce <em>aggothernonce</em> (see
<a href="https://bips.dev/327/#modifications-to-nonce-generation" title="wikilink">above</a>): a
66-byte array</li>
<li>The number <em>u</em> of individual public keys with <em>0 &lt; u &lt; 2^32</em></li>
<li>The individual public keys <em>pk<sub>1..u</sub></em>: <em>u</em> 32-byte
arrays</li>
<li>The number <em>v</em> of tweaks with <em>0 ≤ v &lt; 2^32</em></li>
<li>The tweaks <em>tweak<sub>1..v</sub></em>: <em>v</em> 32-byte arrays</li>
<li>The tweak methods <em>is_xonly_t<sub>1..v</sub></em>: <em>v</em> booleans</li>
<li>The message <em>m</em>: a byte array[17]</li>
<li>The auxiliary randomness <em>rand</em>: a 32-byte array (optional
argument)</li>
</ul>
</li>
<li>If the optional argument <em>rand</em> is present:
<ul>
<li>Let ''sk' '' be the byte-wise xor of <em>sk</em> and
<em>hash<sub>MuSig/aux</sub>(rand)</em></li>
</ul>
</li>
<li>Else:
<ul>
<li>Let <em>sk' = sk</em></li>
</ul>
</li>
<li>Let <em>keyagg_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)</em>; fail if
that fails</li>
<li>For <em>i = 1 .. v</em>:
<ul>
<li>Let <em>keyagg_ctx<sub>i</sub> =
ApplyTweak(keyagg_ctx<sub>i-1</sub>, tweak<sub>i</sub>,
is_xonly_t<sub>i</sub>)</em>; fail if that fails</li>
</ul>
</li>
<li>Let <em>aggpk = GetPubkey(keyagg_ctx<sub>v</sub>)</em></li>
<li>Let <em>k<sub>i</sub> =
int(hash<sub>MuSig/deterministic/nonce</sub>(sk' || aggothernonce ||
aggpk || bytes(8, len(m)) || m || bytes(1, i - 1))) mod n</em> for <em>i =
1,2</em></li>
<li>Fail if <em>k<sub>1</sub> = 0</em> or <em>k<sub>2</sub> = 0</em></li>
<li>Let <em>R<sub>⁎,1</sub> = k<sub>1</sub>⋅G, R<sub>⁎,2</sub> =
k<sub>2</sub>⋅G</em></li>
<li>Let <em>pubnonce = cbytes(R<sub>⁎,2</sub>) || cbytes(R<sub>⁎,2</sub>)</em></li>
<li>Let <em>d = int(sk)</em></li>
<li>Fail if <em>d = 0</em> or <em>d ≥ n</em></li>
<li>Let <em>pk = cbytes(d⋅G)</em></li>
<li>Let <em>secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>)
|| pk</em></li>
<li>Let <em>aggnonce = NonceAgg((pubnonce, aggothernonce))</em>; fail if that
fails and blame nonce aggregator for invalid <em>aggothernonce</em>.</li>
<li>Let <em>session_ctx = (aggnonce, u, pk<sub>1..u</sub>, v,
tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)</em></li>
<li>Return <em>(pubnonce, Sign(secnonce, sk, session_ctx))</em></li>
</ul>
</div>
<h3 id="Tweaking_Definition">Tweaking Definition</h3>
<p>Two modes of tweaking the aggregate public key are supported. They
correspond to the following algorithms:</p>
<div>
<p>Algorithm <em>ApplyPlainTweak(P, t)</em>:</p>
<ul>
<li>Inputs:
<ul>
<li><em>P</em>: a point</li>
<li>The tweak <em>t</em>: an integer with ''0 ≤ t &lt; n ''</li>
</ul>
</li>
<li>Return <em>P + t⋅G</em></li>
</ul>
</div>
<div>
<p>Algorithm <em>ApplyXonlyTweak(P, t)</em>:</p>
<ul>
<li>Return <em>with_even_y(P) + t⋅G</em></li>
</ul>
</div>
<h3 id="Negation_Of_The_Secret_Key_When_Signing">Negation Of The Secret Key When Signing</h3>
<p>In order to produce a partial signature for an X-only aggregate public
key that is an aggregate of <em>u</em> individual public keys and tweaked <em>v</em>
times (X-only or plain), the <em><a href="https://bips.dev/327/#Sign_negation" title="wikilink">Sign</a></em>
algorithm may need to negate the secret key during the signing process.</p>
<p><poem> The following elliptic curve points arise as intermediate steps
when creating a signature: • <em>P<sub>i</sub></em> as computed in <em>KeyAgg</em> is
the point corresponding to the <em>i</em>-th signer's individual public key.
Defining ''d<sub>i</sub>' '' to be the <em>i</em>-th signer's secret key as an
integer, i.e., the ''d' '' value as computed in the <em>Sign</em> algorithm of
the <em>i</em>-th signer, we have</p>
<p><code>   ''P</code><sub><code>i</code></sub><code> = d</code><sub><code>i</code></sub><code>'⋅G ''.</code></p>
<p>• <em>Q<sub>0</sub></em> is the aggregate of the individual public keys. It is
identical to value <em>Q</em> computed in <em>KeyAgg</em> and therefore defined as</p>
<p><code>   </code><em><code>Q</code><sub><code>0</code></sub><code>   ``=``  ``a</code><sub><code>1</code></sub><code>⋅P</code><sub><code>1</code></sub><code>   ``+``  ``a</code><sub><code>2</code></sub><code>⋅P</code><sub><code>2</code></sub><code>   ``+``   ``...``   ``+``  ``a</code><sub><code>u</code></sub><code>⋅P</code><sub><code>u</code></sub></em><code>.</code></p>
<p>• <em>Q<sub>i</sub></em> is the tweaked aggregate public key after the <em>i</em>-th
execution of <em>ApplyTweak</em> for <em>1 ≤ i ≤ v</em>. It holds that</p>
<p><code>   </code><em><code>Q</code><sub><code>i</code></sub><code>   ``=``   ``f(i-1)``   ``+``  ``t</code><sub><code>i</code></sub><code>⋅G</code></em><code> for </code><em><code>i``   ``=``   ``1,``   ``...,``  ``v</code></em><code> where</code><br />
<code>       </code><em><code>f(i-1)``   ``:=``  ``with_even_y(Q</code><sub><code>i-1</code></sub><code>)</code></em><code> if </code><em><code>is_xonly_t</code><sub><code>i</code></sub></em><code> and</code><br />
<code>       </code><em><code>f(i-1)``   ``:=``   ``Q</code><sub><code>i-1</code></sub></em><code> otherwise.</code></p>
<p>• <em>with_even_y(Q<sub>v</sub>)</em> is the final result of the key
aggregation and tweaking operations. It corresponds to the output of
<em>GetXonlyPubkey</em> applied on the final KeyAgg Context. </poem></p>
<p>The signer's goal is to produce a partial signature corresponding to the
final result of key aggregation and tweaking, i.e., the X-only public
key <em>with_even_y(Q<sub>v</sub>)</em>.</p>
<p><poem> For <em>1 ≤ i ≤ v</em>, we denote the value <em>g</em> computed in the <em>i</em>-th
execution of <em>ApplyTweak</em> by <em>g<sub>i-1</sub></em>. Therefore,
<em>g<sub>i-1</sub></em> is <em>-1 mod n</em> if and only if
<em>is_xonly_t<sub>i</sub></em> is true and <em>Q<sub>i-1</sub></em> has an odd Y
coordinate. In other words, <em>g<sub>i-1</sub></em> indicates whether
<em>Q<sub>i-1</sub></em> needed to be negated to apply an X-only tweak:</p>
<p><code>   </code><em><code>f(i-1)``   ``=``  ``g</code><sub><code>i-1</code></sub><code>⋅Q</code><sub><code>i-1</code></sub></em><code> for </code><em><code>1``   ``≤``  ``i``   ``≤``   ``v</code></em><code>.</code></p>
<p>Furthermore, the <em>Sign</em> and <em>PartialSigVerify</em> algorithms set value <em>g</em>
depending on whether <em>Q<sub>v</sub></em> needed to be negated to produce the
(X-only) final output. For consistency, this value <em>g</em> is referred to as
<em>g<sub>v</sub></em> in this section.</p>
<p><code>   </code><em><code>with_even_y(Q</code><sub><code>v</code></sub><code>)``   ``=``  ``g</code><sub><code>v</code></sub><code>⋅Q</code><sub><code>v</code></sub></em><code>.</code></p>
</poem>
<p><poem> So, the (X-only) final public key is</p>
<p><code>   ''with_even_y(Q</code><sub><code>v</code></sub><code>)</code><br />
<code>       = g</code><sub><code>v</code></sub><code>⋅Q</code><sub><code>v</code></sub><br />
<code>       = g</code><sub><code>v</code></sub><code>⋅(f(v-1) + t</code><sub><code>v</code></sub><code>⋅G)</code><br />
<code>       = g</code><sub><code>v</code></sub><code>⋅(g</code><sub><code>v-1</code></sub><code>⋅(f(v-2) + t</code><sub><code>v-1</code></sub><code>⋅G) + t</code><sub><code>v</code></sub><code>⋅G)</code><br />
<code>       = g</code><sub><code>v</code></sub><code>⋅g</code><sub><code>v-1</code></sub><code>⋅f(v-2) + g</code><sub><code>v</code></sub><code>⋅(t</code><sub><code>v</code></sub><code> + g</code><sub><code>v-1</code></sub><code>⋅t</code><sub><code>v-1</code></sub><code>)⋅G</code><br />
<code>       = g</code><sub><code>v</code></sub><code>⋅g</code><sub><code>v-1</code></sub><code>⋅f(v-2) + (sum</code><sub><code>i=v-1..v</code></sub><code> t</code><sub><code>i</code></sub><code>⋅prod</code><sub><code>j=i..v</code></sub><code> g</code><sub><code>j</code></sub><code>)⋅G</code><br />
<code>       = g</code><sub><code>v</code></sub><code>⋅g</code><sub><code>v-1</code></sub><code>⋅...⋅g</code><sub><code>1</code></sub><code>⋅f(0) + (sum</code><sub><code>i=1..v</code></sub><code> t</code><sub><code>i</code></sub><code>⋅prod</code><sub><code>j=i..v</code></sub><code> g</code><sub><code>j</code></sub><code>)⋅G</code><br />
<code>       = g</code><sub><code>v</code></sub><code>⋅...⋅g</code><sub><code>0</code></sub><code>⋅Q</code><sub><code>0</code></sub><code> + g</code><sub><code>v</code></sub><code>⋅tacc</code><sub><code>v</code></sub><code>⋅G''</code><br />
<code>   where </code><em><code>tacc</code><sub><code>i</code></sub></em><code> is computed by </code><em><code>KeyAgg</code></em><code> and </code><em><code>ApplyTweak</code></em><code> as follows:</code><br />
<code>     ''tacc</code><sub><code>0</code></sub><code> = 0</code><br />
<code>     tacc</code><sub><code>i</code></sub><code> = t</code><sub><code>i</code></sub><code> + g</code><sub><code>i-1</code></sub><code>⋅tacc</code><sub><code>i-1</code></sub><code> for i=1..v mod n''</code><br />
<code>   for which it holds that </code><em><code>g</code><sub><code>v</code></sub><code>⋅tacc</code><sub><code>v</code></sub><code>  ``=``   ``sum</code><sub><code>i=1..v</code></sub><code>  ``t</code><sub><code>i</code></sub><code>⋅prod</code><sub><code>j=i..v</code></sub><code>  ``g</code><sub><code>j</code></sub></em><code>.</code></p>
</poem>
<p><poem> <em>KeyAgg</em> and <em>ApplyTweak</em> compute</p>
<p><code>   ''gacc</code><sub><code>0</code></sub><code> = 1</code><br />
<code>   gacc</code><sub><code>i</code></sub><code> = g</code><sub><code>i-1</code></sub><code>⋅gacc</code><sub><code>i-1</code></sub><code> for i=1..v mod n''</code></p>
<p>So we can rewrite above equation for the final public key as</p>
<p><code> </code><em><code>with_even_y(Q</code><sub><code>v</code></sub><code>)``   ``=``  ``g</code><sub><code>v</code></sub><code>⋅gacc</code><sub><code>v</code></sub><code>⋅Q</code><sub><code>0</code></sub><code>   ``+``  ``g</code><sub><code>v</code></sub><code>⋅tacc</code><sub><code>v</code></sub><code>⋅G</code></em><code>.</code></p>
</poem>
<p><poem> Then we have</p>
<p><code>   ''with_even_y(Q</code><sub><code>v</code></sub><code>) - g</code><sub><code>v</code></sub><code>⋅tacc</code><sub><code>v</code></sub><code>⋅G</code><br />
<code>       = g</code><sub><code>v</code></sub><code>⋅gacc</code><sub><code>v</code></sub><code>⋅Q</code><sub><code>0</code></sub><br />
<code>       = g</code><sub><code>v</code></sub><code>⋅gacc</code><sub><code>v</code></sub><code>⋅(a</code><sub><code>1</code></sub><code>⋅P</code><sub><code>1</code></sub><code> + ... + a</code><sub><code>u</code></sub><code>⋅P</code><sub><code>u</code></sub><code>)</code><br />
<code>       = g</code><sub><code>v</code></sub><code>⋅gacc</code><sub><code>v</code></sub><code>⋅(a</code><sub><code>1</code></sub><code>⋅d</code><sub><code>1</code></sub><code>'⋅G + ... + a</code><sub><code>u</code></sub><code>⋅d</code><sub><code>u</code></sub><code>'⋅G)</code><br />
<code>       = sum</code><sub><code>i=1..u</code></sub><code>(g</code><sub><code>v</code></sub><code>⋅gacc</code><sub><code>v</code></sub><code>⋅a</code><sub><code>i</code></sub><code>⋅d</code><sub><code>i</code></sub><code>')*G''.</code></p>
</poem>
<p>Intuitively, <em>gacc<sub>i</sub></em> tracks accumulated sign flipping and
<em>tacc<sub>i</sub></em> tracks the accumulated tweak value after applying the
first <em>i</em> individual tweaks. Additionally, <em>g<sub>v</sub></em> indicates
whether <em>Q<sub>v</sub></em> needed to be negated to produce the final X-only
result. Thus, signer <em>i</em> multiplies its secret key ''d<sub>i</sub>' ''
with <em>g<sub>v</sub>⋅gacc<sub>v</sub></em> in the
<em><a href="https://bips.dev/327/#Sign_negation" title="wikilink">Sign</a></em> algorithm.</p>
<h4 id="Negation_Of_The_Individual_Public_Key_When_Partially_Verifying">Negation Of The Individual Public Key When Partially Verifying</h4>
<p><poem> As explained in <a href="https://bips.dev/327/#negation-of-the-secret-key-when-signing" title="wikilink">Negation Of The Secret Key When
Signing</a> the signer
uses a possibly negated secret key</p>
<p><code>   </code><em><code>d``   ``=``   ``g</code><sub><code>v</code></sub><code>⋅gacc</code><sub><code>v</code></sub><code>⋅d'``  ``mod``   ``n</code></em></p>
<p>when producing a partial signature to ensure that the aggregate
signature will correspond to an aggregate public key with even Y
coordinate. </poem></p>
<p><poem> The <em><a href="https://bips.dev/327/#SigVerify_negation" title="wikilink">PartialSigVerifyInternal</a></em>
algorithm is supposed to check</p>
<p><code> </code><em><code>s⋅G``   ``=``   ``Re</code><sub><code>⁎</code></sub><code>   ``+``   ``e⋅a⋅d⋅G</code></em><code>.</code></p>
</poem>
<p><poem> The verifier doesn't have access to <em>d⋅G</em> but can construct it
using the individual public key <em>pk</em> as follows: ''d⋅G</p>
<p><code>   = g</code><sub><code>v</code></sub><code>⋅gacc</code><sub><code>v</code></sub><code>⋅d'⋅G</code><br />
<code>   = g</code><sub><code>v</code></sub><code>⋅gacc</code><sub><code>v</code></sub><code>⋅cpoint(pk)''</code></p>
<p>Note that the aggregate public key and list of tweaks are inputs to
partial signature verification, so the verifier can also construct
<em>g<sub>v</sub></em> and <em>gacc<sub>v</sub></em>. </poem></p>
<h3 id="Dealing_with_Infinity_in_Nonce_Aggregation">Dealing with Infinity in Nonce Aggregation</h3>
<p>If the nonce aggregator provides <em>aggnonce = bytes(33,0) ||
bytes(33,0)</em>, either the nonce aggregator is dishonest or there is at
least one dishonest signer (except with negligible probability). If
signing aborted in this case, it would be impossible to determine who is
dishonest. Therefore, signing continues so that the culprit is revealed
when collecting and verifying partial signatures.</p>
<p>However, the final nonce <em>R</em> of a BIP340 Schnorr signature cannot be the
point at infinity. If we would nonetheless allow the final nonce to be
the point at infinity, then the scheme would lose the following
property: if <em>PartialSigVerify</em> succeeds for all partial signatures,
then <em>PartialSigAgg</em> will return a valid Schnorr signature. Since this
is a valuable feature, we modify MuSig2* (which is defined in the
appendix of the <a rel="noopener" target="_blank" href="https://eprint.iacr.org/2020/1261">MuSig2 paper</a>) to
avoid producing an invalid Schnorr signature while still allowing
detection of the dishonest signer: In <em>GetSessionValues</em>, if the final
nonce <em>R</em> would be the point at infinity, set it to the generator
instead (an arbitrary choice).</p>
<p>This modification to <em>GetSessionValues</em> does not affect the
unforgeability of the scheme. Given a successful adversary against the
unforgeability game (EUF-CMA) for the modified scheme, a reduction can
win the unforgeability game for the original scheme by simulating the
modification towards the adversary: When the adversary provides
<em>aggnonce' = bytes(33, 0) || bytes(33, 0)</em>, the reduction sets <em>aggnonce
= cbytes_ext(G) || bytes(33, 0)</em>. For any other ''aggnonce' '', the
reduction sets ''aggnonce = aggnonce' ''. (The case that the adversary
provides an ''aggnonce' ≠ bytes(33, 0) || bytes(33, 0) '' but
nevertheless ''R' '' in <em>GetSessionValues</em> is the point at infinity
happens only with negligible probability.)</p>
<h3 id="Choosing_the_Size_of_the_Nonce">Choosing the Size of the Nonce</h3>
<p>The <a rel="noopener" target="_blank" href="https://eprint.iacr.org/2020/1261">MuSig2 paper</a> contains two
security proofs that apply to different variants of the scheme. The
first proof relies on the random oracle model (ROM) and applies to a
scheme variant where each signer's nonce consists of four elliptic curve
points. The second proof requires a stronger model, namely the
combination of the ROM and the algebraic group model (AGM), and applies
to an optimized scheme variant where the signers' nonces consist of only
two points. This proposal uses the latter, optimized scheme variant.
Relying on the stronger model is a legitimate choice for the following
reasons:</p>
<p>First, an approach widely taken is interpreting a Forking Lemma proof in
the ROM merely as design justification and ignoring the loss of security
due to the Forking Lemma. If one believes in this approach, then the ROM
may not be the optimal model in the first place because some parts of
the concrete security bound are arbitrarily ignored. One may just as
well move to the ROM+AGM model, which produces bounds close to the
best-known attacks, e.g., for Schnorr signatures.</p>
<p>Second, as of this writing, there is no instance of a serious
cryptographic scheme with a security proof in the AGM that is not secure
in practice. There are, however, insecure toy schemes with AGM security
proofs, but those explicitly violate the requirements of the AGM.
<a rel="noopener" target="_blank" href="https://eprint.iacr.org/2022/226.pdf">Broken AGM proofs of toy schemes</a>
provide group elements to the adversary without declaring them as group
element inputs. In contrast, in MuSig2, all group elements that arise in
the scheme are known to the adversary and declared as group element
inputs. A scheme very similar to MuSig2 and with two-point nonces was
independently proven secure in the ROM and AGM by <a rel="noopener" target="_blank" href="https://eprint.iacr.org/2020/1245">Alper and
Burdges</a>.</p>
<h2 id="Backwards_Compatibility">Backwards Compatibility</h2>
<p>This document proposes a standard for the MuSig2 multi-signature scheme
that is compatible with
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP340</a>.
MuSig2 is <em>not</em> compatible with ECDSA signatures traditionally used in
Bitcoin.</p>
<h2 id="Change_Log">Change Log</h2>
<p>To help implementers understand updates to this document, we attach a
version number that resembles <em>semantic versioning</em>
(<code>MAJOR.MINOR.PATCH</code>). The <code>MAJOR</code> version is incremented if changes to
the BIP are introduced that are incompatible with prior versions. An
exception to this rule is <code>MAJOR</code> version zero (0.y.z) which is for
development and does not need to be incremented if backwards
incompatible changes are introduced. The <code>MINOR</code> version is incremented
whenever the inputs or the output of an algorithm changes in a
backward-compatible way or new backward-compatible functionality is
added. The <code>PATCH</code> version is incremented for other changes that are
noteworthy (bug fixes, test vectors, important clarifications, etc.).</p>
<ul>
<li><strong>1.0.0</strong> (2023-03-26):
<ul>
<li>Number 327 was assigned to this BIP.</li>
</ul>
</li>
<li><strong>1.0.0-rc.4</strong> (2023-03-02):
<ul>
<li>Add expected value of <em>pubnonce</em> to <em>NonceGen</em> test vectors.</li>
</ul>
</li>
<li><strong>1.0.0-rc.3</strong> (2023-02-28):
<ul>
<li>Improve <em>NonceGen</em> test vectors by not using an all-zero hex
string as <em>rand_</em> values. This change addresses potential
issues in some implementations that interpret this as a special
value indicating uninitialized memory or a broken random number
generator and therefore return an error.</li>
<li>Fix invalid length of a <em>pubnonce</em> in the <em>PartialSigVerify</em>
test vectors.</li>
<li>Improve <em>KeySort</em> test vector.</li>
<li>Add explicit <em>IndividualPubkey</em> algorithm.</li>
<li>Rename KeyGen Context to KeyAgg Context.</li>
</ul>
</li>
<li><strong>1.0.0-rc.2</strong> (2022-10-28):
<ul>
<li>Fix vulnerability that can occur in certain unusual scenarios
(see <a rel="noopener" target="_blank" href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html">bitcoin-dev mailing
list</a>:
Add mandatory <em>pk</em> argument to <em>NonceGen</em>, append <em>pk</em> to
<em>secnonce</em> and check in <em>Sign</em> that the <em>pk</em> in <em>secnonce</em>
matches. Update test vectors.</li>
<li>Make sure that signer's key is in list of individual public keys
by adding failure case to <em>GetSessionKeyAggCoeff</em> and add test
vectors.</li>
</ul>
</li>
<li><strong>1.0.0-rc.1</strong> (2022-10-03): Submit draft BIP to the BIPs repository</li>
<li><strong>0.8.6</strong> (2022-09-15): Clarify that implementations do not need to
support every feature and add a test vector for signing with a
tweaked key</li>
<li><strong>0.8.5</strong> (2022-09-05): Rename some functions to improve clarity.</li>
<li><strong>0.8.4</strong> (2022-09-02): Make naming of nonce variants <em>R</em> in
specifications of the algorithms and reference code easier to read
and more consistent.</li>
<li><strong>0.8.3</strong> (2022-09-01): Overwrite <em>secnonce</em> in <em>sign</em> reference
implementation to help prevent accidental reuse and add test vector
for invalid <em>secnonce</em>.</li>
<li><strong>0.8.2</strong> (2022-08-30): Fix <em>KeySort</em> input length and add test
vectors</li>
<li><strong>0.8.1</strong> (2022-08-26): Add <em>DeterministicSign</em> algorithm</li>
<li><strong>0.8.0</strong> (2022-08-26): Switch from X-only to plain public key for
individual public keys. This requires updating a large portion of
the test vectors.</li>
<li><strong>0.7.2</strong> (2022-08-17): Add <em>NonceGen</em> and <em>Sign/PartialSigVerify</em>
test vectors for messages longer than 32 bytes.</li>
<li><strong>0.7.1</strong> (2022-08-10): Extract test vectors into separate JSON
file.</li>
<li><strong>0.7.0</strong> (2022-07-31): Change <em>NonceGen</em> such that output when
message is not present is different from when message is present but
has length 0.</li>
<li><strong>0.6.0</strong> (2022-07-31): Allow variable length messages, change
serialization of the message in the <em>NonceGen</em> hash function, and
add test vectors</li>
<li><strong>0.5.2</strong> (2022-06-26): Fix <em>aggpk</em> in <em>NonceGen</em> test vectors.</li>
<li><strong>0.5.1</strong> (2022-06-22): Rename &quot;ordinary&quot; tweaking to &quot;plain&quot;
tweaking.</li>
<li><strong>0.5.0</strong> (2022-06-21): Separate ApplyTweak from KeyAgg and
introduce KeyGen Context.</li>
<li><strong>0.4.0</strong> (2022-06-20): Allow the output of NonceAgg to be infinity
and add test vectors</li>
<li><strong>0.3.2</strong> (2022-06-02): Add a lot of test vectors and improve
handling of invalid contributions in reference code.</li>
<li><strong>0.3.1</strong> (2022-05-24): Add <em>NonceGen</em> test vectors</li>
<li><strong>0.3.0</strong> (2022-05-24): Hash <em>i - 1</em> instead of <em>i</em> in <em>NonceGen</em></li>
<li><strong>0.2.0</strong> (2022-05-19): Change order of arguments in <em>NonceGen</em> hash
function</li>
<li><strong>0.1.0</strong> (2022-05-19): Publication of draft BIP on the bitcoin-dev
mailing list</li>
</ul>
<h2 id="Footnotes">Footnotes</h2>
<references />
<h2 id="Acknowledgements">Acknowledgements</h2>
<p>We thank Brandon Black, Riccardo Casatta, Lloyd Fournier, Russell
O'Connor, and Pieter Wuille for their contributions to this document.</p>
<ol>
<li>Applications that sort individual public keys before aggregation
should ensure that the implementation of sorting is reasonably
efficient, and in particular does not degenerate to quadratic
runtime on pathological inputs.</li>
<li>We treat the <em>secnonce</em> and <em>pubnonce</em> as grammatically singular
even though they include serializations of two scalars and two
elliptic curve points, respectively. This treatment may be confusing
for readers familiar with the MuSig2 paper. However, serialization
is a technical detail that is irrelevant for users of MuSig2
interfaces.</li>
<li>Assume an adversary wants to forge a partial signature for
individual public key <em>P</em>. It joins the signing session pretending
to be two different signers, one with individual public key <em>P</em> and
one with another individual public key. The adversary can then set
the second signer's nonce such that it will be able to produce a
partial signature for <em>P</em> but not for the other claimed signer. An
explanation of the individual steps required to create a partial
signature forgery can be found in <a rel="noopener" target="_blank" href="https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b">a write up by Adam
Gibson</a>.</li>
<li>Given a list of individual public keys, it is an open question
whether a BIP-340 signature valid under the corresponding aggregate
public key is a proof of knowledge of all secret keys of the
individual public keys.</li>
<li>It is an open question whether allowing arbitrary tweaks from an
adversary affects the unforgeability of MuSig2.</li>
<li>The <em>IndividualPubkey</em> algorithm matches the key generation
procedure traditionally used for ECDSA in Bitcoin</li>
<li>The key aggregation coefficient is computed by hashing the
individual public key instead of its index, which requires one more
invocation of the SHA-256 compression function. However, it results
in significantly simpler implementations because signers do not need
to translate between public key indices before and after sorting.</li>
<li>In theory, the allowed message size is restricted because SHA256
accepts byte strings only up to size of 2^61-1 bytes (and because of
the 8-byte length encoding).</li>
<li>The random data is hashed (with a unique tag) as a precaution
against situations where the randomness may be correlated with the
secret signing key itself. It is xored with the secret key (rather
than combined with it in a hash) to reduce the number of operations
exposed to the actual secret key.</li>
<li></li>
<li></li>
<li>Failing <em>Sign</em> when <em>GetSessionKeyAggCoeff(session_ctx, P)</em> fails
is not necessary for unforgeability. It merely indicates to the
caller that the scheme is not being used correctly.</li>
<li>Verifying the signature before leaving the signer prevents random or
adversarially provoked computation errors. This prevents publishing
invalid signatures which may leak information about the secret key.
It is recommended but can be omitted if the computation cost is
prohibitive.</li>
<li></li>
<li><em>GetSessionKeyAggCoeff(session_ctx, P)</em> cannot fail when called
from <em>PartialSigVerifyInternal</em>.</li>
<li>Ensuring that the secret key provided to <em>Sign</em> is fully determined
already when <em>NonceGen</em> is invoked is a simple policy to rule out
the attack, but more flexible polices are conceivable. In fact, if
the signer uses nothing but the message to be signed and the list of
the individual public keys of all signers to decide which secret key
to use, then it is not a problem that the adversary can influence
this decision after having seen the <em>pubnonce</em>.<br />
More formally, consider modified algorithms ''NonceGen' '' and
''Sign' '', where ''NonceGen' '' does not take the individual public
key of the signer as input and does not store it in pubnonce, and
Sign' does not check read the individual public key from pubnonce
and does not check it against the secret key taken as input. Then it
suffices that for each invocation of ''NonceGen' '' with output
<em>(secnonce, pubnonce)</em>, a function <em>fsk</em> is determined before
sending out <em>pubnonce</em>, where <em>fsk</em> maps a pair consisting of a list
of individual public keys and a message to a secret key, such that
the secret key <em>sk</em> and the session context <em>session_ctx = (_, _,
pk<sub>1..u</sub>, _, _, _, m)</em> provided to the corresponding
invocation of <em>Sign'(secnonce, sk, session_ctx)</em>, adhere to the
condition <em>fsk(pk<sub>1..u</sub>, m) = sk</em>.<br />
However, this requirement is complex and hard to enforce in
implementations. The algorithms <em>NonceGen</em> and <em>Sign</em> specified in
this BIP are effectively restricted to constant functions <em>fsk(_,
_) = sk</em>. In other words, their usage ensure that the secret key
<em>sk</em> of the signers is determined entirely when invoking <em>NonceGen</em>,
which is enforced easily by letting <em>NonceGen</em> take the
corresponding individual public key <em>pk</em> as input and checking <em>pk</em>
against <em>IndividualPubKey(sk)</em> in <em>Sign</em>.</li>
<li></li>
</ol>

    </div>

        </div>
    </section>
    <footer class="footer">
        <div class="container has-text-centered has-text-weight-bold is-family-monospace">
            <p class="mb-1">Updated <span class="tag is-medium is-warning is-light">2024-02-27</span></p>
            <p>bips.dev - Made with &#x2615; by <a href="https://nickmonad.blog">nickmonad</a></p>
            <p>Check it out on <a href="https://github.com/nickmonad/bips-dev">GitHub</a></p>
            <p>Stay humble. Stack sats. &#x20bf;</p>
        </div>
    </footer>

     
</body>
</html>
