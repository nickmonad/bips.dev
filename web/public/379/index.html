<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Read BIPs like a pro." />
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="og:title" content="BIP 379: Miniscript" />
    <meta property="og:description" content="Read BIPs like a pro." />
    <meta property="og:image" content="https://bips.dev/og-bips-dev.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="BIP 379: Miniscript" />
    <meta name="twitter:description" content="Read BIPs like a pro." />
    <meta name="twitter:creator" content="@nickmonad" />
    <meta name="twitter:image" content="https://bips.dev/og-bips-dev.png" />

    <title>BIP 379: Miniscript</title>

    
        <link rel="stylesheet" href="/style.css" />
    

    <link rel="stylesheet" href="/pagefind/pagefind-ui.css" />
    <script src="/pagefind/pagefind-ui.js"></script>

    <script defer data-domain="bips.dev" src="/js/script.js"></script>
    <script>
        // setup plausible function for custom events
        window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }

        // setup and initialize dark mode
        // https://tailwindcss.com/docs/dark-mode
        window.setTheme = function() {
            if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark')
            } else {
                document.documentElement.classList.remove('dark')
            }
        }
        window.setTheme();

        // searching via
        // https://pagefind.app
        window.addEventListener('DOMContentLoaded', function(event) {
            new PagefindUI({
                element: "#search",
                hightlightParam: "highlight",
                showImages: false,
                showSubResults: true,
                translations: {
                    placeholder: "Search BIPs"
                },
                processTerm: function(term) {
                    plausible('Search');
                    return term;
                }
            });
        });
    </script>

    <style>
        /* variables to override on pagefind */
        /* https://pagefind.app/docs/ui-usage/#customising-the-styles */
        /* values are from tailwind: https://tailwindcss.com/docs/customizing-colors */
        :root {
            --pagefind-ui-primary: #334155;
            --pagefind-ui-text: #334155;
            --pagefind-ui-background: #ffffff;
            --pagefind-ui-border-width: 1px;
            --pagefind-ui-border-radius: 4px;
        }

        html.dark {
            --pagefind-ui-primary: #d1d5db;
            --pagefind-ui-text: #d1d5db;
            --pagefind-ui-background: #18181b;
            --pagefind-ui-border: #152028;
        }

        mark {
            background-color: #ff9900 !important;
            color: #6b7280 !important;
        }
    </style>
</head>

<body class="bg-white dark:bg-zinc-900">
    <div class="container mx-auto flex justify-center">
        <div data-pagefind-body class="min-w-full max-w-full lg:min-w-[1000px] lg:max-w-[1000px] px-6 py-10 space-y-10 text-slate-700 dark:text-gray-300">
            
    <div class="flex flex-col space-y-4 pt-4 md:pt-8">
        <div class="flex justify-between">
            <a href="/">Back to BIPs</a>
            <div class="flex">
                <svg id="toggleDark_light" class="hidden dark:flex w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'light'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
                </svg>
                <svg id="toggleDark_dark" class="flex dark:hidden w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'dark'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
                </svg>
            </div>
        </div>
        <div class="flex flex-col space-y-2">
            <div data-pagefind-weight="10" class="text-2xl font-extrabold">BIP 379: Miniscript</div>
            <div class="flex justify-between">
                <div class="text-xl font-semibold">2023-10-10</div>
                <a href="https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;blob&#x2F;master&#x2F;bip-0379.md" target="_blank">View on GitHub</a>
            </div>
        </div>

        <article class="max-w-none prose prose-lg prose-zinc prose-p:leading-relaxed prose-a:font-bold prose-a:underline prose-a:decoration-2 prose-a:decoration-bitcoin prose-pre:bg-zinc-200 prose-pre:text-zinc-800 dark:prose-invert dark:prose-pre:bg-zinc-600 dark:prose-pre:text-white">
            <pre><code>  BIP: 379
  Layer: Applications
  Title: Miniscript
  Author: Pieter Wuille &lt;pieter@wuille.net&gt;
          Andrew Poelstra &lt;andrew.poelstra@gmail.com&gt;
          Sanket Kanjalkar &lt;sanket1729@gmail.com&gt;
          Antoine Poinsot &lt;darosior@protonmail.com&gt;
          Ava Chow &lt;me@achow101.com&gt;
  Comments-Summary: No comments yet.
  Comments-URI: https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;wiki&#x2F;Comments:BIP-0379
  Status: Draft
  Type: Informational
  Created: 2023-10-10
  License: CC0-1.0
  Requires: 380
</code></pre>
<h2 id="Abstract">Abstract</h2>
<p>This document specifies Miniscript, a language for writing (a subset of) Bitcoin Scripts in a
structured way, enabling analysis, composition, generic signing and more.</p>
<h2 id="Copyright">Copyright</h2>
<p>This document is licensed under the Creative Commons CC0 1.0 Universal license.</p>
<h2 id="Motivation">Motivation</h2>
<p>Bitcoin Script is an unusual stack-based language with many edge cases, designed for implementing
spending conditions consisting of various combinations of signatures, hash locks, and time locks.
Yet, despite being limited in functionality, it is still highly nontrivial to:</p>
<ul>
<li>Given a combination of spending conditions, finding the most economical script to implement it.</li>
<li>Given two scripts, construct a script that implements a composition of their spending conditions (e.g. a multisig where one of the &quot;keys&quot; is another multisig).</li>
<li>Given a script, find out what spending conditions it permits.</li>
<li>Given a script and access to a sufficient set of private keys, construct a general satisfying witness for it.</li>
<li>Given a script, be able to predict the cost of spending an output.</li>
<li>Given a script, know whether particular resource limitations like the ops limit might be hit when spending.</li>
</ul>
<p>Miniscript functions as a representation for scripts that makes this sort of operations possible.
It has a structure that allows composition. It is very easy to statically analyze for various
properties (spending conditions, correctness, security properties, malleability, ...). It can be
targeted by spending policy compilers. Finally, compatible scripts can easily be converted to
Miniscript form - avoiding the need for additional metadata for e.g. signing devices that support
it.</p>
<h2 id="Specification">Specification</h2>
<p>These specifications apply to P2WSH (<a href="https://bips.dev/379/bip-0141.mediawiki">BIP 141</a>) and Tapscript (<a href="https://bips.dev/379/bip-0342.mediawiki">BIP 342</a>) scripts, with only minor
variations between the two. Differences are noted inline. Unless explicitly stated otherwise,
specifications apply to both. P2SH and bare scripts are excluded from this specification.</p>
<h3 id="Translation_Table">Translation Table</h3>
<p>Miniscript consists of a set of script <em>fragments</em> which are designed to be safely and correctly composable.</p>
<p>This table shows all Miniscript <em>fragments</em> and their associated semantics and Bitcoin Script.
Fragments that do not change the semantics of their subexpressions are called <em>wrappers</em>. Normal
fragments use a <code>fragment(arg1,arg2,...)</code> notation, while wrappers are written using
prefixes separated from other fragments by a colon. The colon is dropped between subsequent
wrappers; e.g.  <code>dv:older(144)</code> is the <code>d:</code> wrapper applied to the
<code>v:</code> wrapper applied to the <code>older</code> fragment for 144 blocks.</p>
<p>The <code>pk</code>, <code>pkh</code>, and <code>and_n</code> fragments and <code>t:</code>,
<code>l:</code>, and <code>u:</code> wrappers are syntactic sugar for other Miniscripts, as listed
in the table below. Note that <code>&lt;20&gt;</code> are in hex representation in this document.</p>
<p>Miniscript fragments are expected to be used in <a href="https://bips.dev/379/bip-0382.mediawiki">BIP 382</a> <code>wsh()</code> descriptors
and <a href="https://bips.dev/379/bip-0386.mediawiki">BIP 386</a> <code>tr()</code> descriptors. Key expressions are specified in
<a href="https://bips.dev/379/bip-0380.mediawiki#user-content-Key_Expressions">BIP 380</a>. Additionally, BIPs 382 and 386 specify
restrictions on key expressions and what they resolve to - these apply to key expressions in
Miniscript. BIP 382's key expression restrictions apply to Miniscript in P2WSH contexts, and BIP
386's key expression restrictions apply to Miniscript in P2TR contexts. From a user's perspective,
Miniscript is not a separate language, but rather a significant expansion of the descriptor language.</p>
<table><thead><tr><th>Semantics</th><th>Miniscript Fragment</th><th>Bitcoin Script</th></tr></thead><tbody>
<tr><td>false</td><td><code>0</code></td><td><code>0</code></td></tr>
<tr><td>true</td><td><code>1</code></td><td><code>1</code></td></tr>
<tr><td>check(key)</td><td><code>pk_k(key)</code></td><td><code>&lt;key&gt;</code></td></tr>
<tr><td></td><td><code>pk_h(key)</code></td><td><code>DUP HASH160 &lt;HASH160(key)&gt; EQUALVERIFY </code></td></tr>
<tr><td></td><td><code>pk(key)</code> = <code>c:pk_k(key)</code></td><td><code>&lt;key&gt; CHECKSIG</code></td></tr>
<tr><td></td><td><code>pkh(key)</code> = <code>c:pk_h(key)</code></td><td><code>DUP HASH160 &lt;HASH160(key)&gt; EQUALVERIFY CHECKSIG</code></td></tr>
<tr><td>nSequence ≥ n (and compatible)</td><td><code>older(n)</code></td><td><code>&lt;n&gt; CHECKSEQUENCEVERIFY</code></td></tr>
<tr><td>nLockTime ≥ n (and compatible)</td><td><code>after(n)</code></td><td><code>&lt;n&gt; CHECKLOCKTIMEVERIFY</code></td></tr>
<tr><td>len(x) = 32 and SHA256(x) = h</td><td><code>sha256(h)</code></td><td><code>SIZE &lt;0x20&gt; EQUALVERIFY SHA256 &lt;h&gt; EQUAL</code></td></tr>
<tr><td>len(x) = 32 and HASH256(x) = h</td><td><code>hash256(h)</code></td><td><code>SIZE &lt;0x20&gt; EQUALVERIFY HASH256 &lt;h&gt; EQUAL</code></td></tr>
<tr><td>len(x) = 32 and RIPEMD160(x) = h</td><td><code>ripemd160(h)</code></td><td><code>SIZE &lt;0x20&gt; EQUALVERIFY RIPEMD160 &lt;h&gt; EQUAL</code></td></tr>
<tr><td>len(x) = 32 and HASH160(x) = h</td><td><code>hash160(h)</code></td><td><code>SIZE &lt;0x20&gt; EQUALVERIFY HASH160 &lt;h&gt; EQUAL</code></td></tr>
<tr><td>(X and Y) or Z</td><td><code>andor(X,Y,Z)</code></td><td><code>[X] NOTIF [Z] ELSE [Y] ENDIF</code></td></tr>
<tr><td>X and Y</td><td><code>and_v(X,Y)</code></td><td><code>[X] [Y]</code></td></tr>
<tr><td></td><td><code>and_b(X,Y)</code></td><td><code>[X] [Y] BOOLAND</code></td></tr>
<tr><td></td><td><code>and_n(X,Y)</code> = <code>andor(X,Y,0)</code></td><td><code>[X] NOTIF 0 ELSE [Y] ENDIF</code></td></tr>
<tr><td>X or Z</td><td><code>or_b(X,Z)</code></td><td><code>[X] [Z] BOOLOR</code></td></tr>
<tr><td></td><td><code>or_c(X,Z)</code></td><td><code>[X] NOTIF [Z] ENDIF</code></td></tr>
<tr><td></td><td><code>or_d(X,Z)</code></td><td><code>[X] IFDUP NOTIF [Z] ENDIF</code></td></tr>
<tr><td></td><td><code>or_i(X,Z)</code></td><td><code>IF [X] ELSE [Z] ENDIF</code></td></tr>
<tr><td>X_1 + ... + X_n = k</td><td><code>thresh(k,X_1,...,X_n)</code></td><td><code>[X_1] [X_2] ADD ... [X_n] ADD ... &lt;k&gt; EQUAL</code></td></tr>
<tr><td>check(key_1) + ... + check(key_n) = k <em>(P2WSH only)</em></td><td><code>multi(k,key_1,...,key_n)</code></td><td><code>&lt;k&gt; &lt;key_1&gt; ... &lt;key_n&gt; &lt;n&gt; CHECKMULTISIG</code></td></tr>
<tr><td>check(key_1) + ... + check(key_n) = k <em>(Tapscript only)</em></td><td><code>multi_a(k,key_1,...,key_n)</code></td><td><code>&lt;key_1&gt; CHECKSIG &lt;key_2&gt; CHECKSIGADD ... &lt;key_n&gt; CHECKSIGADD &lt;k&gt; NUMEQUAL</code></td></tr>
<tr><td>X (identities)</td><td><code>a:X</code></td><td><code>TOALTSTACK [X] FROMALTSTACK</code></td></tr>
<tr><td></td><td><code>s:X</code></td><td><code>SWAP [X]</code></td></tr>
<tr><td></td><td><code>c:X</code></td><td><code>[X] CHECKSIG</code></td></tr>
<tr><td></td><td><code>t:X</code> = <code>and_v(X,1)</code></td><td><code>[X] 1</code></td></tr>
<tr><td></td><td><code>d:X</code></td><td><code>DUP IF [X] ENDIF</code></td></tr>
<tr><td></td><td><code>v:X</code></td><td><code>[X] VERIFY (or VERIFY version of last opcode in [X])</code></td></tr>
<tr><td></td><td><code>j:X</code></td><td><code>SIZE 0NOTEQUAL IF [X] ENDIF</code></td></tr>
<tr><td></td><td><code>n:X</code></td><td><code>[X] 0NOTEQUAL</code></td></tr>
<tr><td></td><td><code>l:X</code> = <code>or_i(0,X)</code></td><td><code>IF 0 ELSE [X] ENDIF</code></td></tr>
<tr><td></td><td><code>u:X</code> = <code>or_i(X,0)</code></td><td><code>IF [X] ELSE 0 ENDIF</code></td></tr>
</tbody></table>
<h3 id="Type_System">Type System</h3>
<p>Not every Miniscript expression can be composed with every other. Some return their result by
putting true or false on the stack; others can only abort or continue. Some require subexpressions
that consume an exactly known number of arguments, while others need a subexpression that has a
nonzero top stack element to satisfy. To model all these properties, we define a correctness type
system for Miniscript.</p>
<h4 id="Correctness">Correctness</h4>
<p>Every miniscript expression has one of four basic types: &quot;<strong>B</strong>&quot; (base), &quot;<strong>V</strong>&quot; (verify),
&quot;<strong>K</strong>&quot; (key) and &quot;<strong>W</strong>&quot; (wrapped). Then there are 5 type modifiers that guarantee additional
properties: &quot;<strong>z</strong>&quot; (zero-arg), &quot;<strong>o</strong>&quot; (one-arg), &quot;<strong>n</strong>&quot; (nonzero), &quot;<strong>d</strong>&quot;
(dissatisfiable), and &quot;<strong>u</strong>&quot; (unit).</p>
<p>The following table lists the correctness requirements for each of the Miniscript expressions, and
its type properties in function of those of their subexpressions.</p>
<table><thead><tr><th>Miniscript</th><th>Requires</th><th>Type</th><th>Properties</th></tr></thead><tbody>
<tr><td><code>0</code></td><td></td><td>B</td><td>z; u; d</td></tr>
<tr><td><code>1</code></td><td></td><td>B</td><td>z; u</td></tr>
<tr><td><code>pk_k(key)</code></td><td></td><td>K</td><td>o; n; d; u</td></tr>
<tr><td><code>pk_h(key)</code></td><td></td><td>K</td><td>n; d; u</td></tr>
<tr><td><code>older(n)</code>, <code>after(n)</code></td><td>1 ≤ n &lt; 2<sup>31</sup></td><td>B</td><td>z</td></tr>
<tr><td><code>sha256(h)</code></td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td><code>ripemd160(h)</code></td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td><code>hash256(h)</code></td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td><code>hash160(h)</code></td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td><code>andor(X,Y,Z)</code></td><td>X is Bdu; Y and Z are both B, K, or V</td><td>same as Y/Z</td><td>z=z<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub>; o=z<sub>X</sub>o<sub>Y</sub>o<sub>Z</sub> or o<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub>; u=u<sub>Y</sub>u<sub>Z</sub>; d=d<sub>Z</sub></td></tr>
<tr><td><code>and_v(X,Y)</code></td><td>X is V; Y is B, K, or V</td><td>same as Y</td><td>z=z<sub>X</sub>z<sub>Y</sub>; o=z<sub>X</sub>o<sub>Y</sub> or z<sub>Y</sub>o<sub>X</sub>; n=n<sub>X</sub> or z<sub>X</sub>n<sub>Y</sub>; u=u<sub>Y</sub></td></tr>
<tr><td><code>and_b(X,Y)</code></td><td>X is B; Y is W</td><td>B</td><td>z=z<sub>X</sub>z<sub>Y</sub>; o=z<sub>X</sub>o<sub>Y</sub> or z<sub>Y</sub>o<sub>X</sub>; n=n<sub>X</sub> or z<sub>X</sub>n<sub>Y</sub>; d=d<sub>X</sub>d<sub>Y</sub>; u</td></tr>
<tr><td><code>or_b(X,Z)</code></td><td>X is Bd; Z is Wd</td><td>B</td><td>z=z<sub>X</sub>z<sub>Z</sub>; o=z<sub>X</sub>o<sub>Z</sub> or z<sub>Z</sub>o<sub>X</sub>; d; u</td></tr>
<tr><td><code>or_c(X,Z)</code></td><td>X is Bdu; Z is V</td><td>V</td><td>z=z<sub>X</sub>z<sub>Z</sub>; o=o<sub>X</sub>z<sub>Z</sub></td></tr>
<tr><td><code>or_d(X,Z)</code></td><td>X is Bdu; Z is B</td><td>B</td><td>z=z<sub>X</sub>z<sub>Z</sub>; o=o<sub>X</sub>z<sub>Z</sub>; d=d<sub>Z</sub>; u=u<sub>Z</sub></td></tr>
<tr><td><code>or_i(X,Z)</code></td><td>both are B, K, or V</td><td>same as X/Z</td><td>o=z<sub>X</sub>z<sub>Z</sub>; u=u<sub>X</sub>u<sub>Z</sub>; d=d<sub>X</sub> or d<sub>Z</sub></td></tr>
<tr><td><code>thresh(k,X_1,...,X_n)</code></td><td>1 ≤ k ≤ n; X<sub>1</sub> is Bdu; others are Wdu</td><td>B</td><td>z=all are z; o=all are z except one is o; d; u</td></tr>
<tr><td><code>multi(k,key_1,...,key_n)</code></td><td>1 ≤ k ≤ n ≤ 20</td><td>B</td><td>n; d; u</td></tr>
<tr><td><code>multi_a(k,key_1,...,key_n)</code></td><td>1 ≤ k ≤ n</td><td>B</td><td>d; u</td></tr>
<tr><td><code>a:X</code></td><td>X is B</td><td>W</td><td>d=d<sub>X</sub>; u=u<sub>X</sub></td></tr>
<tr><td><code>s:X</code></td><td>X is Bo</td><td>W</td><td>d=d<sub>X</sub>; u=u<sub>X</sub></td></tr>
<tr><td><code>c:X</code></td><td>X is K</td><td>B</td><td>o=o<sub>X</sub>; n=n<sub>X</sub>; d=d<sub>X</sub>; u</td></tr>
<tr><td><code>d:X</code></td><td>X is Vz</td><td>B</td><td>o; n; d; <em>(Tapscript only)</em> u</td></tr>
<tr><td><code>v:X</code></td><td>X is B</td><td>V</td><td>z=z<sub>X</sub>; o=o<sub>X</sub>; n=n<sub>X</sub></td></tr>
<tr><td><code>j:X</code></td><td>X is Bn</td><td>B</td><td>o=o<sub>X</sub>; n; d; u=u<sub>X</sub></td></tr>
<tr><td><code>n:X</code></td><td>X is B</td><td>B</td><td>z=z<sub>X</sub>; o=o<sub>X</sub>; n=n<sub>X</sub>; d=d<sub>X</sub>; u</td></tr>
</tbody></table>
<h4 id="Timelock_Type_Mixing">Timelock Type Mixing</h4>
<p>There is one additional correctness property that Miniscript expressions must satisfy:
the four timelock types (absolute time based, absolute height based, relative time based, and
relative height based) must not be mixed in an incompatible way.</p>
<p>Within <code>and</code> combinators and the <code>thresh</code> combinator where k &gt;= 2, it is illegal for both absolute
height based and time based timelocks to appear, or for both relative height based and time based
timelocks to appear.</p>
<p>For all other combinators, it is legal to mix timelock types. It is also always legal to
mix absolute and relative timelocks (even if one is height based and the other is time based).</p>
<h4 id="Malleability">Malleability</h4>
<p>Malleability is the ability for a third party (someone who does <em>not</em> hold a participating private
key) to modify an existing satisfaction into another valid satisfaction. To analyze the
malleability guarantees of a script we define three additional type properties: &quot;<strong>s</strong>&quot; (signed),
&quot;<strong>f</strong>&quot; (forced) and &quot;<strong>e</strong>&quot; (expressive).</p>
<p>The following table lists the malleability properties and requirement of each fragment.</p>
<table><thead><tr><th>Miniscript</th><th>Requires</th><th>Properties</th></tr></thead><tbody>
<tr><td><code>0</code></td><td></td><td>s, e</td></tr>
<tr><td><code>1</code></td><td></td><td>f</td></tr>
<tr><td><code>pk_k(key)</code></td><td></td><td>s, e</td></tr>
<tr><td><code>pk_h(key)</code></td><td></td><td>s, e</td></tr>
<tr><td><code>older(n)</code></td><td></td><td>f</td></tr>
<tr><td><code>after(n)</code></td><td></td><td>f</td></tr>
<tr><td><code>sha256(h)</code></td><td></td><td></td></tr>
<tr><td><code>ripemd160(h)</code></td><td></td><td></td></tr>
<tr><td><code>hash256(h)</code></td><td></td><td></td></tr>
<tr><td><code>hash160(h)</code></td><td></td><td></td></tr>
<tr><td><code>andor(X,Y,Z)</code></td><td>e<sub>X</sub> and (s<sub>X</sub> or s<sub>Y</sub> or s<sub>Z</sub>)</td><td>s=s<sub>Z</sub> and (s<sub>X</sub> or s<sub>Y</sub>); f=f<sub>Z</sub> and (s<sub>X</sub> or f<sub>Y</sub>); e=e<sub>Z</sub> and (s<sub>X</sub> or f<sub>Y</sub>)</td></tr>
<tr><td><code>and_v(X,Y)</code></td><td></td><td>s=s<sub>X</sub> or s<sub>Y</sub>; f=s<sub>X</sub> or f<sub>Y</sub></td></tr>
<tr><td><code>and_b(X,Y)</code></td><td></td><td>s=s<sub>X </sub>or s<sub>Y;</sub> f=f<sub>Xf</sub><sub>Y</sub> or s<sub>X</sub>f<sub>X</sub> or s<sub>Y</sub>f<sub>Y</sub>; e=e<sub>X</sub>e<sub>Y</sub>s<sub>X</sub>s<sub>Y</sub></td></tr>
<tr><td><code>or_b(X,Z)</code></td><td>e<sub>Xe</sub><sub>Z </sub>and (s<sub>X</sub> or s<sub>Z</sub>)</td><td>s=s<sub>X</sub>s<sub>Z</sub>; e</td></tr>
<tr><td><code>or_c(X,Z)</code></td><td>e<sub>X</sub> and (s<sub>X</sub> or s<sub>Z</sub>)</td><td>s=s<sub>X</sub>s<sub>Z</sub>; f</td></tr>
<tr><td><code>or_d(X,Z)</code></td><td>e<sub>X</sub> and (s<sub>X</sub> or s<sub>Z</sub>)</td><td>s=s<sub>X</sub>s<sub>Z</sub>; f=f<sub>Z</sub>; e=e<sub>Z</sub></td></tr>
<tr><td><code>or_i(X,Z)</code></td><td>s<sub>X</sub> or s<sub>Z</sub></td><td>s=s<sub>X</sub>s<sub>Z</sub>; f=f<sub>X</sub>f<sub>Z</sub>; e=e<sub>X</sub>f<sub>Z</sub> or e<sub>Z</sub>f<sub>X</sub></td></tr>
<tr><td><code>thresh(k,X_1,...,X_n)</code></td><td>all are e; at most k are non-s</td><td>s=at most k-1 are non-s; e=all are s</td></tr>
<tr><td><code>multi(k,key_1,...,key_n)</code></td><td></td><td>s; e</td></tr>
<tr><td><code>multi_a(k,key_1,...,key_n)</code></td><td></td><td>s; e</td></tr>
<tr><td><code>a:X</code></td><td></td><td>s=s<sub>X</sub>; f=f<sub>X</sub>; e=e<sub>X</sub></td></tr>
<tr><td><code>s:X</code></td><td></td><td>s=s<sub>X</sub>; f=f<sub>X</sub>; e=e<sub>X</sub></td></tr>
<tr><td><code>c:X</code></td><td></td><td>s; f=f<sub>X</sub>; e=e<sub>X</sub></td></tr>
<tr><td><code>d:X</code></td><td></td><td>s=s<sub>X</sub>; e</td></tr>
<tr><td><code>v:X</code></td><td></td><td>s=s<sub>X</sub>; f</td></tr>
<tr><td><code>j:X</code></td><td></td><td>s=s<sub>X</sub>; e=f<sub>X</td></tr>
<tr><td><code>n:X</code></td><td></td><td>s=s<sub>X</sub>; f=f<sub>X</sub>; e=e<sub>X</sub></td></tr>
</tbody></table>
<h3 id="Satisfaction">Satisfaction</h3>
<p>The following table shows all valid satisfactions and dissatisfactions for every Miniscript, using
satisfactions and dissatisfactions of its subexpressions. Multiple possibilities are separated by
semicolons. Some options are inefficient and provably unnecessary to the satisfaction algorithm
described below, but are valid according to script rules and could be used by a malleator or other
non-standard actor. These are called <em>non-canonical</em> options, and are listed for completeness, but
<del>[struckthrough]</del>. The fragments where a satisfaction or dissatisfaction does not exist will
contain <em>(none)</em>. The fragments where the satisfaction or dissatisfaction is to provide no data
will contain <em>(empty)</em>.</p>
<table><thead><tr><th>Miniscript</th><th>Dissatisfactions (dsat)</th><th>Satisfactions (sat)</th></tr></thead><tbody>
<tr><td><code>0</code></td><td><em>(empty)</em></td><td><em>(none)</em></td></tr>
<tr><td><code>1</code></td><td><em>(none)</em></td><td><em>(empty)</em></td></tr>
<tr><td><code>pk_k(key)</code></td><td>0</td><td>sig</td></tr>
<tr><td><code>pk_h(key)</code></td><td>0 key</td><td>sig key</td></tr>
<tr><td><code>older(n)</code></td><td><em>(none)</em></td><td><em>(empty)</em></td></tr>
<tr><td><code>after(n)</code></td><td><em>(none)</em></td><td><em>(empty)</em></td></tr>
<tr><td><code>sha256(h)</code></td><td>any 32-byte vector except the preimage</td><td>preimage</td></tr>
<tr><td><code>ripemd160(h)</code></td><td>any 32-byte vector except the preimage</td><td>preimage</td></tr>
<tr><td><code>hash256(h)</code></td><td>any 32-byte vector except the preimage</td><td>preimage</td></tr>
<tr><td><code>hash160(h)</code></td><td>any 32-byte vector except the preimage</td><td>preimage</td></tr>
<tr><td><code>andor(X,Y,Z)</code></td><td>dsat(Z) dsat(X); <del>[dsat(Y) sat(X)]</del></td><td>sat(Y) sat(X); sat(Z) dsat(X)</td></tr>
<tr><td><code>and_v(X,Y)</code></td><td><em>(none)</em>; <del>[dsat(Y) sat(X)]</del></td><td>sat(Y) sat(X)</td></tr>
<tr><td><code>and_b(X,Y)</code></td><td>dsat(Y) dsat(X); <del>[sat(Y) dsat(X)]; [dsat(Y) sat(X)]</del></td><td>sat(Y) sat(X)</td></tr>
<tr><td><code>or_b(X,Z)</code></td><td>dsat(Z) dsat(X)</td><td>dsat(Z) sat(X); sat(Z) dsat(X); <del>[sat(Z) sat(X)]</del></td></tr>
<tr><td><code>or_c(X,Z)</code></td><td><em>(none)</em></td><td>sat(X); sat(Z) dsat(X)</td></tr>
<tr><td><code>or_d(X,Z)</code></td><td>dsat(Z) dsat(X)</td><td>sat(X); sat(Z) dsat(X)</td></tr>
<tr><td><code>or_i(X,Z)</code></td><td>dsat(X) 1; dsat(Z) 0</td><td>sat(X) 1; sat(Z) 0</td></tr>
<tr><td><code>thresh(k,X_1,...,X_n)</code></td><td>All dsats; <del>[Sats/dsats with 1 ≤ #(sats) ≠ k]</del></td><td>Sats/dsats with #(sats) = k</td></tr>
<tr><td><code>multi(k,key_1,...,key_n)</code></td><td>0 0 ... 0 (k+1 times)</td><td>0 sig ... sig</td></tr>
<tr><td><code>multi_a(k,key_1,...,key_n)</code></td><td>0 ... 0 (n times); <del>[sig/0 with #(sig) ≠ k]</del></td><td>sig/0 with #(sig) = k and #(sigs/0) = n</td></tr>
<tr><td><code>a:X</code></td><td>dsat(X)</td><td>sat(X)</td></tr>
<tr><td><code>s:X</code></td><td>dsat(X)</td><td>sat(X)</td></tr>
<tr><td><code>c:X</code></td><td>dsat(X)</td><td>sat(X)</td></tr>
<tr><td><code>d:X</code></td><td>0</td><td>sat(X) 1</td></tr>
<tr><td><code>v:X</code></td><td><em>(none)</em></td><td>sat(X)</td></tr>
<tr><td><code>j:X</code></td><td>0; <del>[dsat(X) (if nonzero top stack)]</del></td><td>sat(X)</td></tr>
<tr><td><code>n:X</code></td><td>dsat(X)</td><td>sat(X)</td></tr>
</tbody></table>
<h4 id="Non-malleable_Satisfaction_Algorithm">Non-malleable Satisfaction Algorithm</h4>
<p>In order to produce non-malleable satisfactions we make use of a function that returns the optimal
satisfaction and dissatisfaction for a given expression (if any exist), or a special DONTUSE (&quot;don't use&quot;) value,
together with an optional HASSIG (&quot;has signature&quot;) marker that tracks whether the solution contains at least one
signature. To implement the function:</p>
<ul>
<li>Invoke the function recursively for all subexpressions, obtaining all their satisfactions/dissatisfactions.</li>
<li>Iterate over all the valid satisfactions/dissatisfactions in the table above (including the non-canonical ones), taking into account:
<ul>
<li>The dissatisfactions for <code>sha256</code>, <code>ripemd160</code>, <code>hash256</code>, and <code>hash160</code> are always malleable, so instead use DONTUSE there.</li>
<li>The non-canonical options for <code>and_b</code>, <code>or_b</code>, and <code>thresh</code> are always overcomplete, so instead use DONTUSE there as well (with HASSIG flag if the original non-canonical solution had one).</li>
<li>The satisfactions for <code>pk_k</code>, <code>pk_h</code>, and <code>multi</code> can be marked HASSIG.</li>
<li>When constructing solutions by combining results for subexpressions, the result is DONTUSE if any of the constituent results is DONTUSE. Furthermore, the result gets the HASSIG tag if any of the constituents does.</li>
</ul>
</li>
<li>If among all valid solutions (including DONTUSE ones) more than one does not have the HASSIG marker, return DONTUSE.</li>
<li>If instead exactly one does not have the HASSIG marker, return that solution.</li>
<li>If all valid solutions have the HASSIG marker, but all of them are DONTUSE, return DONTUSE-HASSIG. The HASSIG marker is important because while this represents a choice between multiple options that would cause malleability if used, they are not available to the attacker, and we may be able to avoid them entirely still.</li>
<li>Otherwise, all not-DONTUSE options are valid, so return the smallest one (in terms of witness size).</li>
</ul>
<p>To produce an overall satisfaction, invoke the function on the toplevel expression. If no valid
satisfaction is returned, or it is DONTUSE, fail. Otherwise, if any timelocking is used in the
script but the result does not have the HASSIG flag, also fail. If the satisfaction is both not
DONTUSE and HASSIG, return it.</p>
<h2 id="Discussion">Discussion</h2>
<h2 id="Security">Security</h2>
<p>Miniscript primarily aims to provide guarantees on the correctness of a Bitcoin Script. That is, to
guarantee <strong>consensus soundness</strong> and <strong>standardness completeness</strong>. Consensus soundness means
it is not possible to construct a consensus-valid witness for a Bitcoin Script unless the Miniscript
spending conditions are met. Standardness completeness means a standardness-valid witness can be
created for all spending paths of a Miniscript, assuming the resource limits are respected and there
is no timelock mixing.</p>
<p>Additionally, Miniscript can guarantee the non-malleability and maximum size of a witness. These can
assist in assessing the soundness of protocols where transaction fees (and therefore transaction
size) are security-critical parameters.</p>
<p>Hash preimages are constrained to 32 bytes to disallow various forms of griefing, including making
non-standard (un-relayable) transactions, consensus-invalid swaps across blockchains, as well as
ensure that satisfaction cost can be accurately calculated.</p>
<p>In order for these properties to not just apply to script, but to an entire transaction, it's
important that the witness commits to all data relevant for verification. In practice this means
that scripts whose conditions can be met without any digital signature are insecure. Besides being
trivially insecure, note how a transaction lacking a signature check allows an attacker to change
its nLockTime and nSequence fields to meet additional timelock conditions.</p>
<h3 id="Type_System-1">Type System</h3>
<p>To statically verify the correctness and malleability guarantees discussed in the previous section,
we define a type system. See the specifications above for a reference of each fragment's
requirements and properties. Here we give more information about each type.</p>
<p>Every expression has one of four basic types:</p>
<ul>
<li>&quot;<strong>B</strong>&quot; Base expressions. These take their inputs from the top of the stack. When satisfied, they push a nonzero value of up to 4 bytes onto the stack. When dissatisfied, they push an exact 0 onto the stack (if dissatisfaction without aborting is possible at all). This type is used for most expressions, and required for the top level expression. An example is <code>older(n)</code> = <code>&lt;n&gt; CHECKSEQUENCEVERIFY</code>.</li>
<li>&quot;<strong>V</strong>&quot; Verify expressions. Like &quot;B&quot;, these take their inputs from the top of the stack. Upon satisfaction however, they continue without pushing anything. They cannot be dissatisfied (will abort instead). A &quot;V&quot; can be obtained using the <code>v:</code> wrapper on a &quot;B&quot; expression, or by combining other &quot;V&quot; expressions using <code>and_v</code>, <code>or_i</code>, <code>or_c</code>, or <code>andor</code>. An example is <code>v:pk(key)</code> = <code>&lt;key&gt; CHECKSIGVERIFY</code>.</li>
<li>&quot;<strong>K</strong>&quot; Key expressions. They again take their inputs from the top of the stack, but instead of verifying a condition directly they always push a public key onto the stack, for which a signature is still required to satisfy the expression. A &quot;K&quot; can be converted into a &quot;B&quot; using the <code>c:</code> wrapper. An example is <code>pk_h(key)</code> = <code>DUP HASH160 &lt;Hash160(key)&gt; EQUALVERIFY</code>.</li>
<li>&quot;<strong>W</strong>&quot; Wrapped expressions. They take their inputs from one below the top of the stack, and push a nonzero (in case of satisfaction) or zero (in case of dissatisfaction) either on top of the stack, or one below. So for example a 3-input &quot;W&quot; would take the stack &quot;A B C D E F&quot; and turn it into &quot;A B F 0&quot; or &quot;A B 0 F&quot; in case of dissatisfaction, and &quot;A B F n&quot; or &quot;A B n F&quot; in case of satisfaction (with n a nonzero value). Every &quot;W&quot; is either <code>s:B</code> (SWAP B) or <code>a:B</code> (TOALTSTACK B FROMALTSTACK). An example is <code>s:pk(key)</code> = <code>SWAP &lt;key&gt; CHECKSIG</code>.</li>
</ul>
<p>Then there are 6 type modifiers, which guarantee additional properties:</p>
<ul>
<li>&quot;<strong>z</strong>&quot; Zero-arg: this expression always consumes exactly 0 stack elements.</li>
<li>&quot;<strong>o</strong>&quot; One-arg: this expression always consumes exactly 1 stack element.</li>
<li>&quot;<strong>n</strong>&quot; Nonzero: this expression always consumes at least 1 stack element, no satisfaction for this expression requires the top input stack element to be zero.</li>
<li>&quot;<strong>d</strong>&quot; Dissatisfiable: a dissatisfaction for this expression can unconditionally be constructed. This implies the dissatisfaction cannot include any signature or hash preimage, and cannot rely on timelocks being satisfied.</li>
<li>&quot;<strong>u</strong>&quot; Unit: when satisfied, this expression will put an exact 1 on the stack (as opposed to any nonzero value).</li>
<li>&quot;<strong>k</strong>&quot; No timelock mixing. This expression does not contain a mix of heightlock and timelock of the same type. If the miniscript does not have the &quot;k&quot; property, the miniscript template will not match the user expectation of the corresponding spending policy.</li>
</ul>
<p>Finally to analyze malleability guarantees we introduce 3 new type modifiers:</p>
<ul>
<li>&quot;<strong>s</strong>&quot; Signed: satisfying this expression always requires a signature (predicting whether all satisfactions will be HASSIG).</li>
<li>&quot;<strong>f</strong>&quot; Forced: dissatisfying this expression always requires a signature (predicting whether all dissatisfactions will be HASSIG).</li>
<li>&quot;<strong>e</strong>&quot; Expressive: this requires a unique unconditional dissatisfaction to exist, and forces all conditional dissatisfactions (if any) to require a signature.</li>
</ul>
<h3 id="Malleability-1">Malleability</h3>
<p>Since Segwit, malleating a transaction no longer breaks the validity of unconfirmed descendant
transactions. However, unintentional malleability may still have a number of much weaker undesirable
effects. If a witness can be stuffed with additional data, the transaction's feerate will go down,
potentially to the point where its ability to propagate and get confirmed is impacted. Additionally,
malleability can be exploited to add roundtrips to BIP152 block propagation, by trying to get
different miners to mine different versions of the same transaction. Finally, malleability may
interfere with the usage of hash locks as a mechanism for publishing preimages.</p>
<p>Using the malleability type properties it is possible to determine statically whether a script can
be non-malleably satisfied under all circumstances. In many cases it is reasonable to only accept
such guaranteed-non-malleable scripts, as unexpected behavior can occur when using other scripts.</p>
<p>For example, when running the non-malleable satisfaction algorithm above, adding available
preimages, or increasing the nLockTime/nSequence values actually may make it fail where it succeeded
before. This is because a larger set of met conditions may mean an existing satisfaction goes from
non-malleable to malleable. Restricting things to scripts that are guaranteed to be satisfiable in a
non-malleable way avoids this problem.</p>
<p>When analysing Miniscripts for resource limits, restricting yourself to just non-malleable solutions
(or even non-malleable scripts) also leads to tighter bounds, as all non-canonical satisfactions and
dissatisfactions can be left out of consideration.</p>
<p>The malleability analysis makes the following assumptions:</p>
<ul>
<li>The attacker does not have access to any of the private keys of public keys that participate in the Script. Participants with private keys inherently have the ability to produce different satisfactions by creating multiple signatures. While it is also interesting to study the impact rogue participants can have, we treat it as a distinct problem.</li>
<li>The attacker only has access to hash preimages that honest users have access to as well. This is a reasonable assumption because hash preimages are revealed once globally, and then available to everyone. On the other hand, making the assumption that attackers may have access to more preimages than honest users makes a large portion of scripts impossible to satisfy in a non-malleable way.</li>
<li>The attacker gets to see exactly one satisfying witness of any transaction. If he sees multiple, it becomes possible for the attacker to mix and match different satisfactions. This is very hard to reason about.</li>
<li>We restrict this analysis to scripts where no public key is repeated. If signatures constructed for one part of the script can be bound to other checks in the same script, a variant of the mixing from the previous point becomes available that is equally hard to reason about. Furthermore this situation can be avoided by using separate keys.</li>
<li>The attacker is constrained by common standardness rules. A miner may be able to malleate a witness considered non-malleable by Miniscript.</li>
</ul>
<h4 id="Non-Malleable_Satisfaction">Non-Malleable Satisfaction</h4>
<p>Malleable satisfactions or dissatisfactions appear whenever options are available to attackers distinct from the one taken by honest users. This can happen for multiple reasons:</p>
<ol>
<li>Two or more options for a satisfaction or dissatisfaction are listed in the table above which are both available to attackers directly. Regardless of which option is used in the honest solution, the attacker can change the solution to the other one.</li>
<li>Two or more options for a satisfaction or dissatisfaction are listed in the table above, only one of which is available to attackers, but the honest solution uses another one. In that case, the attacker can modify the solution to pick the one available to him.</li>
<li>The honest users pick a solution that contains a satisfaction which can be turned into a dissatisfaction without invalidating the overall witness. Those are called overcomplete solutions.</li>
</ol>
<p>Because we assume attackers never have access to private keys, we can treat any solution that
includes a signature as one that is unavailable to attackers. For others, the worst case is that the
attacker has access to every solution the honest users have, but no others: for preimages this is an
explicit assumption, while timelock availability is determined by the nLockTime and nSequence fields
in the transaction. As long as the overall satisfaction includes at least one signature, those
values are fixed, and timelock availability is identical for attackers and honest users.</p>
<p>The description of the non-malleable satisfaction algorithm can be used to show that no
non-canonical solutions listed in the satisfaction table can occur inside non-malleable
satisfaction:</p>
<ul>
<li>Some of the non-canonical options (the <code>or_b</code>, <code>and_b</code>, and <code>thresh</code> ones) are overcomplete, and thus can clearly not appear in non-malleable satisfactions.</li>
<li>The fact that non-&quot;d&quot; expressions cannot be dissatisfied in valid witnesses rules out the usage of the non-canonical <code>and_v</code> dissatisfaction.</li>
<li>&quot;d&quot; expressions are defined to be unconditionally dissatisfiable, which implies that for those a non-HASSIG dissatisfaction must exist. Non-HASSIG solutions must be preferred over HASSIG ones (reason 2), and when multiple non-HASSIG ones exist, none can be used (reason 1). This lets us rule out the other non-canonical options in the table:
<ul>
<li><code>j:X</code> is always &quot;d&quot;, its non-HASSIG dissatisfaction &quot;0&quot; always exists, and thus rules out any usage of &quot;dsat(X)&quot;.</li>
<li>If <code>andor(X,Y,Z)</code> is &quot;d&quot;, a non-HASSIG dissatisfaction &quot;dsat(Z) dsat(X)&quot; must exist, and thus rules out any usage of &quot;dsat(Y) sat(X)&quot;.</li>
<li>If <code>and_b(X,Y)</code> is &quot;d&quot;, a non-HASSIG dissatisfaction &quot;dsat(Y) dsat(X)&quot; must exist, and thus rules out any usage of &quot;dsat(Y) sat(X)&quot; and &quot;sat(Y) dsat(X)&quot;. Those are also overcomplete.</li>
<li><code>thresh(k,...)</code> is always &quot;d&quot;, a non-HASSIG dissatisfaction with just dissatisfactions must exist due to typing rules, and thus rules out usage of the other dissatisfactions. They are also overcomplete.</li>
</ul>
</li>
</ul>
<h3 id="Resource_Limits">Resource Limits</h3>
<p>Various types of Bitcoin Scripts have different resource limitations, either through consensus or standardness. Some of them affect otherwise valid Miniscripts:</p>
<ul>
<li>In P2WSH, scripts larger than 3600 bytes are invalid by standardness. In Tapscript, scripts are implicitly bounded by the maximum size of a block (1 million virtual bytes).</li>
<li>In P2WSH, script satisfactions where the total number of non-push opcodes plus the number of keys participating in all executed <code>CHECKMULTISIG</code> is above 201 are invalid by consensus.</li>
<li>In both Tapscript and P2WSH, script satisfactions which make the stack exceed 1000 elements before or during execution are invalid.</li>
<li>In P2WSH, satisfactions with a witness consisting of over 100 stack elements (excluding the script itself) are invalid by standardness.</li>
</ul>
<p>A static analysis can be performed on a Miniscript to verify if none, all or any of the spending
paths hit any of the limits.</p>
<h2 id="Test_Vectors">Test Vectors</h2>
<p>TBD</p>
<h2 id="Backwards_Compatibility">Backwards Compatibility</h2>
<p>Miniscript's syntax is compatible with BIP 380 Output Script Descriptors, and should be considered
an extension to it that provides a new type of Script expression that is only valid in
<code>wsh()</code> and <code>tr()</code> contexts. As these are wholly new expressions, they are not
compatible with any existing implementation of descriptors. Additionally, the scripts produced are
unlikely to be standard scripts.</p>
<p>The <code>pk()</code>, <code>pkh()</code>, <code>multi()</code>, and <code>multi_a()</code>
fragments overlap with existing descriptors. These parse to the same semantic meanings as those
descriptors and produce the same scripts.</p>
<h2 id="Reference_Implementation">Reference Implementation</h2>
<p>A first reference implementation and documentation for Miniscript in P2WSH was originally published at
https://github.com/sipa/miniscript .</p>
<p>The reference implementation for Miniscript in P2WSH was introduced in Bitcoin Core through PRs
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bitcoin/pull/24147">24147</a>, <a rel="noopener" target="_blank" href="https://github.com/bitcoin/bitcoin/pull/24148">24148</a>, and
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bitcoin/pull/24149">24149</a>. The last one to be merged was released in Bitcoin
Core version 25.0.</p>
<p>The reference implementation for Miniscript in Tapscript was introduced in Bitcoin Core in PR
<a rel="noopener" target="_blank" href="https://github.com/bitcoin/bitcoin/pull/27255">27255</a>. This PR was merged and released in Bitcoin Core
version 26.0.</p>

        </article>
    </div>


            <hr class="border-slate-700" />

            <div data-pagefind-ignore class="w-full flex flex-col items-center space-y-2 text-center">
                <div class="flex items-center space-x-2">
                    <p class="font-bold">Updated</p>
                    <p class="font-bold">2025-11-02</p>
                </div>
                <p>See an issue with rendering or formatting? Submit an issue on <a href="https://github.com/nickmonad/bips.dev" target="_blank">GitHub</a></p>
                <p>Do you find this site useful? Please consider <a href="https://buy.tryspeed.com/plink_live_lyek4a2yW2Sn2wfA" target="_blank">donating</a> some sats to support ongoing development.</p>
                <p><a href="/">bips.dev</a> is presented by <a href="https://nickmonad.blog" target="_blank">nickmonad</a></p>
                <p class="pt-4 text-sm">All content is owned and licensed by the respective author(s). This website makes no claim of ownership.</p>
            </div>
        </div>
    </div>
</body>
</html>
