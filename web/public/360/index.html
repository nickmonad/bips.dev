<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Read BIPs like a pro." />
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="og:title" content="BIP 360: Pay-to-Merkle-Root (P2MR)" />
    <meta property="og:description" content="Read BIPs like a pro." />
    <meta property="og:image" content="https://bips.dev/og-bips-dev.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="BIP 360: Pay-to-Merkle-Root (P2MR)" />
    <meta name="twitter:description" content="Read BIPs like a pro." />
    <meta name="twitter:creator" content="@nickmonad" />
    <meta name="twitter:image" content="https://bips.dev/og-bips-dev.png" />

    <title>BIP 360: Pay-to-Merkle-Root (P2MR)</title>

    
        <link rel="stylesheet" href="/style.css" />
    

    <link rel="stylesheet" href="/pagefind/pagefind-ui.css" />
    <script src="/pagefind/pagefind-ui.js"></script>

    <script defer data-domain="bips.dev" src="/js/script.js"></script>
    <script>
        // setup plausible function for custom events
        window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }

        // setup and initialize dark mode
        // https://tailwindcss.com/docs/dark-mode
        window.setTheme = function() {
            if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark')
            } else {
                document.documentElement.classList.remove('dark')
            }
        }
        window.setTheme();

        // searching via
        // https://pagefind.app
        window.addEventListener('DOMContentLoaded', function(event) {
            new PagefindUI({
                element: "#search",
                hightlightParam: "highlight",
                showImages: false,
                showSubResults: true,
                translations: {
                    placeholder: "Search BIPs"
                },
                processTerm: function(term) {
                    plausible('Search');
                    return term;
                }
            });
        });
    </script>

    <style>
        /* variables to override on pagefind */
        /* https://pagefind.app/docs/ui-usage/#customising-the-styles */
        /* values are from tailwind: https://tailwindcss.com/docs/customizing-colors */
        :root {
            --pagefind-ui-primary: #334155;
            --pagefind-ui-text: #334155;
            --pagefind-ui-background: #ffffff;
            --pagefind-ui-border-width: 1px;
            --pagefind-ui-border-radius: 4px;
        }

        html.dark {
            --pagefind-ui-primary: #d1d5db;
            --pagefind-ui-text: #d1d5db;
            --pagefind-ui-background: #18181b;
            --pagefind-ui-border: #152028;
        }

        mark {
            background-color: #ff9900 !important;
            color: #6b7280 !important;
        }
    </style>
</head>

<body class="bg-white dark:bg-zinc-900">
    <div class="container mx-auto flex justify-center">
        <div data-pagefind-body class="min-w-full max-w-full lg:min-w-[1000px] lg:max-w-[1000px] px-6 py-10 space-y-10 text-slate-700 dark:text-gray-300">
            
    <div class="flex flex-col space-y-4 pt-4 md:pt-8">
        <div class="flex justify-between">
            <a href="/">Back to BIPs</a>
            <div class="flex">
                <svg id="toggleDark_light" class="hidden dark:flex w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'light'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
                </svg>
                <svg id="toggleDark_dark" class="flex dark:hidden w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'dark'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
                </svg>
            </div>
        </div>
        <div class="flex flex-col space-y-2">
            <div data-pagefind-weight="10" class="text-2xl font-extrabold">BIP 360: Pay-to-Merkle-Root (P2MR)</div>
            <div class="flex justify-between">
                <div class="text-xl font-semibold">2024-12-18</div>
                <a href="https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;blob&#x2F;master&#x2F;bip-0360.mediawiki" target="_blank">View on GitHub</a>
            </div>
        </div>

        <article class="max-w-none prose prose-lg prose-zinc prose-p:leading-relaxed prose-a:font-bold prose-a:underline prose-a:decoration-2 prose-a:decoration-bitcoin prose-pre:bg-zinc-200 prose-pre:text-zinc-800 dark:prose-invert dark:prose-pre:bg-zinc-600 dark:prose-pre:text-white">
            <pre><code>  BIP: 360
  Layer: Consensus (soft fork)
  Title: Pay-to-Merkle-Root (P2MR)
  Authors: Hunter Beast &lt;hunter@surmount.systems&gt;
           Ethan Heilman &lt;ethan.r.heilman@gmail.com&gt;
           Isabel Foxen Duke &lt;isabel.duke@gmail.com&gt;
  Status: Draft
  Type: Specification
  Assigned: 2024-12-18
  License: BSD-3-Clause
  Version: 0.11.0
  Requires: 340, 341, 342
</code></pre>
<h2>Introduction</h2>
<h3>Abstract</h3>
<p>This document proposes a new output type: Pay-to-Merkle-Root (P2MR), via a soft fork. P2MR outputs operate with nearly the same functionality as P2TR (Pay-to-Taproot) outputs, but with the key path spend removed.</p>
<p>Through this modification, P2MR outputs allow developers to use script trees and tapscript in a manner that is:</p>
<ol>
<li>resistant to long exposure attacks by Cryptographically Relevant Quantum Computers (CRQCs), and</li>
<li>resistant to future cryptanalytic approaches that may compromise the elliptic curve cryptography (ECC) used by Bitcoin.</li>
</ol>
<p>It is worth noting that proposed P2MR outputs are only resistant to &quot;long exposure attacks&quot; on elliptic curve cryptography; that is, attacks on keys exposed for time periods longer than needed to confirm a spending transaction.</p>
<p>Protection against more sophisticated quantum attacks, including protection against private key recovery from public keys exposed in the mempool while a transaction is waiting to be confirmed (a.k.a. &quot;short exposure attacks&quot;), may require the introduction of post-quantum signatures in Bitcoin. We believe it's worth considering this path in the future and intend to offer a separate proposal for this purpose upon further research.</p>
<p>This document additionally defines &quot;long exposure&quot; and &quot;short exposure&quot; attacks, and other new terminology in the Glossary.</p>
<h3>Copyright</h3>
<p>This document is licensed under the 3-clause BSD license.</p>
<h3>Motivation</h3>
<p>The primary threat to Bitcoin from Cryptographically Relevant Quantum Computers (CRQCs) is their potential to break the key cryptographic assumption which secures the digital signatures used in Bitcoin.<sup id="cite_ref_1"><a href="#cite_ref_1">1</a></sup> More specifically, <a href="https://arxiv.org/pdf/quant-ph/0301141" target="_blank">Shor's algorithm</a> enables a CRQC to solve the Discrete Logarithm Problem (DLP) exponentially faster than classical methods.<sup id="cite_ref_2"><a href="#cite_ref_2">2</a></sup> This allows the derivation of private keys from public keys — a process referred to here as quantum key recovery.<sup id="cite_ref_3"><a href="#cite_ref_3">3</a></sup> While it is unclear when or if CRQCs will become viable in the future, we propose the addition of a quantum-resistant, <a href="#script-tree-output-type" target="_blank">script tree output type</a> for those interested in this level of protection.</p>
<p>While some may balk at the potential threat of quantum computers to Bitcoin given their limited functionality to date, some others — including governments, corporations and some existing and potential Bitcoin users — are concerned about their potential for advancement. The Commercial National Security Algorithm Suite (CNSA) 2.0, for instance, has mandated software and networking equipment to be upgraded to post-quantum schemes by 2030, with browsers and operating systems fully upgraded by 2033. Additionally, according to NIST IR 8547, Elliptic Curve Cryptography (ECC) is planned to be disallowed within the US federal government after 2035 (with an exception made for hybrid cryptography, or the use of ECC and post-quantum algorithms together). These kinds of mandates have triggered concern by some ECC users, including some Bitcoin users who prefer to be prepared out of an abundance of caution.</p>
<p>In the most optimistic case, wherein quantum computers never pose a significant risk to ECC, we understand that the possibility of quantum advancement alone may be influencing adoption and broad confidence in the Bitcoin network. In other words, we believe users' fear of quantum computers may be worth addressing regardless of CRQC viability. Given these concerns, we think it's worth considering simple low risk changes that create options for using Bitcoin in a quantum-resistant way.</p>
<p>As a conservative first step in this effort, we propose Pay-to-Merkle-Root (P2MR), a script tree output that can be used in a quantum resistant manner.</p>
<h3>Long Exposure vs Short Exposure Attacks</h3>
<p>For clarity, this proposal specifically mitigates the risk of long exposure attacks on outputs that support tapscript and script trees. While some other Bitcoin output types, such as P2SH, are safe against long exposure attacks, taproot is not and taproot is the only currently activated output type that supports tapscript and script trees.</p>
<p>A long exposure attack is an attack performed on exposed blockchain data, such as exposed public keys, or the scripts of spent outputs. These are likely to be the earliest quantum attacks made possible on Bitcoin, because attackers will have ample time — as much time as vulnerable keys are exposed — to carry out quantum key recovery.</p>
<p>Short exposure attacks, however, require faster quantum computers, because they must occur within the relatively short time that a transaction is unconfirmed in the mempool.</p>
<p>Bitcoin outputs are generally vulnerable to short exposure attacks, as most Bitcoin transactions require revealing the associated public key when spending. Full protection of outputs from short exposure attacks may require the use of post-quantum signature schemes.</p>
<p>Since long exposure attacks on public keys are likely to be the first quantum-enabled threat to Bitcoin, we propose a script tree output that is resistant to long exposure attacks as a first step in hardening Bitcoin against the potential threat of quantum computers.</p>
<p>The following list of output types describes their long exposure attack vulnerability:</p>
<table><thead><tr><th>Type</th><th>Vulnerable</th><th>Prefix</th><th>Example</th></tr></thead><tbody>
<tr><td>P2PK</td><td>Yes</td><td>Varies</td><td>02103203b768951584fe9af6d9d9e6ff26a5f76e453212f19ba163774182ab8057f3eac</td></tr>
<tr><td>P2PKH</td><td>No*</td><td>1</td><td>1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</td></tr>
<tr><td>P2MS</td><td>Yes</td><td>Varies</td><td>52410496ec45f878b62c46c4be8e336dff7cc58df9b502178cc240e...</td></tr>
<tr><td>P2SH</td><td>No*</td><td>3</td><td>3FkhZo7sGNue153xhgqPBcUaBsYvJW6tTx</td></tr>
<tr><td>P2WPKH</td><td>No*</td><td>bc1q</td><td>bc1qsnh5ktku9ztqeqfr89yrqjd05eh58nah884mku</td></tr>
<tr><td>P2WSH</td><td>No*</td><td>bc1q</td><td>bc1qvhu3557twysq2ldn6dut6rmaj3qk04p60h9l79wk4lzgy0ca8mfsnffz65</td></tr>
<tr><td>P2TR</td><td>Yes</td><td>bc1p</td><td>bc1p92aslsnseq786wxfk3ekra90ds9ku47qttupfjsqmmj4z82xdq4q3rr58u</td></tr>
<tr><td>P2MR</td><td>No*</td><td>bc1z</td><td>bc1zzmv50jjgxxhww6ve4g5zpewrkjqhr06fyujpm20tuezdlxmfphcqfc80ve</td></tr>
</tbody></table>
<p>The following output types are fundamentally vulnerable to long exposure attacks:</p>
<ul>
<li>P2PK outputs (e.g. Satoshi's coins, CPU miners)</li>
<li>Reused outputs*</li>
<li>Taproot outputs (starts with bc1p)</li>
</ul>
<p><nowiki>*</nowiki> Funds in P2PKH, P2SH, P2WPKH, P2WSH, and P2MR outputs can become vulnerable to long exposure quantum attacks anytime their script reveals a public key.</p>
<p>Note: Extended public keys, commonly known as &quot;xpubs,&quot; and wallet descriptors also reveal quantum vulnerable public key information. For further clarification on quantum attack vectors, please refer to the <a href="#Glossary" target="_blank">Glossary of Terms</a>.</p>
<h2>Design</h2>
<p>Pay-to-Merkle-Root (P2MR) is a proposed new output type that commits to the root of a script tree. It operates with nearly the same functionality as P2TR (Pay-to-Taproot) outputs, but with the quantum vulnerable key path spend removed.</p>
<p>In other words, P2MR outputs commit to the Merkle root of a script tree without committing to an internal key. The script(s) being committed to, however, may contain a key or key-hash.</p>
<p>This output type is designed to offer users protection against long exposure quantum attacks as well as a practical output type with which post-quantum signatures may be used if such signatures are adopted in the future.</p>
<p>Since P2MR outputs have no key path spend, they omit the Taproot internal key. Instead, a P2MR output includes the 32-byte root of the script tree as defined in <a href="/341" target="_blank">BIP 341</a> hashed with the tag &quot;TapBranch&quot; as shown below.</p>
<img src="bip-0360/media/merkletree.png" />
<p>To construct a P2MR output, we follow the process outlined in <a href="/341" target="_blank">BIP 341</a> to compute the final tapbranch hash, which is the merkle root of the script leaves; however, instead of tweaking the internal key with the root of the Merkle tree (as is the case with P2TR outputs), P2MR outputs commit only to final tapbranch hash, which is tagged, &quot;TapBranch&quot;.</p>
<pre><code>D = tagged_hash(&quot;TapLeaf&quot;, bytes([leaf_version]) + ser_script(script))
CD = tagged_hash(&quot;TapBranch&quot;, C + D)
CDE = tagged_hash(&quot;TapBranch&quot;, CD + E)
ABCDE = tagged_hash(&quot;TapBranch&quot;, AB + CDE)
</code></pre>
<p>A P2MR input witness provides the following:</p>
<pre><code>initial stack element 0,
...,
initial stack element N,
leaf script,
control block = [control byte, 32*m byte Merkle path] # m is the depth of the script in the Merkle tree
</code></pre>
<p>The initial stack elements of P2MR follow the same rules as P2TR script path spends.
That is, they place elements on the stack to be evaluated by the leaf script.</p>
<p>The control block is a <em>1 + 32 * m</em> byte array, where the first byte is the control byte and the next <em>32 * m</em> bytes are the Merkle path to the leaf script. The control byte is the same as the control byte in a P2TR control block, including the 7 bits which are used to specify the leaf version. The parity bit of the control byte is always 1, since P2MR does not have a key path spend. Unlike P2TR, we omit the public key from the control block as it is not needed in P2MR. We maintain support for the optional annex in the witness (see Specification section below for more details).</p>
<h2>Rationale</h2>
<p>Design of the P2MR output type is guided by the following intentions:</p>
<ol>
<li>Minimize changes to the network. We should reuse existing Bitcoin code and preserve existing software behavior, workflows, user expectations and compatibility whenever possible.</li>
</ol>
<p>P2MR leverages the battle tested P2TR, tapleaf and tapscript code already in Bitcoin, reducing the implementation burden on wallets, exchanges, and libraries that can reuse code they already have. This approach reduces complexity and minimizes implementation risks.</p>
<ol start="2">
<li>Create the safest possible path for the addition of post-quantum signature integrations, in the event that they are used in the future.</li>
</ol>
<p>Importantly, we are proposing a script tree output, i.e. an output type that supports tapscript, that is resistant to long exposure attacks. While some existing output types are already resistant to long exposure attacks (e.g. P2WSH), no such output type supports tapscript — a feature that may be required for practical implementation of post-quantum signature opcodes.</p>
<p>P2WSH, for instance, does not support tapscript and as such does not support the OP_SUCCESSx opcode update path that will be critical for the integration of post-quantum OP_CHECKSIG opcodes into Bitcoin.<sup id="cite_ref_4"><a href="#cite_ref_4">4</a></sup></p>
<ol start="3">
<li>Facilitate gradual integration of quantum resistant features that can be carried out iteratively as quantum computers evolve. This approach encourages responsiveness to the current threat-level, while avoiding heavy-handedness in our reactions to a potential threat.</li>
</ol>
<p>We designed P2MR with an eye towards integrating post-quantum signatures in the future, without proposing more complex changes while CRQCs are still in their infancy.</p>
<h3>P2MR Trade-Offs</h3>
<p>While P2TR outputs (and the use of key path spend) will remain an option for folks wishing to use them, we aim to be clear about the tradeoffs of using P2MR outputs, which disable the key path spend for the benefit of quantum resistance.</p>
<p>The witness to a P2MR spend is always larger than the witness to a P2TR key path spend. This is because a P2TR key path spend requires only a Schnorr signature in the witness. For P2MR, the witness must include the chosen leaf script, the initial stack, and a control block consisting of the control byte and Merkle path (if any).</p>
<p>That said, the witness to a P2MR spend will always be smaller than the witness to an equivalent P2TR script path spend, because there is no longer any internal key in P2MR that must be revealed in the control block. For a more complete comparison of output type transaction sizes, the &quot;Transaction Size and Fees&quot; section may be reviewed later in this proposal.</p>
<p>Additionally, there is a privacy tradeoff when comparing P2MR and P2TR, which is that users reveal they are spending to a script tree whenever they are using P2MR outputs, since P2MR outputs can only be spent via script path spend. In P2TR when you spend an output as a key path spend, you don't reveal if you have any script path spends. This trade-off only exists when comparing P2TR key path spends to P2MR script path spends; P2TR and P2MR provide the same level of privacy when both are script path spends.</p>
<p><strong>Note:</strong> P2MR and P2TR both provide greater script privacy than P2SH <a href="/16" target="_blank">BIP 16</a> because unused script paths are not revealed.</p>
<h2>Specification</h2>
<p>We define the Pay-to-Merkle-Root (P2MR) output structure as follows:</p>
<p>A P2MR output is similar to a P2TR output (as defined in <a href="/341" target="_blank">BIP 341</a>); however, unlike P2TR outputs, we disable the key path spend for the benefit of quantum resistance by omitting the internal key and the tap tweak step.
A P2MR output is then a SegWit version 2 byte followed by the Merkle root of the script tree as the witness program.</p>
<h3>Address Format</h3>
<p>P2MR outputs use SegWit version 2, resulting in mainnet addresses that start with <code>bc1z</code>, following <a href="/173" target="_blank">BIP 173</a>. Bech32m encoding maps version 2 to the prefix <code>z</code>.</p>
<p>Example P2MR address:</p>
<pre><code>bc1zzmv50jjgxxhww6ve4g5zpewrkjqhr06fyujpm20tuezdlxmfphcqfc80ve
</code></pre>
<p>This commits to a 32-byte script tree Merkle root.</p>
<h3>ScriptPubKey</h3>
<p>The <code>scriptPubKey</code> for a P2MR output is:</p>
<pre><code>OP_2 OP_PUSHBYTES_32 &lt;hash&gt;
</code></pre>
<p>Where:</p>
<ul>
<li><code>OP_2</code> indicates SegWit version 2.</li>
<li><code>&lt;hash&gt;</code> is the 32-byte Merkle root of the script tree.</li>
</ul>
<h3>Script Validation</h3>
<p>A P2MR output is a native SegWit output (see <a href="/141" target="_blank">BIP 141</a>) with version 2 and a 32-byte witness program. For the sake of comparison, we have — as much as possible — copied the language verbatim from the script validation section of <a href="/341" target="_blank">BIP 341</a>.</p>
<ul>
<li>Let <em>q</em> be the 32-byte array containing the witness program (the second push in the scriptPubKey) which represents the Merkle root of the script tree.</li>
<li>Fail if the witness stack does not have two or more elements.</li>
<li>Fail if the witness stack has exactly two elements and the first byte of the last element is 0x50.</li>
<li>If there are at least three witness elements, and the first byte of the last element is 0x50, this last element is called <em>annex a</em> and is removed from the witness stack. The annex (or the lack thereof) is always covered by the signature and contributes to transaction weight, but is otherwise ignored during P2MR validation.</li>
<li>There must be at least two witness elements left.
<ul>
<li>Call the second-to-last stack element <em>s</em>, the script (as defined in <a href="/341" target="_blank">BIP 341</a>).</li>
<li>The last stack element is called the control block <em>c</em>, and must have length <em>1 + 32 * m</em>, for a value of <em>m</em> that is an integer between 0 and 128, inclusive. Fail if it does not have such a length.</li>
<li>Let <em>v = c[0] &amp; 0xfe</em> be the <em>leaf version</em> (as defined in <a href="/341" target="_blank">BIP 341</a>). To maintain <em>leaf version</em> encoding compatibility the last bit of c[0] is unused and must be 1.<sup id="cite_ref_5"><a href="#cite_ref_5">5</a></sup></li>
<li>Let <em>k<sub>0</sub> = hash<sub>TapLeaf</sub>(v || compact_size(size of s) || s)</em>; also call it the <em>tapleaf hash</em>.</li>
<li>For <em>j</em> in <em>[0,1,...,m-1]</em>:
<ul>
<li>Let <em>e<sub>j</sub> = c[1+32j:33+32j]</em>.</li>
<li>Let <em>k<sub>j+1</sub></em> depend on whether <em>k<sub>j</sub> &lt; e<sub>j</sub></em> (lexicographically):
*  If <em>k<sub>j</sub> &lt; e<sub>j</sub></em>: <em>k<sub>j+1</sub> = hash<sub>TapBranch</sub>(k<sub>j</sub> || e<sub>j</sub>)</em>.
*  If <em>k<sub>j</sub> ≥ e<sub>j</sub></em>: <em>k<sub>j+1</sub> = hash<sub>TapBranch</sub>(e<sub>j</sub> || k<sub>j</sub>)</em>.</li>
</ul>
</li>
<li>Let <em>r = k<sub>m</sub></em>.</li>
<li>If <em>q ≠ r</em>, fail.</li>
<li>Execute the script, according to the script rules specified in BIP 342, using the witness stack elements excluding the script <em>s</em>, the control block <em>c</em>, and the annex <em>a</em> if present, as initial stack. This implies that for the future leaf versions (non-<em>0xC0</em>) the execution must succeed.</li>
</ul>
</li>
</ul>
<p>The steps above follow the script path spend logic from <a href="/341" target="_blank">BIP 341</a> with the following changes:</p>
<ul>
<li>The witness program is the the Merkle root of the script tree and not a tweaked public key. This means that we skip directly to the BIP 341 script path validation.</li>
<li>We compute the script tree Merkle root <em>r</em> and compare it directly to the witness program <em>q</em>.</li>
<li>The control block is <em>1 + 32*m</em> bytes, instead of <em>33 + 32*m</em> bytes.</li>
</ul>
<h3>Common Signature Message Construction</h3>
<p>The <a href="https://learnmeabitcoin.com/technical/upgrades/taproot/#common-signature-message" target="_blank">common signature message</a> construction for P2MR outputs is exactly the same procedure as defined in <a href="/342" target="_blank">BIP342 Common Signature Message</a>.</p>
<h3> Compatibility with BIP 141 </h3>
<p>By adhering to the SegWit transaction structure and versioning, P2MR outputs are compatible with existing transaction processing rules. Nodes that do not recognize SegWit version 2 will treat these outputs as anyone-can-spend but generally will not relay or mine such transactions.</p>
<h3>Transaction Size and Fees</h3>
<p>All P2MR and P2TR outputs are always the same size. P2MR inputs can be slightly larger or smaller than their equivalent P2TR inputs, depending on the use of key path vs script path spend in the case of P2TR. Let's consider the cases.</p>
<h4>Comparison with P2TR key path spend</h4>
<p>A P2MR witness will be larger than a P2TR witness when the P2TR output is spent via the key path spend. A witness to a P2TR key path spend is simply a signature. P2MR quantum resistance comes from removing the P2TR key path spend. Every P2MR spend is a P2TR script path spend and so requires a script, its input stack and a control block. Consequently, P2MR loses this size advantage of P2TR key path spends in order to gain quantum resistance. If the script tree only has a single leaf script, no Merkle path is needed in the control block, giving us a minimal size control block of 1 byte.</p>
<p>P2MR witness for depth-0 tree (103 bytes):</p>
<pre><code>[count] (1 byte), # Number of elements in the witness
[size] signature (1 + 64 bytes = 65 bytes),
leaf script = [size] [OP_PUSHBYTES_32, 32-byte public key, OP_CHECKSIG] (1 + 1 + 32 + 1 bytes = 35 bytes),
control block = [size] [control byte] [merkle path (empty)] (1 + 1 + 0 bytes = 2 bytes)
</code></pre>
<p>P2TR key path spend witness (66 bytes):</p>
<pre><code>[count] (1 byte), # Number of elements in the witness
[size] signature (1 + 64 bytes = 65 bytes)
</code></pre>
<p>Thus, the P2MR witness would be 103 - 66 = 37 bytes larger than a P2TR key path spend witness.</p>
<p>If the Merkle tree has more than a single leaf, then the Merkle path must be included in the control block, increasing the size by <em>32 * m</em> bytes, where m is the depth of the Merkle tree.
While script trees do support leaf scripts of different depths, here we assume the Merkle tree has been constructed such that each leaf is at the same depth.
This would make such witness 37 + 32 * m bytes larger than a P2TR key path spend witness.<sup id="cite_ref_6"><a href="#cite_ref_6">6</a></sup></p>
<p>P2MR witness <em>(103 + 32*m bytes)</em>:</p>
<pre><code>[count] (1 byte), # Number of elements in the witness
[size] signature (64 + 1 bytes = 65 bytes),
leaf script = [size] [OP_PUSHBYTES_32, 32-byte public key, OP_CHECKSIG] (34 + 1 bytes = 35 bytes),
control block = [size] [control byte] [Merkle path] (1 + 1 + 32*m = 2 + 32*m bytes)
</code></pre>
<h4>Comparison with P2TR script path spend</h4>
<p>A P2MR witness will be smaller than the witness to an equivalent P2TR script path spend. This is because P2MR does not require inclusion of an internal public key in the control block to unlock and spend an output. For this reason, a P2MR witness will always be 32 bytes smaller than an equivalent P2TR script path spend witness.</p>
<h2>Performance Impact</h2>
<p>P2MR is slightly more computationally performant than P2TR script path spends, as the operations to spend a P2MR output is a strict subset of the operations needed to perform a script path spend on a P2TR output.</p>
<h2>Backward Compatibility</h2>
<p>Older wallets and nodes that have not been made compatible with SegWit version 2 and P2MR will not understand these outputs. Per <a href="/350" target="_blank">BIP 350</a> older wallets should be able to spend funds to SegWit version 2 outputs. Users should ensure they are using updated wallets and nodes to receive P2MR outputs and validate transactions using P2MR outputs. P2MR is fully compatible with tapscript and existing tapscript programs can be used in P2MR outputs without modification. P2MR can also support future scripts with new leaf versions.</p>
<h2>Security</h2>
<p>P2MR outputs provide the same tapscript functionality as P2TR outputs, but with the quantum-vulnerable key path spend removed. The similarity between these output types enables users to easily migrate script trees from P2TR outputs to P2MR outputs for protection against long exposure quantum attacks. Wallets supporting only P2TR key path spends would need to migrate to using script trees. This is a straightforward migration as it only requires moving to a simple OP_CHECKSIG leaf script.</p>
<p>Protection from long exposure quantum attacks does not depend on the activation of post-quantum signatures in Bitcoin, but requires that users do not expose their public keys to attackers via public key reuse or other unsafe practices.</p>
<p>P2MR uses a 256-bit hash output, providing 128 bits of collision resistance and 256 bits of preimage resistance. This is the same level of security as P2WSH specified in <a href="/141" target="_blank">BIP 141</a>, which also uses a 256-bit hash output.</p>
<p>P2MR does not, by itself, protect against short exposure quantum attacks, but these attacks can be mitigated by future activation of post-quantum signatures.</p>
<p>Combined with P2MR, post-quantum signature schemes can provide comprehensive quantum resistance to P2MR outputs, including protection from short exposure attacks.</p>
<p>That said, protection against long exposure quantum attacks alone should not be underestimated. It's unlikely that early CRQCs will be fast enough to perform short exposure attacks, making preparedness against long exposure attacks more time-critical.</p>
<h2>Security Considerations for Post-Quantum Signature Schemes</h2>
<p>While this proposal does not include the introduction of post-quantum signature schemes, we think it's worth commenting on security considerations related to this possibility.</p>
<p>Quantum-resistant signature algorithms (e.g. ML-DSA or SLH-DSA) offer different levels of protection and should be scrutinized before use. We are currently researching options for the potential proposal of post-quantum signatures into Bitcoin and encourage others to engage in this research as well.</p>
<p>We also imagine the possibility of introducing multiple post-quantum signatures for redundancy. Balancing the risks of additional complexity with the benefits of signature-type redundancy will be the challenge here.</p>
<h2>Test Vectors and Reference Code</h2>
<p>Test vector data for creation of P2MR UTXOs can be found <a href="https://github.com/bitcoin/bips/blob/master/bip-0360/ref-impl/common/tests/data/P2MR_construction.json" target="_blank">here</a>.</p>
<p>These test vectors build off of the test vectors for <a href="/341" target="_blank">BIP 341</a> (Taproot). One important distinction is that the P2MR test vectors do not include keypath spend scenarios.</p>
<p>Also included are test vectors in <a href="https://github.com/bitcoin/bips/tree/master/bip-0360/ref-impl/rust" target="_blank">rust implementation</a> and <a href="https://github.com/bitcoin/bips/tree/master/bip-0360/ref-impl/python" target="_blank">python implementation</a>. One of these tests demonstrates a tapscript that requires a secp256k1 signature to spend the P2MR UTXO (modeled after one of the extremely valuable examples provided by <a href="https://learnmeabitcoin.com/technical/upgrades/taproot/#example-3-script-path-spend-signature" target="_blank">this Taproot script path spend example</a>. Similar to BIP 341 test vectors, all signatures are created with an all-zero (0x0000...0000) <a href="/340" target="_blank">BIP 340</a> auxiliary randomness array.</p>
<h2>Related Work</h2>
<p>Below we attempt to summarize some of the ideas discussed on the Bitcoin Development Mailing List that relate to P2MR.</p>
<p>The idea of Taproot with key path spend removed has been discussed a number of times in the Bitcoin community.</p>
<p>For instance, <a href="https://gnusha.org/pi/bitcoindev/CAD5xwhgzR8e5r1e4H-5EH2mSsE1V39dd06+TgYniFnXFSBqLxw@mail.gmail.com/" target="_blank">OP_CAT Makes Bitcoin Quantum Secure</a> notes that if we disable the key path spend in Taproot and activate OP_CAT <a href="/347" target="_blank">BIP 347</a>, we could achieve quantum resistance by using Lamport signatures with OP_CAT.</p>
<p>Lamport and WOTS (Winternitz One-Time Signatures) built from CAT are quantum resistant, but are one-time signatures — meaning, if you sign twice for the same public key, you risk leaking your private key, which is a significant security concern for everyday users.</p>
<p>This would require major changes to wallet behavior and would represent a significant security downgrade. Common practices, such as RBF and CPFP, could risk revealing private keys if no stateless signature scheme is used.</p>
<p><a href="https://groups.google.com/g/bitcoindev/c/8O857bRSVV8/m/rTrpeFjWDAAJ" target="_blank">Trivial QC signatures with clean upgrade path</a> and <a href="https://groups.google.com/g/bitcoindev/c/oQKezDOc4us/m/T1vSMkZNAAAJ" target="_blank">Re: P2QRH / BIP 360 Update</a> also discuss the possibility of Taproot with key path spend removed. The design of P2MR was partly inspired by these discussions.</p>
<p>Commit-reveal schemes such as <a href="https://gnusha.org/pi/bitcoindev/1518710367.3550.111.camel@mmci.uni-saarland.de/" target="_blank">Re: Transition to post-quantum (2018)</a> and <a href="https://groups.google.com/g/bitcoindev/c/LpWOcXMcvk8/m/YEiH-kTHAwAJ" target="_blank">Post-Quantum commit / reveal Fawkescoin variant as a soft fork (2025)</a> have been proposed as a way to create cryptocurrencies without public key cryptography. The ideas in this paper were more recently expanded upon by Tadge Dryja in his &quot;<a href="https://www.youtube.com/watch?v=4bzOwYPf1yo" target="_blank">Lifeboat</a>&quot; proposal, which effectively quantum-proofs Bitcoin transactions through a similar pre-commitment scheme designed for Bitcoin.</p>
<h2>Other Methods of Addressing Quantum Vulnerabilities for Cryptocurrencies</h2>
<p>It is worth noting, by way of comparison, that <a href="https://ethresear.ch/t/how-to-hard-fork-to-save-most-users-funds-in-a-quantum-emergency/18901" target="_blank">Vitalik Buterin's proposed solution</a> to Ethereum's quantum vulnerability is quite different from the approach in this BIP.</p>
<p>His plan involves a hard fork of the chain, reverting all blocks after some sufficient amount of theft, and using STARKs based on BIP 32 seeds to act as the authoritative secret when signing. We believe rollbacks of any kind are an untenable approach for Bitcoin and would likely be impractical to implement.</p>
<p>That said, we believe the use of STARKs (which are quantum-resistant) may prove useful as a method of proving access to external private keys, in the event that the community chooses to burn vulnerable coins as proposed by Jameson Lopp and others in <a href="https://qbip.org/" target="_blank">QBIP</a>.</p>
<p>Discussions related to the burning of coins, and other attempts to slow a potential supply shock caused by quantum-retrieval of vulnerable coins, are out of scope for this proposal. That said, members of our team have separately proposed <a href="https://github.com/cryptoquick/bips/blob/hourglass/bip-hourglass.mediawiki" target="_blank">Hourglass</a> to address this concern and are continuing research on this subject.</p>
<h2>Conclusion</h2>
<p>In this proposal, we adopt a &quot;prepared not scared&quot; approach to the possible advancement of quantum computing and offer Bitcoin users an option for increased protection if they so choose. This BIP does not take a position on any specific quantum computing timeline, but rather proposes a flexible and unobtrusive option for users that wish to mitigate this risk according to their own estimate of the timeline.</p>
<p>This is an issue that has been discussed with some regularity in <a href="https://bitcointalk.org/index.php?topic=133425.0" target="_blank">Bitcoin forums</a> since at least 2012, and there is clearly user demand for increased quantum protection.</p>
<h2>Glossary</h2>
<p><strong>Quantum Key Recovery</strong></p>
<p>The derivation of private keys from public keys in elliptic curve cryptography (ECC), made possible by solving the discrete logarithm problem (DLP).</p>
<p>Shor's algorithm, developed by Peter Shor in 1994, is a quantum algorithm that efficiently solves the discrete logarithm problem — potentially made possible by the future viability of cryptographically relevant quantum computers (CRQCs).</p>
<p><strong>Long Exposure Attacks</strong></p>
<p>Attempts to derive private keys from public keys that are exposed for an extended period of time; that is, longer than the window of time that a public key is generally exposed in the mempool while waiting to be confirmed.</p>
<p>Long exposure attacks give attackers an unlimited amount of time to perform quantum key recovery, as long as funds remain in the output. Poor wallet hygiene (e.g. from address reuse) or use of outputs with exposed public keys (e.g. P2TR outputs) increases vulnerability to long exposure attacks.</p>
<p><strong>Short Exposure Attacks</strong></p>
<p>Attempts to derive private keys from public keys during the brief period when funds are unconfirmed in the mempool. These attacks cannot be prevented through wallet hygiene, as revealing a public key is necessary for spending.</p>
<p>Protection against short exposure attacks may require post-quantum signature schemes; that said, executing these attacks requires faster CRQCs than those capable of executing long exposure attacks and are therefore viewed as lower-risk than long exposure attacks in the nearer term.</p>
<p><span id="script-tree-output-type"></span>
<strong>Script Tree Output Type</strong></p>
<p>Script tree output types are a category of output type that support a script tree consisting of leaf scripts. Script tree output types support tapscript and would support any new script language added to bitcoin which is able to be used as a leaf script in a script trees. If Pay-to-Merkle-Root (P2MR) is activated, P2MR would be the second script tree output type in Bitcoin, the other being Pay-to-Taproot (P2TR).</p>
<p><strong>Pay-to-Merkle-Root (P2MR)</strong></p>
<p>A script tree output type, similar to to Pay-to-Taproot (P2TR), but with the quantum-vulnerable key path spend removed.</p>
<h2>Footnotes</h2>
<ol>
<li><a href="https://bips.dev/360/#cite_ref_1">^</a> A Cryptographically Relevant Quantum Computer is an <em>object</em> which is only loosely defined by <em>characteristics</em> in quantum physics as of today. It could be understood in the context of this BIP and in Bitcoin that it's a <em>hardware-agnostic</em> computer supposed to have the architecture to keep <em>coherent</em> a sufficient number of logical qubits to be able to run Shor's algorithm in an efficient fashion.</li>
<li><a href="https://bips.dev/360/#cite_ref_2">^</a> Shor's algorithm is believed to need 10^8 operations to break a 256-bit elliptic curve public key.</li>
<li><a href="https://bips.dev/360/#cite_ref_3">^</a> Meaning, deriving private keys from public keys via Shor's algorithm</li>
<li><a href="https://bips.dev/360/#cite_ref_4">^</a> <code>OP_SUCCESSx</code> is a mechanism to upgrade tapscript</li>
<li><a href="https://bips.dev/360/#cite_ref_5">^</a> Why set the last bit of c[0] to one? Consider a faulty implementation that deserializes the <em>leaf version</em> as c[0] rather than c[0] &amp; 0xfe for both P2TR and P2MR. If they test against P2MR outputs and require that last bit is 1, this deserialization bug will cause an immediate error.</li>
<li><a href="https://bips.dev/360/#cite_ref_6">^</a> If <em>m &gt;= 8</em>, then the compact size will use 3 bytes rather than 1 byte</li>
</ol>
<h2>Changelog</h2>
<p>To help implementers understand updates to this BIP, we keep a list of substantial changes.</p>
<ul>
<li><strong>0.11.0</strong>  (2026-02-10) - Rename BIP from Pay-to-Tapscript-Hash (P2TSH) to Pay-to-Merkle-Root (P2MR)</li>
<li><strong>0.10.3</strong>  (2026-02-06) - Rename tapscript-native output type to script tree output type.</li>
<li><strong>0.10.2</strong>  (2026-01-23) - Fix bug in verification, minor review comments and adopt <a href="/3" target="_blank">BIP 003</a> conventions.</li>
<li><strong>0.10.1</strong>  (2026-01-21) - Terminology and clarity improvements, addressed feedback from reviews.</li>
<li><strong>0.10.0</strong>  (2025-09-17) - Rewrote BIP for clarity and renamed from P2QRH to P2TSH</li>
<li><strong>0.9.0</strong>  (2025-07-20) - Changed the Witness Version from 3 to 2.</li>
<li><strong>0.8.0</strong> (2025-07-07) - P2QRH is now a P2TR with the vulnerable key path spend removed. Number of PQ signature algorithms supported reduced from three to two. PQ signature algorithm support is now added via opcodes or leaf version.</li>
<li><strong>0.7.0</strong> (2025-03-18) - Correct inconsistencies in commitment and attestation structure. Switch from Merkle tree commitment to sorted vector hash commitment. Update descriptor format.</li>
<li><strong>0.6.2</strong> (2025-03-12) - Add verification times for each algorithm. 256 to 128 (NIST V to NIST I). Add key type bitmask. Clarify multisig semantics.</li>
<li><strong>0.6.1</strong> (2025-02-23) - More points of clarification from review. Update dead link.</li>
<li><strong>0.6.0</strong> (2025-01-20) - Remove SQIsign from consideration due to significant performance concerns. Refactor language from long range attack to long exposure so as to not be confused with the language around block re-org attacks.</li>
<li><strong>0.5.1</strong> (2024-12-18) - Assigned BIP number.</li>
<li><strong>0.5.0</strong> (2024-12-13) - Update to use Merkle tree for attestation commitment. Update LR &amp; SR quantum attack scenarios.</li>
<li><strong>0.4.0</strong> (2024-12-01) - Add details on attestation structure and parsing.</li>
<li><strong>0.3.0</strong> (2024-10-21) - Replace XMSS with CRYSTALS-Dilithium due to NIST approval and size constraints.</li>
<li><strong>0.2.2</strong> (2024-09-30) - Refactor the ECC vs PoW section. Swap quitness for attestation.</li>
<li><strong>0.2.1</strong> (2024-09-29) - Update section on PoW to include partial-preimage.</li>
<li><strong>0.2.0</strong> (2024-09-28) - Add Winternitz, XMSS signatures, and security assumption types to PQC table. Omit NIST Level I table. Add spend script specification. Add revealed public key scenario table.</li>
<li><strong>0.1.0</strong> (2024-09-27) - Initial draft proposal</li>
</ul>
<h2>Acknowledgements</h2>
<p>This document is inspired by <a href="/341" target="_blank">BIP 341</a>, which introduced the design of the P2TR (Taproot) output type using Schnorr signatures.</p>
<p>I'm incredibly grateful to Ethan Heilman for joining as co-author and transforming this BIP into something far more congruent with existing Bitcoin design. Additionally, much gratitude to our most recent co-author, Isabel Foxen Duke, for her thoughtful editing and crafting much of the language in this proposal. I am likewise indebted to those on the Anduro Quantum Working Group who took the time to contribute including Jeff Bride, Michael Casey, and notmike.</p>
<p>Thank you as well to those who took the time to review and contribute, including Jon Atack, Adam Borcany, Ava Chow, Kyle Crews, Pierre-Luc Dallaire-Demers, D++, Mark Erhardt, Jameson Lopp, Antoine Riard, Armin Sabouri, Vojtěch Strnad, Guy Swann, and Joey Yandle.</p>
<p>Whatever inaccuracies may remain are attributable solely to the authors.</p>

        </article>
    </div>


            <hr class="border-slate-700" />

            <div data-pagefind-ignore class="w-full flex flex-col items-center space-y-2 text-center">
                <div class="flex items-center space-x-2">
                    <p class="font-bold">Updated</p>
                    <p class="font-bold">2026-02-12</p>
                </div>
                <p>See an issue with rendering or formatting? Submit an issue on <a href="https://github.com/nickmonad/bips.dev" target="_blank">GitHub</a></p>
                <p>Do you find this site useful? Please consider <a href="https://buy.tryspeed.com/plink_live_lyek4a2yW2Sn2wfA" target="_blank">donating</a> some sats to support ongoing development.</p>
                <p><a href="/">bips.dev</a> is presented by <a href="https://nickmonad.blog" target="_blank">nickmonad</a></p>
                <p class="pt-4 text-sm">All content is owned and licensed by the respective author(s). This website makes no claim of ownership.</p>
            </div>
        </div>
    </div>
</body>
</html>
