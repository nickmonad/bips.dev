<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Read BIPs like a pro." />
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="og:title" content="BIP 324: Version 2 P2P Encrypted Transport Protocol" />
    <meta property="og:description" content="Read BIPs like a pro." />
    <meta property="og:image" content="https://bips.dev/og-bips-dev.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="BIP 324: Version 2 P2P Encrypted Transport Protocol" />
    <meta name="twitter:description" content="Read BIPs like a pro." />
    <meta name="twitter:creator" content="@nickmonad" />
    <meta name="twitter:image" content="https://bips.dev/og-bips-dev.png" />

    <title>BIP 324: Version 2 P2P Encrypted Transport Protocol</title>

    
        <link rel="stylesheet" href="/style.css" />
    

    <link rel="stylesheet" href="/pagefind/pagefind-ui.css" />
    <script src="/pagefind/pagefind-ui.js"></script>

    <script defer data-domain="bips.dev" src="/js/script.js"></script>
    <script>
        // setup plausible function for custom events
        window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }

        // setup and initialize dark mode
        // https://tailwindcss.com/docs/dark-mode
        window.setTheme = function() {
            if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark')
            } else {
                document.documentElement.classList.remove('dark')
            }
        }
        window.setTheme();

        // searching via
        // https://pagefind.app
        window.addEventListener('DOMContentLoaded', function(event) {
            new PagefindUI({
                element: "#search",
                hightlightParam: "highlight",
                showImages: false,
                showSubResults: true,
                translations: {
                    placeholder: "Search BIPs"
                },
                processTerm: function(term) {
                    plausible('Search');
                    return term;
                }
            });
        });
    </script>

    <style>
        /* variables to override on pagefind */
        /* https://pagefind.app/docs/ui-usage/#customising-the-styles */
        /* values are from tailwind: https://tailwindcss.com/docs/customizing-colors */
        :root {
            --pagefind-ui-primary: #334155;
            --pagefind-ui-text: #334155;
            --pagefind-ui-background: #ffffff;
            --pagefind-ui-border-width: 1px;
            --pagefind-ui-border-radius: 4px;
        }

        html.dark {
            --pagefind-ui-primary: #d1d5db;
            --pagefind-ui-text: #d1d5db;
            --pagefind-ui-background: #18181b;
            --pagefind-ui-border: #152028;
        }

        mark {
            background-color: #ff9900 !important;
            color: #6b7280 !important;
        }
    </style>
</head>

<body class="bg-white dark:bg-zinc-900">
    <div class="container mx-auto flex justify-center">
        <div data-pagefind-body class="min-w-full max-w-full lg:min-w-[1000px] lg:max-w-[1000px] px-6 py-10 space-y-10 text-slate-700 dark:text-gray-300">
            
    <div class="flex flex-col space-y-4 pt-4 md:pt-8">
        <div class="flex justify-between">
            <a href="/">Back to BIPs</a>
            <div class="flex">
                <svg id="toggleDark_light" class="hidden dark:flex w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'light'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
                </svg>
                <svg id="toggleDark_dark" class="flex dark:hidden w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'dark'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
                </svg>
            </div>
        </div>
        <div class="flex flex-col space-y-2">
            <div data-pagefind-weight="10" class="text-2xl font-extrabold">BIP 324: Version 2 P2P Encrypted Transport Protocol</div>
            <div class="flex justify-between">
                <div class="text-xl font-semibold">2019-03-08</div>
                <a href="https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;blob&#x2F;master&#x2F;bip-0324.mediawiki" target="_blank">View on GitHub</a>
            </div>
        </div>

        <article class="max-w-none prose prose-lg prose-zinc prose-p:leading-relaxed prose-a:font-bold prose-a:underline prose-a:decoration-2 prose-a:decoration-bitcoin prose-pre:bg-zinc-200 prose-pre:text-zinc-800 dark:prose-invert dark:prose-pre:bg-zinc-600 dark:prose-pre:text-white">
            <pre><code>  BIP: 324
  Layer: Peer Services
  Title: Version 2 P2P Encrypted Transport Protocol
  Author: Dhruv Mehta &lt;dhruv@bip324.com&gt;
          Tim Ruffing &lt;crypto@timruffing.de&gt;
          Jonas Schnelli &lt;dev@jonasschnelli.ch&gt;
          Pieter Wuille &lt;bitcoin-dev@wuille.net&gt;
  Comments-URI: https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;wiki&#x2F;Comments:BIP-0324
  Status: Final
  Type: Standards Track
  Created: 2019-03-08
  License: BSD-3-Clause
  Replaces: 151
</code></pre>
<h2> Introduction </h2>
<h3> Abstract </h3>
<p>This document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.</p>
<h3> Copyright </h3>
<p>This document is licensed under the 3-clause BSD license.</p>
<h3> Motivation </h3>
<p>Bitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:</p>
<ul>
<li>While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.</li>
<li>Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.</li>
<li>The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.</li>
</ul>
<p>This proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.</p>
<ul>
<li>Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in the case of manual, deliberate connections (as opposed to automatic, random ones), they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.</li>
<li>Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.</li>
<li>A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.</li>
</ul>
<p>** Why encrypt without authentication?**</p>
<p>As we have argued above, unauthenticated encryption<ref name="what_does_auth_mean"><strong>What does <em>authentication</em> mean in this context?</strong> Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:</p>
<ul>
<li>The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.</li>
<li>The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some public key mechanism. The proposal in this document does <strong>not</strong> include such a mechanism.</ref> provides strictly better security than no encryption. Thus, all connections should use encryption, even if they are unauthenticated.</li>
</ul>
<p>When it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see <a href="https://github.com/sipa/writeups/tree/main/private-authentication-protocols" target="_blank">Private authentication protocols</a>).</p>
<p>** Why have a pseudorandom bytestream when traffic analysis is still possible? **</p>
<p>Traffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.</p>
<p>A pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., <a href="https://gitlab.com/yawning/obfs4" target="_blank">obfs4</a> and a recently proposed <a href="https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/" target="_blank">cTLS extension</a>). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.</p>
<p>** Why not use a secure tunnel protocol? **</p>
<p>Our goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, and the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN protocols, these are not desirable or applicable for automatic connections at scale:</p>
<ul>
<li>Proxy networks like Tor or I2P introduce a separate address space, independent of network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name="pure_tor_attack"><strong>Why is it a bad idea to have nodes exclusively connected over Tor?</strong> See the <a href="https://arxiv.org/abs/1410.6079" target="_blank">Bitcoin over Tor isn't a Good Idea</a> paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.</li>
<li>VPN protocols like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.</li>
</ul>
<p>Thus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled – on top of any network layer rather than be part of the network layer.</p>
<p>** Why not use a general-purpose transport encryption protocol? **</p>
<p>While it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.</p>
<p>The primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at the core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.</p>
<p>In contrast, our proposal instead aims for a simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a <em>session ID</em> that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called <em>channel binding</em> because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside the Diffie-Hellman key exchange.<ref name="channel_binding_noise_tls"><strong>Do other protocols not support exporting a session ID?</strong> While <a href="https://noiseprotocol.org/noise.html#channel-binding" target="_blank">Noise</a> and <a href="https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/" target="_blank">TLS (as a draft)</a> offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, <a href="https://www.dsn.kastel.kit.edu/bitcoin/" target="_blank">which typically live for hours or even weeks</a>.</p>
<p>Besides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:</p>
<ul>
<li>Neither offers a pseudorandom bytestream.</li>
<li>Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.</li>
<li>Neither offers shapability of the bytestream.</li>
<li>Both provide a stream-based interface to the application layer, whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.</li>
</ul>
<p>While existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.</p>
<h2> Goals </h2>
<p>This proposal aims to achieve the following properties:</p>
<ul>
<li>Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.</li>
<li>Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.</li>
<li>Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.</li>
<li>Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name="shapable_hs_tor_circumvention"><strong>How can shapability help circumvent fragmentation-pattern based censoring?</strong> See <a href="https://gitlab.torproject.org/legacy/trac/-/issues/20348" target="_blank">note_2229522 this Tor issue</a> as an example.</ref></li>
<li>Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.</li>
<li>Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.</li>
<li>Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.</li>
<li>Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.</li>
</ul>
<h2> Specification </h2>
<p>The specification consists of three parts:</p>
<ul>
<li>The <strong>Transport layer</strong> concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.</li>
<li>The <strong>Application layer</strong> concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.</li>
<li>The <strong>Signaling</strong> concerns how v2 nodes advertise their support for the v2 protocol to potential peers.</li>
</ul>
<h3> Transport layer specification </h3>
<p>In this section, we define the encryption protocol for messages between peers.</p>
<h4> Overview and design </h4>
<p>We first give an informal overview of the entire protocol flow and packet encryption.</p>
<p><strong>Protocol flow overview</strong></p>
<p>Given a newly established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the <strong>initiator</strong> (who established the connection) and the <strong>responder</strong> (who accepted the connection).</p>
<ol>
<li>The <strong>Key exchange phase</strong>, where nodes exchange data to establish shared secrets.
<ul>
<li>The initiator:</li>
<li>
<ul>
<li>Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name="ellswift_paper"><strong>What is ElligatorSwift and why use it?</strong> The <a href="https://eprint.iacr.org/2022/759.pdf" target="_blank">SwiftEC paper</a> describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name="ellswift_perf"><strong>How fast is ElligatorSwift?</strong> Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.</li>
</ul>
</li>
<li>
<ul>
<li>May send up to 4095<ref name="why_4095_garbage"><strong>How was the limit of 4095 bytes garbage chosen?</strong> It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called <strong>garbage</strong>, providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name="why_garbage"><strong>Why does the affordance for garbage exist in the protocol?</strong> The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref></li>
</ul>
</li>
<li>The responder:</li>
<li>
<ul>
<li>Waits until one byte is received which does not match the 16 bytes consisting of the network magic followed by &quot;version\x00\x00\x00\x00\x00&quot;. If the first 16 bytes do match, the connection is treated as using the v1 protocol instead.<ref name="why_no_prefix_check"><strong>What if a v2 initiator's public key starts accidentally with these 16 bytes?</strong> This is so unlikely (probability of <em>2<sup>-128</sup></em>) to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it. The optional detection of wrong-network v1 peers has a probability of <em>2<sup>-96</sup></em>, which is still negligible compared to random network failures.</ref><ref>Bitcoin Core versions &lt;=0.4.0 and &gt;=22.0 ignore valid P2P messages that are received prior to a VERSION message. Bitcoin Core versions between 0.4.0 and 22.0 assign a misbehavior score to the peer upon receiving such messages. v2 clients implementing this proposal will interpret any message other than VERSION received as the first message to be the initiation of a v2 connection, and will result in disconnection for v1 initiators that send any message type other than VERSION as the first message. We are not aware of any implementations where this could pose a problem.</ref></li>
</ul>
</li>
<li>
<ul>
<li>If the first 4 received bytes do not match the network magic, but the 12 bytes after that do match the version message encoding above, implementations may interpret this as a v1 peer of a different network, and disconnect them.</li>
</ul>
</li>
<li>
<ul>
<li>Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.</li>
</ul>
</li>
<li>
<ul>
<li>Similarly may send up to 4095 bytes of garbage data after their public key.</li>
</ul>
</li>
<li>Both parties:</li>
<li>
<ul>
<li>Receive (the remainder of) the full 64-byte public key from the other side.</li>
</ul>
</li>
<li>
<ul>
<li>Use X-only<ref name="xonly_ecdh"><strong>Why use X-only ECDH?</strong> Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name="why_ecdh_pubkeys"><strong>Why is the shared secret computation a function of the exact 64-byte public encodings sent?</strong> This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 <strong>encryption keys</strong> (two in each direction: one for packet lengths, one for content encryption), a <strong>session id</strong>, and two 16-byte <strong>garbage terminators</strong><ref><strong>What length is sufficient for garbage terminators?</strong> The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadvertently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref><strong>What does a garbage terminator in the wild look like?</strong> <div><img src="bip-0324/garbage_terminator.png" /></div></li>
</ul>
</li>
</ul>
</li>
</ol>
<p></ref> (one in each direction) using HKDF-SHA256.
* * Send their 16-byte garbage terminator.<ref name="why_garbage_term"><strong>Why does the protocol need a garbage terminator?</strong> While it is in principle possible to use the first packet after the garbage directly as a terminator (scan until a valid packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref>
* * Receive up to 4111 bytes, stopping when encountering the garbage terminator.
*  At this point, both parties have the same keys, and all further communication proceeds in the form of <strong>encrypted packets</strong>.
* * Encrypted packets have an <strong>ignore bit</strong>, which makes them <strong>decoy packets</strong> if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point from here on. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.
* * For each of the two directions, the first encrypted packet that will be sent in that direction (regardless of it being a decoy packet or not) will make use of the associated authenticated data (AAD) feature of the AEAD to authenticate the garbage that has been sent in that direction.<ref name="why_garbage_auth"><strong>Why does the protocol authenticate the garbage?</strong> Without garbage authentication, the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref></p>
<ol>
<li>The <strong>Version negotiation phase</strong>, where parties negotiate what transport version they will use, as well as data defined by that version.<ref name="example_versions"><strong>What features could be added in future protocol versions?</strong> Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>
<ul>
<li>The responder:</li>
<li>
<ul>
<li>Sends a <strong>version packet</strong> with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.</li>
</ul>
</li>
<li>The initiator:</li>
<li>
<ul>
<li>Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name="version_negotiation"><strong>How will future versions encode version numbers in the version packet?</strong> Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a &quot;v2.N&quot; protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref></li>
</ul>
</li>
<li>
<ul>
<li>Sends a <strong>version packet</strong> with empty content as well, to indicate support for the v2 P2P protocol.</li>
</ul>
</li>
<li>The responder:</li>
<li>
<ul>
<li>Receives a packet, ignores its contents.</li>
</ul>
</li>
</ul>
</li>
<li>The <strong>Application phase</strong>, where the packets exchanged have contents to be interpreted as application data.
<ul>
<li>Whenever either peer has a message to send, it sends a packet with that application message as <strong>contents</strong>.</li>
</ul>
</li>
</ol>
<p>To avoid the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name="handshake_progress"><strong>How can progress be guaranteed in a backwards-compatible way?</strong> In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:</p>
<ul>
<li>The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 16 bytes prefix.</li>
<li>The responder must start sending after having received at least one byte that mismatches that 16-byte prefix.</li>
<li>As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)</li>
<li>Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.</li>
<li>After either party has sent their garbage terminator, they must transition to the version negotiation phase without waiting for more bytes.</li>
</ul>
<p>Since the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref></p>
<p>Note that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage terminator. So the first two phases together, jointly called <strong>the handshake</strong>, comprise just 1.5 roundtrips:</p>
<ul>
<li>the initiator sends public key + garbage</li>
<li>the responder sends public key + garbage + garbage terminator + decoy packets (optional) + version packet</li>
<li>the initiator sends garbage terminator + decoy packets (optional) + version packet</li>
</ul>
<p><strong>Packet encryption overview</strong></p>
<p>All data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the <strong>contents</strong>, as well as an <strong>ignore bit</strong> as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.</p>
<p>Each packet consists of:</p>
<ul>
<li>A 3-byte encrypted <strong>length</strong> field, encoding the length of the <strong>contents</strong> (between <em>0</em> and <em>2<sup>24</sup>-1</em><ref name="max_packet_length"><strong>Is <em>2<sup>24</sup>-1</em> bytes sufficient as maximum content size?</strong> The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to <em>2<sup>24</sup>-1</em> we can accommodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).</li>
<li>An authenticated encryption of the <strong>plaintext</strong>, which consists of:
<ul>
<li>A 1-byte <strong>header</strong> which consists of transport layer protocol flags. Currently, only the highest bit is defined as the <strong>ignore bit</strong>. The other bits are ignored, but this may change in future versions<sup id="cite_ref_1"><a href="#cite_ref_1">1</a></sup>.</li>
<li>The variable-length <strong>contents</strong>.</li>
</ul>
</li>
</ul>
<p>The encryption of the plaintext uses <strong><a href="https://en.wikipedia.org/wiki/ChaCha20-Poly1305" target="_blank">ChaCha20Poly1305</a></strong><ref name="why_chacha20"><strong>Why is ChaCha20Poly1305 chosen as the basis for packet encryption?</strong> It is a very widely used authenticated encryption cipher (used among others in SSH, TLS 1.2, TLS 1.3, <a href="https://en.wikipedia.org/wiki/QUIC" target="_blank">QUIC</a>, Noise, and <a href="https://www.wireguard.com/protocol/" target="_blank">WireGuard</a>; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the <a href="https://competitions.cr.yp.to/caesar.html" target="_blank">CAESAR</a> competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an <a href="https://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank">authenticated encryption with associated data</a> (AEAD) cipher specified in <a href="https://datatracker.ietf.org/doc/html/rfc8439" target="_blank">RFC 8439</a>. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.</p>
<p>The length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name="why_no_len_auth"><strong>Why is the length encryption not separately authenticated?</strong> Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in <a href="https://himsen.github.io/pdf/thesis.pdf" target="_blank">Hansen 2016 (Definition 22)</a> under the name &quot;boundary hiding against chosen-plaintext attacks (BH-CPA)&quot;.) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see <a href="https://himsen.github.io/pdf/thesis.pdf" target="_blank">Hansen 2016 (Section 3.9)</a> for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> <strong>ChaCha20</strong> encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in <a href="http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305" target="_blank">OpenSSH</a>.<ref name="openssl_changes"><strong>How does packet encryption differ from the OpenSSH design?</strong> The differences are:</p>
<ul>
<li>The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.</li>
<li>Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.</li>
<li>The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).</li>
<li>A hash step is performed every 224<ref name="rekey_interval"><strong>How was the rekeying interval 224 chosen?</strong> Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-<a href="/31" target="_blank">BIP31</a> connections) on a connection, the node will transmit 224 packets in about 3.11 days. This means <em>soft rekeying</em> after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 224 messages is sufficiently infrequent that it has only negligible impact on performance. Furthermore, 224 times 3 bytes (the number of bytes consumed by each length encryption) is 672, which is a multiple of 64 minus 32. This means that at the end of 224 length encryptions, exactly 32 bytes of keystream data remain that can be used as next key.</ref> messages to rekey the encryption ciphers, in order to provide forward security.</li>
</ul>
<p></ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name="ok_to_batch"><strong>Is it acceptable to use a less standard construction for length encryption?</strong> The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref></p>
<p>In order to provide forward security<ref name="rekey"><strong>What value does forward security provide?</strong> Re-keying ensures <a href="https://eprint.iacr.org/2001/035.pdf" target="_blank">forward secrecy within a session</a>, i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref><strong>Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?</strong> Our cipher ratchets encryption keys forward in order to protect messages encrypted under <em>past</em> encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under <em>future</em> encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers <em>temporarily</em> (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 224 messages, by switching to a new key that is generated by the key stream using the old key.</p>
<h4> Handshake: key exchange and version negotiation </h4>
<p>Next we specify the handshake of a connection in detail.</p>
<p>As explained before, these messages are sent to set up the connection:</p>
<pre><code> ----------------------------------------------------------------------------------------------------
 | Initiator                         Responder                                                      |
 |                                                                                                  |
 | x, ellswift_X = ellswift_create()                                                                |
 |                                                                                                  |
 |    ---- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) ---&gt;              |
 |                                                                                                  |
 |                                   y, ellswift_Y = ellswift_create()                              |
 |                                   ecdh_secret = v2_ecdh(                                         |
 |                                                     y, ellswift_X, ellswift_Y, initiating=False) |
 |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |
 |                                                                                                  |
 |    &lt;--- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +                 |
 |             responder_garbage_terminator (16 bytes) +                                            |
 |             v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION, aad=responder_garbage) ----    |
 |                                                                                                  |
 | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |
 | v2_initialize(responder, ecdh_secret, initiating=True)                                           |
 |                                                                                                  |
 |     ---- initiator_garbage_terminator (16 bytes) +                                               |
 |              v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION, aad=initiator_garbage) ---&gt;   |
 |                                                                                                  |
 ----------------------------------------------------------------------------------------------------
</code></pre>
<h5> Shared secret computation </h5>
<p>The peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.</p>
<pre><code>def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):
    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)
    if initiating:
        # Initiating, place our public key encoding first.
        return sha256_tagged(&quot;bip324_ellswift_xonly_ecdh&quot;, ellswift_ours + ellswift_theirs + ecdh_point_x32)
    else:
        # Responding, place their public key encoding first.
        return sha256_tagged(&quot;bip324_ellswift_xonly_ecdh&quot;, ellswift_theirs + ellswift_ours + ecdh_point_x32)
</code></pre>
<p>Here, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in <a href="/340" target="_blank">BIP340</a>.</p>
<h5> ElligatorSwift encoding of curve X coordinates </h5>
<p>The functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with
ElligatorSwift-encoded public keys.</p>
<p>First we define a constant:</p>
<ul>
<li>Let <em>c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852</em>.<ref name="sqrt_minus3"><strong>What is the <em>c</em> constant used in <em>XSwiftEC</em>?</strong> The algorithm requires a constant <em>√-3 (mod p)</em>; in other words, a number <em>c</em> such that <em>-c<sup>2</sup> mod p = 3</em>. There are two solutions to this equation, one which is itself a square modulo <em>p</em>, and its negation. We choose the square one.</ref></li>
</ul>
<p>To define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the <a href="https://eprint.iacr.org/2022/759.pdf" target="_blank">SwiftEC</a> paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers <em>(u, t)</em> (both in range <em>0..p-1</em>) to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from <a href="/340" target="_blank">BIP340</a>.</p>
<ul>
<li><em>XSwiftEC(u, t)</em>:
<ul>
<li>Alter the inputs to guarantee an X coordinate on the curve:<ref name="ellswift_deviation"><strong>Why do the inputs to the XSwiftEC algorithm need to be altered?</strong> This step deviates from the paper, which maps a negligibly small subset of inputs (around <em>3/2<sup>256</sup></em>) to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>
<ul>
<li>If <em>u mod p = 0</em>, let <em>u = 1</em> instead.</li>
<li>If <em>t mod p = 0</em>, let <em>t = 1</em> instead.</li>
<li>If <em>(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0</em>, let <em>t = 2t (mod p)</em> instead.</li>
</ul>
</li>
<li>Let <em>X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).</em><ref name="modinv"><strong>What does the division (/) sign in modular arithmetic refer to?</strong> Note that the division in these expressions corresponds to multiplication with the modular inverse modulo <em>p</em>, i.e. <em>a / b (mod p)</em> with nonzero <em>b</em> is the unique solution <em>x</em> for which <em>bx = a (mod p)</em>. It can be computed as <em>ab<sup>p-2</sup> (mod p)</em>, but more efficient algorithms exist.</ref></li>
<li>Let <em>Y = (X + t)/(cu) (mod p)</em>.</li>
<li>For every <em>x</em> in <em>{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}</em> (all <em>mod p</em>; the order matters):
<ul>
<li>If <em>lift_x(x)</em> succeeds, return <em>x</em>. There is at least one such <em>x</em>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>To find encodings of a given X coordinate <em>x</em>, we first need the inverse of <em>XSwiftEC</em>. The function <em>XSwiftECInv(x, u, case)</em> either returns <em>t</em> such that <em>XSwiftEC(u, t) = x</em>, or <em>None</em>. The <em>case</em> variable is an integer in range <em>0..7</em>, which selects which of the up to 8 valid such <em>t</em> values to return:</p>
<ul>
<li><em>XSwiftECInv(x, u, case)</em>:
<ul>
<li>If <em>case &amp; 2 = 0</em>:
<ul>
<li>If <em>lift_x(-x - u)</em> succeeds, return <em>None</em>.</li>
<li>Let <em>v = x</em>.</li>
<li>Let <em>s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)</em>.</li>
</ul>
</li>
<li>Else (<em>case &amp; 2 = 2</em>):
<ul>
<li>Let <em>s = x - u (mod p)</em>.</li>
<li>If <em>s = 0</em>, return <em>None</em>.</li>
<li>Let <em>r</em> be the square root of <em>-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).</em><ref name="modsqrt"><strong>How to compute a square root mod <em>p</em>?</strong> Due to the structure of <em>p</em>, a candidate for the square root of <em>a</em> mod <em>p</em> can be computed as <em>x = a<sup>(p+1)/4</sup> mod p</em>. If <em>a</em> is not a square mod <em>p</em>, this formula returns the square root of <em>-a mod p</em> instead, so it is necessary to verify that <em>x<sup>2</sup> mod p = a</em>. If that is the case <em>-x mod p</em> is a solution too, but we define &quot;the&quot; square root to be equal to that expression (the square root will therefore always be a square itself, as <em>(p+1)/4</em> is even). This algorithm is a specialization of the <a href="https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm" target="_blank">Tonelli-Shanks algorithm</a>.</ref> Return <em>None</em> if it does not exist.</li>
<li>If <em>case &amp; 1 = 1</em> and <em>r = 0</em>, return <em>None</em>.</li>
<li>Let <em>v = (r/s - u)/2</em>.</li>
</ul>
</li>
<li>Let <em>w</em> be the square root of <em>s (mod p)</em>. Return <em>None</em> if it does not exist.</li>
<li>If <em>case &amp; 5 = 0</em>, return <em>-w(u(1 - c)/2 + v)</em>.</li>
<li>If <em>case &amp; 5 = 1</em>, return <em>w(u(1 + c)/2 + v)</em>.</li>
<li>If <em>case &amp; 5 = 4</em>, return <em>w(u(1 - c)/2 + v)</em>.</li>
<li>If <em>case &amp; 5 = 5</em>, return <em>-w(u(1 + c)/2 + v)</em>.</li>
</ul>
</li>
</ul>
<p>The overall <em>XElligatorSwift</em> algorithm, matching the name used in the paper, then uses this inverse to randomly_<ref name="ellswift_helps_parroting"><strong>Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?</strong> The algorithm chooses the first 32 bytes (i.e., the value <em>u</em>) and then computes a corresponding <em>t</em> such that the mapping to the curve point holds. In general, picking <em>u</em> from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in <em>u</em>, and the algorithm will still find a corresponding <em>t</em>. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as <a href="https://tls13.xargs.org/" target="_blank">TLS 1.3</a>, which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of <em>x</em>:</p>
<ul>
<li><em>XElligatorSwift(x)</em>:
<ul>
<li>Loop:
<ul>
<li>Let <em>u</em> be a random non-zero integer in range <em>1..p-1</em> inclusive.</li>
<li>Let <em>case</em> be a random integer in range <em>0..7</em> inclusive.</li>
<li>Compute <em>t = XSwiftECInv(x, u, case)</em>.</li>
<li>If <em>t</em> is not <em>None</em>, return <em>(u, t)</em>. Otherwise, restart loop.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:</p>
<ul>
<li><em>ellswift_create()</em>:
<ul>
<li>Generate a random private key <em>priv</em> in range <em>1..p-1</em>.</li>
<li>Let <em>P = priv⋅G</em>, the corresponding public key point to <em>priv</em>.</li>
<li>Let <em>(u, t) = XElligatorSwift(x(P))</em>, an encoding of <em>x(P)</em>.</li>
<li><em>ellswift_pub = bytes(u) || bytes(t)</em>, its encoding as 64 bytes.</li>
<li>Return <em>(priv, ellswift_pub)</em>.</li>
</ul>
</li>
</ul>
<p>Finally the <code>ellswift_ecdh_xonly</code> algorithm is:</p>
<ul>
<li><em>ellswift_ecdh_xonly(ellswift_theirs, priv)</em>:
<ul>
<li>Let <em>u = int(ellswift_theirs[:32]) mod p</em>.</li>
<li>Let <em>t = int(ellswift_theirs[32:]) mod p</em>.</li>
<li>Return <em>bytes(x(priv⋅lift_x(XSwiftEC(u, t))))</em>.<ref name="lift_x_choice"><strong>Does it matter which point <em>lift_x</em> maps to?</strong> Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref></li>
</ul>
</li>
</ul>
<h5> Keys and session ID derivation </h5>
<p>The authenticated encryption construction proposed here requires two 32-byte keys per communication direction. These (in addition to a session ID) are computed using HKDF<ref name="why_hkdf"><strong>Why use HKDF for deriving key material?</strong> The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in <a href="https://tools.ietf.org/html/rfc5869" target="_blank">RFC 5869</a> with SHA256 as the hash function:</p>
<pre><code>def initialize_v2_transport(peer, ecdh_secret, initiating):
    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail
    prk = HKDF_Extract(Hash=sha256, salt=b&#x27;bitcoin_v2_shared_secret&#x27; + NETWORK_MAGIC, ikm=ecdh_secret)

    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#x27;session_id&#x27;, L=32)

    # Initialize the packet encryption ciphers.
    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#x27;initiator_L&#x27;, L=32)
    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#x27;initiator_P&#x27;, L=32)
    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#x27;responder_L&#x27;, L=32)
    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#x27;responder_P&#x27;, L=32)
    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b&#x27;garbage_terminators&#x27;, L=32)
    initiator_garbage_terminator = garbage_terminators[:16]
    responder_garbage_terminator = garbage_terminators[16:]

    if initiating:
        peer.send_L = FSChaCha20(initiator_L)
        peer.send_P = FSChaCha20Poly1305(initiator_P)
        peer.send_garbage_terminator = initiator_garbage_terminator
        peer.recv_L = FSChaCha20(responder_L)
        peer.recv_P = FSChaCha20Poly1305(responder_P)
        peer.recv_garbage_terminator = responder_garbage_terminator
    else:
        peer.send_L = FSChaCha20(responder_L)
        peer.send_P = FSChaCha20Poly1305(responder_P)
        peer.send_garbage_terminator = responder_garbage_terminator
        peer.recv_L = FSChaCha20(initiator_L)
        peer.recv_P = FSChaCha20Poly1305(initiator_P)
        peer.recv_garbage_terminator = initiator_garbage_terminator

    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:
    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)
</code></pre>
<p>The session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.</p>
<h5> Overall handshake pseudocode </h5>
<p>To establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len &lt; 4096</code>.</p>
<pre><code>def initiate_v2_handshake(peer, garbage_len):
    peer.privkey_ours, peer.ellswift_ours = ellswift_create()
    peer.sent_garbage = rand_bytes(garbage_len)
    send(peer, peer.ellswift_ours + peer.sent_garbage)
</code></pre>
<p>The responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len &lt; 4096</code>. If the first 16 bytes received match the v1 prefix, the v1 protocol is used instead.</p>
<pre><code>TRANSPORT_VERSION = b&#x27;&#x27;
NETWORK_MAGIC = b&#x27;\xf9\xbe\xb4\xd9&#x27; # Mainnet network magic; differs on other networks.
V1_PREFIX = NETWORK_MAGIC + b&#x27;version\x00\x00\x00\x00\x00&#x27;

def respond_v2_handshake(peer, garbage_len):
    peer.received_prefix = b&quot;&quot;
    while len(peer.received_prefix) &lt; len(V1_PREFIX):
        peer.received_prefix += receive(peer, 1)
        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:
            peer.privkey_ours, peer.ellswift_ours = ellswift_create()
            peer.sent_garbage = rand_bytes(garbage_len)
            send(peer, ellswift_Y + peer.sent_garbage)
            return
    use_v1_protocol()
</code></pre>
<p>Upon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code>, optionally followed by an arbitrary number of decoy packets. Afterwards, it receives the responder's garbage (delimited by the garbage terminator). The responder performs very similar steps but includes the earlier received prefix bytes in the public key. Both the initiator and the responder set the AAD of the first encrypted packet they send after the garbage terminator (i.e., either an optional decoy packet or the version packet) to the garbage they have just sent, not including the garbage terminator.</p>
<pre><code>def complete_handshake(peer, initiating, decoy_content_lengths=[]):
    received_prefix = b&#x27;&#x27; if initiating else peer.received_prefix
    ellswift_theirs = receive(peer, 64 - len(received_prefix))
    if not initiating and ellswift_theirs[4:16] == V1_PREFIX[4:16]:
        # Looks like a v1 peer from the wrong network.
        disconnect(peer)
    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,
                          initiating=initiating)
    initialize_v2_transport(peer, ecdh_secret, initiating=True)
    # Send garbage terminator
    send(peer, peer.send_garbage_terminator)
    # Optionally send decoy packets after garbage terminator.
    aad = peer.sent_garbage
    for decoy_content_len in decoy_content_lengths:
        send(v2_enc_packet(peer, decoy_content_len * b&#x27;\x00&#x27;, aad=aad))
        aad = b&#x27;&#x27;
    # Send version packet.
    send(v2_enc_packet(peer, TRANSPORT_VERSION, aad=aad))
    # Skip garbage, until encountering garbage terminator.
    received_garbage = recv(peer, 16)
    for i in range(4096):
        if received_garbage[-16:] == peer.recv_garbage_terminator:
            # Receive, decode, and ignore version packet.
            # This includes skipping decoys and authenticating the received garbage.
            v2_receive_packet(peer, aad=received_garbage[:-16])
            return
        else:
            received_garbage += recv(peer, 1)
    # Garbage terminator was not seen after 4 KiB of garbage.
    disconnect(peer)
</code></pre>
<h4> Packet encryption </h4>
<p>Lastly, we specify the packet encryption cipher in detail.</p>
<h5> Existing cryptographic primitives </h5>
<p>Packet encryption is built on two existing primitives:</p>
<ul>
<li><strong>ChaCha20Poly1305</strong> is specified as <code>AEAD_CHACHA20_POLY1305</code> in <a href="https://datatracker.ietf.org/doc/html/rfc8439" target="_blank">section-2.8 RFC 8439 section 2.8</a>. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:
<ul>
<li><code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array <em>key</em>, a 12-byte array <em>nonce</em>, an arbitrary-length byte array <em>aad</em>, and an arbitrary-length byte array <em>plaintext</em>, and returns a byte array <em>ciphertext</em>, 16 bytes longer than the plaintext.</li>
<li><code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array <em>key</em>, a 12-byte array <em>nonce</em>, an arbitrary-length byte array <em>aad</em>, and an arbitrary-length byte array <em>ciphertext</em>, and returns either a byte array <em>plaintext</em> (16 bytes shorter than the ciphertext), or <em>None</em> in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified <em>key</em>, <em>nonce</em>, and <em>aad</em>.</li>
</ul>
</li>
<li>The <strong>ChaCha20 Block Function</strong> is specified in <a href="https://datatracker.ietf.org/doc/html/rfc8439" target="_blank">section-2.3 RFC 8439 section 2.3</a>. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:
<ul>
<li><code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array <em>key</em>, a 12-byte array <em>nonce</em>, and an integer <em>count</em> in range <em>0..2<sup>32</sup>-1</em>, and returns a byte array of length 64.</li>
</ul>
</li>
</ul>
<p>These will be used for plaintext encryption and length encryption, respectively.</p>
<h5> Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 </h5>
<p>To provide re-keying every 224 packets, we specify two wrappers.</p>
<p>The first is <strong>FSChaCha20Poly1305</strong>, which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 224 messages by encrypting 32 zero bytes<ref name="rekey_why_aead"><strong>Why is rekeying implemented in terms of an invocation of the AEAD?</strong> This means the FSChaCha20Poly1305 wrapper can be thought of as a pure layer around the ChaCha20Poly1305 AEAD. Actual implementations can take advantage of the fact that this formulation is equivalent to using byte 64 through 95 of the keystream output of the underlying ChaCha20 cipher as new key, avoiding the need for Poly1305 in the process.</ref>, and using the first 32 bytes of the result. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little-endian encoding of the number of messages with the current key, followed by the 64-bit little-endian encoding of the number of rekeyings performed. For rekeying, the first 32-bit integer is set to <em>0xffffffff</em>.</p>
<pre><code>REKEY_INTERVAL = 224

class FSChaCha20Poly1305:
    &quot;&quot;&quot;Rekeying wrapper AEAD around ChaCha20Poly1305.&quot;&quot;&quot;

    def __init__(self, initial_key):
        self.key = initial_key
        self.packet_counter = 0

    def crypt(self, aad, text, is_decrypt):
        nonce = ((self.packet_counter % REKEY_INTERVAL).to_bytes(4, &#x27;little&#x27;) +
                 (self.packet_counter &#x2F;&#x2F; REKEY_INTERVAL).to_bytes(8, &#x27;little&#x27;))
        if is_decrypt:
            ret = aead_chacha20_poly1305_decrypt(self.key, nonce, aad, text)
        else:
            ret = aead_chacha20_poly1305_encrypt(self.key, nonce, aad, text)
        if (self.packet_counter + 1) % REKEY_INTERVAL == 0:
            rekey_nonce = b&quot;\xFF\xFF\xFF\xFF&quot; + nonce[4:]
            self.key = aead_chacha20_poly1305_encrypt(self.key, rekey_nonce, b&quot;&quot;, b&quot;\x00&quot; * 32)[:32]
        self.packet_counter += 1
        return ret

    def decrypt(self, aad, ciphertext):
        return self.crypt(aad, ciphertext, True)

    def encrypt(self, aad, plaintext):
        return self.crypt(aad, plaintext, False)
</code></pre>
<p>The second is <strong>FSChaCha20</strong>, a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 224 chunks using the next 32 bytes of the block function output as new key. A <em>chunk</em> refers here to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 224 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 224 chunks is composed of 4 zero bytes followed by the 64-bit little-endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.</p>
<pre><code>class FSChaCha20:
    &quot;&quot;&quot;Rekeying wrapper stream cipher around ChaCha20.&quot;&quot;&quot;

    def __init__(self, initial_key):
        self.key = initial_key
        self.block_counter = 0
        self.chunk_counter = 0
        self.keystream = b&#x27;&#x27;

    def get_keystream_bytes(self, nbytes):
        while len(self.keystream) &lt; nbytes:
            nonce = ((0).to_bytes(4, &#x27;little&#x27;) +
                     (self.chunk_counter &#x2F;&#x2F; REKEY_INTERVAL).to_bytes(8, &#x27;little&#x27;))
            self.keystream += chacha20_block(self.key, nonce, self.block_counter)
            self.block_counter += 1
        ret = self.keystream[:nbytes]
        self.keystream = self.keystream[nbytes:]
        return ret

    def crypt(self, chunk):
        ks = self.get_keystream_bytes(len(chunk))
        ret = bytes([ks[i] ^ chunk[i] for i in range(len(chunk))])
        if ((self.chunk_counter + 1) % REKEY_INTERVAL) == 0:
            self.key = self.get_keystream_bytes(32)
            self.block_counter = 0
        self.chunk_counter += 1
        return ret
</code></pre>
<h5> Overall packet encryption and decryption pseudocode </h5>
<p>Encryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.</p>
<pre><code>LENGTH_FIELD_LEN = 3
HEADER_LEN = 1
IGNORE_BIT_POS = 7

def v2_enc_packet(peer, contents, aad=b&#x27;&#x27;, ignore=False):
    assert len(contents) &lt;= 2**24 - 1
    header = (ignore &lt;&lt; IGNORE_BIT_POS).to_bytes(HEADER_LEN, &#x27;little&#x27;)
    plaintext = header + contents
    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)
    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, &#x27;little&#x27;))
    return enc_contents_len + aead_ciphertext
</code></pre>
<pre><code>CHACHA20POLY1305_EXPANSION = 16

def v2_receive_packet(peer, aad=b&#x27;&#x27;):
    while True:
        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)
        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), &#x27;little&#x27;)
        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)
        plaintext = peer.recv_P.decrypt(aad, aead_ciphertext)
        if plaintext is None:
            disconnect(peer)
            break
        # Only the first packet is expected to have non-empty AAD.
        aad = b&#x27;&#x27;
        header = plaintext[:HEADER_LEN]
        if not (header[0] &amp; (1 &lt;&lt; IGNORE_BIT_POS)):
            return plaintext[HEADER_LEN:]
</code></pre>
<h4> Performance </h4>
<p>Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.</p>
<h3> Application layer specification </h3>
<h4> v2 Bitcoin P2P message structure </h4>
<p>v2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer <strong>contents</strong> is composed of:</p>
<table><thead><tr><th>Field</th><th>Size in bytes</th><th>Comments</th></tr></thead><tbody>
<tr><td><code>message_type</code></td><td>1 or 13</td><td>either a one byte ID in range <em>1..255</em> or <code>b'\x00'</code> followed by a 12-byte ASCII message type (as in the v1 P2P protocol)</td></tr>
<tr><td><code>message_payload</code></td><td><code>message_length</code></td><td>message payload</td></tr>
</tbody></table>
<p>If the first byte of <code>message_type</code> is <code>b'\x00'</code>, the following 12 bytes are interpreted as an ASCII message type (as in the v1 P2P protocol), trailing padded with <code>b'\x00'</code> as necessary. If the first byte of <code>message_type</code> is in the range <em>1..255</em>, it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol, as most messages sent/received will have a message type ID. We recommend reserving 1-byte type IDs for message types that are sent more than once per direction per connection.<ref name="smaller_messages"><strong>How do the lengths between v1 and v2 compare?</strong> For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref>&lt;ref name&quot;fixed_length_long_ids&quot;&gt;<strong>Why not allow variable length long message type IDs?</strong> Allowing for variable length long IDs reduces the available 1-byte ID space by 12 (to encode the length itself) and incentivizes less descriptive message types. In addition, limiting message types to fixed lengths of 1 or 13 hampers traffic analysis.</ref></p>
<p>The following table lists currently defined message type IDs:</p>
<table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody>
<tr><td>(12 bytes follow)</td><td><code>ADDR</code></td><td><code>BLOCK</code></td><td><code>BLOCKTXN</code></td><td></td></tr>
<tr><td><code>CMPCTBLOCK</code></td><td><code>FEEFILTER</code></td><td><code>FILTERADD</code></td><td><code>FILTERCLEAR</code></td><td></td></tr>
<tr><td><code>FILTERLOAD</code></td><td><code>GETBLOCKS</code></td><td><code>GETBLOCKTXN</code></td><td><code>GETDATA</code></td><td></td></tr>
<tr><td><code>GETHEADERS</code></td><td><code>HEADERS</code></td><td><code>INV</code></td><td><code>MEMPOOL</code></td><td></td></tr>
<tr><td><code>MERKLEBLOCK</code></td><td><code>NOTFOUND</code></td><td><code>PING</code></td><td><code>PONG</code></td><td></td></tr>
<tr><td><code>SENDCMPCT</code></td><td><code>TX</code></td><td><code>GETCFILTERS</code></td><td><code>CFILTER</code></td><td></td></tr>
<tr><td><code>GETCFHEADERS</code></td><td><code>CFHEADERS</code></td><td><code>GETCFCHECKPT</code></td><td><code>CFCHECKPT</code></td><td></td></tr>
<tr><td>+28</td><td><code>ADDRV2</code></td><td></td><td></td><td></td></tr>
<tr><td>≥29</td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<p>Additional message types may be added separately after BIP finalization.</p>
<h3> Signaling specification </h3>
<h4> Signaling v2 support </h4>
<p>Peers supporting the v2 transport protocol signal support by advertising the <code>NODE_P2P_V2 = (1 &lt;&lt; 11)</code> service flag in addr relay. If met with immediate disconnection when establishing a v2 connection, clients implementing this proposal are encouraged to retry connecting using the v1 protocol.<sup id="cite_ref_2"><a href="#cite_ref_2">2</a></sup></p>
<h2> Test Vectors </h2>
<p>For development and testing purposes, we provide a collection of test vectors in CSV format, and a naive, highly inefficient, <a href="https://github.com/bitcoin/bips/blob/master/bip-0324/reference.py" target="_blank">reference implementation</a> of the relevant algorithms. This code is for demonstration purposes only:</p>
<ul>
<li><a href="https://github.com/bitcoin/bips/blob/master/bip-0324/ellswift_decode_test_vectors.csv" target="_blank">XElligatorSwift decoding vectors</a> provide examples of ElligatorSwift-encoded public keys, and the X coordinate they map to.</li>
<li><a href="https://github.com/bitcoin/bips/blob/master/bip-0324/xswiftec_inv_test_vectors.csv" target="_blank">XSwiftECInv vectors</a> provide examples of <em>(u, x)</em> pairs, and the various <em>t</em> values that <em>xswiftec_inv</em> maps them to.</li>
<li><a href="https://github.com/bitcoin/bips/blob/master/bip-0324/packet_encoding_test_vectors.csv" target="_blank">Packet encoding vectors</a> illustrate the lifecycle of the authenticated encryption scheme proposed in this document.</li>
</ul>
<h2> Rationale and References </h2>
<ol>
<li><a href="https://bips.dev/324/#cite_ref_1">^</a> <strong>Why is the header a part of the plaintext and not included alongside the length field?</strong> The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</li>
<li><a href="https://bips.dev/324/#cite_ref_2">^</a> <strong>Why are v2 clients met with immediate disconnection encouraged to retry with a v1 connection?</strong> Service flags propagated through untrusted intermediaries using ADDR and ADDRV2 P2P messages and are OR'ed when received from multiple sources. An untrusted intermediary could falsely advertise a potential peer as supportive of v2 connections. Connection downgrades to v1 mitigate the risk of a network participant being blackholed via false advertising.</li>
</ol>
<h2> Acknowledgements </h2>
<p>Thanks to everyone (last name order) that helped invent and develop the ideas in this proposal:</p>
<ul>
<li>Matt Corallo</li>
<li>Lloyd Fournier</li>
<li>Gregory Maxwell</li>
<li>Anthony Towns</li>
</ul>

        </article>
    </div>


            <hr class="border-slate-700" />

            <div data-pagefind-ignore class="w-full flex flex-col items-center space-y-2 text-center">
                <div class="flex items-center space-x-2">
                    <p class="font-bold">Updated</p>
                    <p class="font-bold">2026-01-04</p>
                </div>
                <p>See an issue with rendering or formatting? Submit an issue on <a href="https://github.com/nickmonad/bips.dev" target="_blank">GitHub</a></p>
                <p>Do you find this site useful? Please consider <a href="https://buy.tryspeed.com/plink_live_lyek4a2yW2Sn2wfA" target="_blank">donating</a> some sats to support ongoing development.</p>
                <p><a href="/">bips.dev</a> is presented by <a href="https://nickmonad.blog" target="_blank">nickmonad</a></p>
                <p class="pt-4 text-sm">All content is owned and licensed by the respective author(s). This website makes no claim of ownership.</p>
            </div>
        </div>
    </div>
</body>
</html>
