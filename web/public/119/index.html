<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Read BIPs like a pro." />
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="og:title" content="BIP 119: CHECKTEMPLATEVERIFY" />
    <meta property="og:description" content="Read BIPs like a pro." />
    <meta property="og:image" content="https://bips.dev/og-bips-dev.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="BIP 119: CHECKTEMPLATEVERIFY" />
    <meta name="twitter:description" content="Read BIPs like a pro." />
    <meta name="twitter:creator" content="@nickmonad" />
    <meta name="twitter:image" content="https://bips.dev/og-bips-dev.png" />

    <title>BIP 119: CHECKTEMPLATEVERIFY</title>

    
        <link rel="stylesheet" href="/style.css" />
    

    <link rel="stylesheet" href="/pagefind/pagefind-ui.css" />
    <script src="/pagefind/pagefind-ui.js"></script>

    <script defer data-domain="bips.dev" src="/js/script.js"></script>
    <script>
        // setup plausible function for custom events
        window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }

        // setup and initialize dark mode
        // https://tailwindcss.com/docs/dark-mode
        window.setTheme = function() {
            if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark')
            } else {
                document.documentElement.classList.remove('dark')
            }
        }
        window.setTheme();

        // searching via
        // https://pagefind.app
        window.addEventListener('DOMContentLoaded', function(event) {
            new PagefindUI({
                element: "#search",
                hightlightParam: "highlight",
                showImages: false,
                showSubResults: true,
                translations: {
                    placeholder: "Search BIPs"
                },
                processTerm: function(term) {
                    plausible('Search');
                    return term;
                }
            });
        });
    </script>

    <style>
        /* variables to override on pagefind */
        /* https://pagefind.app/docs/ui-usage/#customising-the-styles */
        /* values are from tailwind: https://tailwindcss.com/docs/customizing-colors */
        :root {
            --pagefind-ui-primary: #334155;
            --pagefind-ui-text: #334155;
            --pagefind-ui-background: #ffffff;
            --pagefind-ui-border-width: 1px;
            --pagefind-ui-border-radius: 4px;
        }

        html.dark {
            --pagefind-ui-primary: #d1d5db;
            --pagefind-ui-text: #d1d5db;
            --pagefind-ui-background: #18181b;
            --pagefind-ui-border: #152028;
        }

        mark {
            background-color: #ff9900 !important;
            color: #6b7280 !important;
        }
    </style>
</head>

<body class="bg-white dark:bg-zinc-900">
    <div class="container mx-auto flex justify-center">
        <div data-pagefind-body class="min-w-full max-w-full lg:min-w-[1000px] lg:max-w-[1000px] px-6 py-10 space-y-10 text-slate-700 dark:text-gray-300">
            
    <div class="flex flex-col space-y-4 pt-4 md:pt-8">
        <div class="flex justify-between">
            <a href="/">Back to BIPs</a>
            <div class="flex">
                <svg id="toggleDark_light" class="hidden dark:flex w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'light'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
                </svg>
                <svg id="toggleDark_dark" class="flex dark:hidden w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'dark'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
                </svg>
            </div>
        </div>
        <div class="flex flex-col space-y-2">
            <div data-pagefind-weight="10" class="text-2xl font-extrabold">BIP 119: CHECKTEMPLATEVERIFY</div>
            <div class="flex justify-between">
                <div class="text-xl font-semibold">2020-01-06</div>
                <a href="https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;blob&#x2F;master&#x2F;bip-0119.mediawiki" target="_blank">View on GitHub</a>
            </div>
        </div>

        <article class="max-w-none prose prose-lg prose-zinc prose-p:leading-relaxed prose-a:font-bold prose-a:underline prose-a:decoration-2 prose-a:decoration-bitcoin prose-pre:bg-zinc-200 prose-pre:text-zinc-800 dark:prose-invert dark:prose-pre:bg-zinc-600 dark:prose-pre:text-white">
            <pre><code>  BIP: 119
  Layer: Consensus (soft fork)
  Title: CHECKTEMPLATEVERIFY
  Author: Jeremy Rubin &lt;j@rubin.io&gt;
  Comments-URI: https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;wiki&#x2F;Comments:BIP-0119
  Status: Draft
  Type: Standards Track
  Created: 2020-01-06
  License: BSD-3-Clause
</code></pre>
<h2>Abstract</h2>
<p>This BIP proposes a new opcode, OP_CHECKTEMPLATEVERIFY, to be activated
as a change to the semantics of OP_NOP4.</p>
<h2>Summary</h2>
<p>OP_CHECKTEMPLATEVERIFY uses opcode OP_NOP4 (0xb3) as a soft fork upgrade.</p>
<p>OP_CHECKTEMPLATEVERIFY does the following:</p>
<ul>
<li>There is at least one element on the stack, fail otherwise</li>
<li>The element on the stack is 32 bytes long, NOP otherwise</li>
<li>The DefaultCheckTemplateVerifyHash of the transaction at the current input index is equal to the element on the stack, fail otherwise</li>
</ul>
<p>The DefaultCheckTemplateVerifyHash commits to the serialized version, locktime, scriptSigs hash (if any
non-null scriptSigs), number of inputs, sequences hash, number of outputs, outputs hash, and
currently executing input index.</p>
<p>The recommended standardness rules additionally:</p>
<ul>
<li>Reject non-32 byte as SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS.</li>
</ul>
<h2>Motivation</h2>
<p>This BIP introduces a transaction template, a simple spending restriction that
pattern matches a transaction against a hashed transaction specification.
OP_CHECKTEMPLATEVERIFY reduces many of the trust, interactivity, and storage
requirements inherent with the use of pre-signing in applications.
For more details on applications, please see the references.</p>
<h2>Detailed Specification</h2>
<p>The below code is the main logic for verifying CHECKTEMPLATEVERIFY, described
in pythonic pseudocode. The canonical specification for the semantics of
OP_CHECKTEMPLATEVERIFY as implemented in C++ in the context of Bitcoin Core can
be seen in the reference implementation.</p>
<p>The execution of the opcode is as follows:</p>
<pre><code>def execute_bip_119(self):
    # Before soft-fork activation &#x2F; failed activation
    # continue to treat as NOP4
    if not self.flags.script_verify_default_check_template_verify_hash:
        # Potentially set for node-local policy to discourage premature use
        if self.flags.script_verify_discourage_upgradable_nops:
            return self.errors_with(errors.script_err_discourage_upgradable_nops)
        return self.return_as_nop()

    # CTV always requires at least one stack argument
    if len(self.stack) &lt; 1:
        return self.errors_with(errors.script_err_invalid_stack_operation)

    # CTV only verifies the hash against a 32 byte argument
    if len(self.stack[-1]) == 32:
        # Ensure the precomputed data required for anti-DoS is available,
        # or cache it on first use
        if self.context.precomputed_ctv_data == None:
            self.context.precomputed_ctv_data = self.context.tx.get_default_check_template_precomputed_data()

        # If the hashes do not match, return error
        if stack[-1] != self.context.tx.get_default_check_template_hash(self.context.nIn, self.context.precomputed_ctv_data):
            return self.errors_with(errors.script_err_template_mismatch)

        return self.return_as_nop()

    # future upgrade can add semantics for this opcode with different length args
    # so discourage use when applicable
    if self.flags.script_verify_discourage_upgradable_nops:
        return self.errors_with(errors.script_err_discourage_upgradable_nops)
    else:
        return self.return_as_nop()
</code></pre>
<p>The computation of this hash can be implemented as specified below (where self
is the transaction type). Care must be taken that in any validation context,
the precomputed data must be initialized to prevent Denial-of-Service attacks.
Any implementation <em>must</em> cache these parts of the hash computation to avoid
quadratic hashing DoS. All variable length computations must be precomputed
including hashes of the scriptsigs, sequences, and outputs. See the section
&quot;Denial of Service and Validation Costs&quot; below. This is not a performance
optimization.</p>
<pre><code>
def ser_compact_size(l):
    r = b&quot;&quot;
    if l &lt; 253:
        # Serialize as unsigned char
        r = struct.pack(&quot;B&quot;, l)
    elif l &lt; 0x10000:
        # Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian)
        r = struct.pack(&quot;&lt;BH&quot;, 253, l)
    elif l &lt; 0x100000000:
        # Serialize as unsigned char 254 followed by unsigned 4 byte integer (little endian)
        r = struct.pack(&quot;&lt;BI&quot;, 254, l)
    else:
        # Serialize as unsigned char 255 followed by unsigned 8 byte integer (little endian)
        r = struct.pack(&quot;&lt;BQ&quot;, 255, l)
    return r

def ser_string(s):
    return ser_compact_size(len(s)) + s

class CTxOut:
    def serialize(self):
        r = b&quot;&quot;
        # serialize as signed 8 byte integer (little endian)
        r += struct.pack(&quot;&lt;q&quot;, self.nValue)
        r += ser_string(self.scriptPubKey)
        return r

def get_default_check_template_precomputed_data(self):
    result = {}
    # If there are no scriptSigs we do not need to precompute a hash
    if any(inp.scriptSig for inp in self.vin):
        result[&quot;scriptSigs&quot;] = sha256(b&quot;&quot;.join(ser_string(inp.scriptSig) for inp in self.vin))
    # The same value is also pre-computed for and defined in BIP-341 and can be shared.
    # each nSequence is packed as 4 byte unsigned integer (little endian)
    result[&quot;sequences&quot;] = sha256(b&quot;&quot;.join(struct.pack(&quot;&lt;I&quot;, inp.nSequence) for inp in self.vin))
    # The same value is also pre-computed for and defined in BIP-341 and can be shared
    # See class CTxOut above for details.
    result[&quot;outputs&quot;] = sha256(b&quot;&quot;.join(out.serialize() for out in self.vout))
    return result

# parameter precomputed must be passed in for DoS resistance
def get_default_check_template_hash(self, nIn, precomputed = None):
    if precomputed == None:
        precomputed = self.get_default_check_template_precomputed_data()
    r = b&quot;&quot;
    # Serialize as 4 byte signed integer (little endian)
    r += struct.pack(&quot;&lt;i&quot;, self.nVersion)
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack(&quot;&lt;I&quot;, self.nLockTime)
    # we do not include the hash in the case where there is no
    # scriptSigs
    if &quot;scriptSigs&quot; in precomputed:
        r += precomputed[&quot;scriptSigs&quot;]
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack(&quot;&lt;I&quot;, len(self.vin))
    r += precomputed[&quot;sequences&quot;]
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack(&quot;&lt;I&quot;, len(self.vout))
    r += precomputed[&quot;outputs&quot;]
    # Serialize as 4 byte unsigned integer (little endian)
    r += struct.pack(&quot;&lt;I&quot;, nIn)
    return sha256(r)
</code></pre>
<p>A PayToBareDefaultCheckTemplateVerifyHash output matches the following template:</p>
<pre><code># Extra-fast test for pay-to-basic-standard-template CScripts:
def is_pay_to_bare_default_check_template_verify_hash(self):
    return len(self) == 34 and self[0] == 0x20 and self[-1] == OP_CHECKTEMPLATEVERIFY
</code></pre>
<h2>Deployment</h2>
<p>Activation logic is elided from this BIP and is more appropriately discussed elsewhere.</p>
<p>Until BIP-119 reaches ACTIVE state and the
SCRIPT_VERIFY_DEFAULT_CHECK_TEMPLATE_VERIFY_HASH flag is enforced, node implementations should (are recommended to)
execute a NOP4 as SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS (to deny entry to the mempool) for policy and must evaluate as
a NOP for consensus (during block validation).</p>
<p>In order to facilitate using CHECKTEMPLATEVERIFY, the common case of a
PayToBareDefaultCheckTemplateVerifyHash
with no scriptSig data may (is recommended to) be made standard to permit relaying. Future bare scripts may be
standardized later as policy changes at the preference of the implementer.</p>
<h2>Reference Implementation</h2>
<p>A reference implementation and tests are available here in the PR to Bitcoin Core https://github.com/bitcoin/bitcoin/pull/21702.</p>
<p>It is not ideal to link to a PR, as it may be rebased and changed, but it is the best place to find
the current implementation and review comments of others.
A recent commit hash in that PR including tests and vectors can be found here https://github.com/jeremyrubin/bitcoin/commit/3109df5616796282786706738994a5b97b8a5a38.
Once the PR is merged, this BIP should be updated to point to the specific code released.</p>
<p>Test vectors are available in [/bip-0119/vectors the bip-0119/vectors
directory] for checking compatibility with the reference implementation and BIP.</p>
<h2>Rationale</h2>
<p>OP_CHECKTEMPLATEVERIFY's design is a small code change and simple to analyze. It is
compatible with future upgrades if new template types are required
for more complex but demonstrably safe use cases.</p>
<p>Below we'll discuss the rules one-by-one:</p>
<h4>The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack</h4>
<p>The set of data committed to is a superset of data which can impact the TXID of the transaction,
other than the inputs. This ensures that for a given known input, the TXIDs can also be known ahead
of time. Otherwise, CHECKTEMPLATEVERIFY would not be usable for Batched Channel Creation constructions
as the redemption TXID could be malleated and pre-signed transactions invalidated, unless the channels
are built using an LN-Symmetry-like protocol. Note that there may be other types of pre-signed contracts that
may or may not be able to use LN-Symmetry-like constructs, therefore making TXIDs predictable makes CTV more
composable with arbitrary sub-protocols.</p>
<h5>Committing to the version and locktime</h5>
<p>Were these values not committed, it would be possible to delay the spending of
an output arbitrarily as well as possible to change the TXID.</p>
<p>Committing these values, rather than restricting them to specific values, is
more flexible as it permits users of CHECKTEMPLATEVERIFY to set the version and
locktime as they please.</p>
<h5>Committing to the ScriptSigs Hash</h5>
<p>The scriptsig in a segwit transaction must be exactly empty, unless it is a P2SH
segwit transaction in which case it must be only the exact redeemscript. P2SH is incompatible
(unless the P2SH hash is broken) with CHECKTEMPLATEVERIFY because the template hash must commit
to the ScriptSig, which must contain the redeemscript, which is a hash cycle.</p>
<p>To prevent malleability when not using a segwit input, we also commit to the
scriptsig. This makes it possible to use a 2 input CHECKTEMPLATEVERIFY with a legacy pre-signed
spend, as long as the exact scriptsig for the legacy output is committed. This is more robust than
simply disallowing any scriptSig to be set with CHECKTEMPLATEVERIFY.</p>
<p>If no scriptSigs are set in the transaction, there is no purpose in hashing the data or including it
in the DefaultCheckTemplateVerifyHash, so we elide it. It is expected to be common that no scriptSigs will be
set as segwit mandates that the scriptSig must be empty (to avoid malleability).</p>
<p>We commit to the hash rather than the values themselves as this is already
precomputed for each transaction to optimize SIGHASH_ALL signatures.</p>
<p>Committing to the hash additionally makes it simpler to construct DefaultCheckTemplateVerifyHash safely and unambiguously from
script.</p>
<h5>Committing to the number of inputs</h5>
<p>If we allow more than one input to be spent in the transaction then it would be
possible for two outputs to request payment to the same set of outputs,
resulting in half the intended payments being discarded, the &quot;half-spend&quot; problem.</p>
<p>Furthermore, the restriction on which inputs can be co-spent is critical for
payments-channel constructs where a stable TXID is a requirement (updates would
need to be signed on all combinations of inputs).</p>
<p>However, there are legitimate use cases for allowing multiple inputs. For
example:</p>
<p>Script paths:</p>
<pre><code>    Path A: &lt;+24 hours&gt; OP_CHECKSEQUENCEVERIFY OP_CHECKTEMPLATEVERIFY &lt;Pay Alice 1 Bitcoin (1 input) nLockTime for +24 hours&gt;
    Path B: OP_CHECKTEMPLATEVERIFY &lt;Pay Bob 2 Bitcoin (2 inputs)&gt;
</code></pre>
<p>In this case, there are 24 hours for the output to, with the addition of a
second output, pay Bob 2 BTC. If 24 hours lapses, then Alice may redeem her 1
BTC from the contract. Both input UTXOs may have the exact same Path B, or only one.</p>
<p>The issue with these constructs is that there are N! orders that the inputs can
be ordered in and it's not generally possible to restrict the ordering.</p>
<p>CHECKTEMPLATEVERIFY allows for users to guarantee the exact number of inputs being
spent. In general, using CHECKTEMPLATEVERIFY with more than one input is difficult
and exposes subtle issues, so multiple inputs should not be used except in
specific applications.</p>
<p>In principle, committing to the Sequences Hash (below) implicitly commits to the number of inputs,
making this field strictly redundant. However, separately committing to this number makes it easier
to construct DefaultCheckTemplateVerifyHash from script.</p>
<p>We treat the number of inputs as a <code>uint32_t</code> because Bitcoin's consensus decoding logic limits vectors
to <code>MAX_SIZE=33554432</code> and that is larger than <code>uint16_t</code> and smaller than <code>uint32_t</code>. 32 bits is also
friendly for manipulation using Bitcoin's current math opcodes, should <code>OP_CAT</code> be added. Note that
the max inputs in a block is further restricted by the block size to around 25,000, which would fit
into a <code>uint16_t</code>, but that is an unnecessary abstraction leak.</p>
<h5>Committing to the Sequences Hash</h5>
<p>If we don't commit to the sequences, then the TXID can be malleated. This also allows us to enforce
a relative sequence lock without an OP_CSV. It is insufficient to just pair CHECKTEMPLATEVERIFY
with OP_CSV because OP_CSV enforces a minimum nSequence value, not a literal value.</p>
<p>We commit to the hash rather than the values themselves as this is already
precomputed for each transaction to optimize SIGHASH_ALL signatures.</p>
<p>Committing to the hash additionally makes it simpler to construct DefaultCheckTemplateVerifyHash safely and unambiguously from
script.</p>
<h5>Committing to the Number of Outputs</h5>
<p>In principle, committing to the Outputs Hash (below) implicitly commits to the number of outputs,
making this field strictly redundant. However, separately committing to this number makes it easier
to construct DefaultCheckTemplateVerifyHash from script.</p>
<p>We treat the number of outputs as a <code>uint32_t</code> because a <code>COutpoint</code> index is a <code>uint32_t</code>.
Further, Bitcoin's consensus decoding logic limits vectors to <code>MAX_SIZE=33554432</code> and that is
larger than <code>uint16_t</code> and smaller than <code>uint32_t</code>. 32 bits is also friendly for manipulation using
Bitcoin's current math opcodes, should <code>OP_CAT</code> be added.</p>
<h5>Committing to the outputs hash</h5>
<p>This ensures that spending the UTXO is guaranteed to create the exact outputs
requested.</p>
<p>We commit to the hash rather than the values themselves as this is already
precomputed for each transaction to optimize SIGHASH_ALL signatures.</p>
<p>Committing to the hash additionally makes it simpler to construct DefaultCheckTemplateVerifyHash safely and unambiguously from
script.</p>
<h5>Committing to the current input's index</h5>
<p>Committing to the currently executing input's index is not strictly needed for anti-malleability,
however it does restrict the input orderings eliminating a source of malleability for protocol
designers.</p>
<p>However, committing to the index eliminates key-reuse vulnerability to the half-spend problem.
As CHECKTEMPLATEVERIFY scripts commit to being spent at particular index, reused instances of these
scripts cannot be spent at the same index, which implies that they cannot be spent in the same transaction.
This makes it safer to design wallet vault contracts without half-spend vulnerabilities.</p>
<p>Committing to the current index doesn't prevent one from expressing a CHECKTEMPLATEVERIFY which can
be spent at multiple indices. In current script, the CHECKTEMPLATEVERIFY operation can be wrapped
in an OP_IF for each index (or Tapscript branches in the future). If OP_CAT or OP_SHA256STREAM are
added to Bitcoin, the index may simply be passed in by the witness before hashing.</p>
<h5>Committing to Values by Hash</h5>
<p>Committing to values by hash makes it easier and more efficient to construct a
DefaultCheckTemplateVerifyHash
from script. Fields which are not intended to be set may be committed to by hash without incurring
O(n) overhead to re-hash.</p>
<p>Furthermore, if OP_SHA256STREAM is added in the future, it may be possible to write a script which
allows adding a single output to a list of outputs without incurring O(n) overhead by committing to
a hash midstate in the script.</p>
<h5>Using SHA256</h5>
<p>SHA256 is a 32 byte hash which meets Bitcoin's security standards and is
available already inside of Bitcoin Script for programmatic creation of template
programs.</p>
<p>RIPEMD160, a 20 byte hash, might also be a viable hash in some contexts and has some benefits. For fee efficiency,
RIPEMD160 saves 12 bytes. However, RIPEMD160 was not chosen for BIP-119 because it introduces
risks around the verification of programs created by third parties to be subject to a
<a href="birthday-attack" target="_blank">https://bitcoin.stackexchange.com/questions/54841/birthday-attack-on-p2sh</a> on
transaction preimages.</p>
<h5>Using Non-Tagged Hashes</h5>
<p>The Taproot/Schnorr BIPs use Tagged Hashes
(<code>SHA256(SHA256(tag)||SHA256(tag)||msg)</code>) to prevent taproot leaves, branches,
tweaks, and signatures from overlapping in a way that might introduce a security
<a href="vulnerability" target="_blank">https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-June/016091.html</a>.</p>
<p>OP_CHECKTEMPLATEVERIFY is not subject to this sort of vulnerability as the
hashes are effectively tagged externally, that is, by OP_CHECKTEMPLATEVERIFY
itself and therefore cannot be confused for another hash.</p>
<p>It would be a conservative design decision to make it a tagged hash even if
there was no obvious benefit and no cost. However, in the future, if OP_CAT were
to be introduced to Bitcoin, it would make programs which dynamically build
OP_CHECKTEMPLATEVERIFY hashes less space-efficient. Therefore, bare untagged hashes
are used in BIP-119.</p>
<h5>The Ordering of Fields</h5>
<p>Strictly speaking, the ordering of fields is insignificant. However, with a
carefully selected order, the efficiency of future scripts (e.g., those using a
OP_CAT or OP_SHA256STREAM) may be improved (as described in the Future Upgrades
section).</p>
<p>In particular, the order is selected in order of least likely to change to most.</p>
<ol>
<li>nVersion</li>
<li>nLockTime</li>
<li>scriptSig hash (maybe!)</li>
<li>input count</li>
<li>sequences hash</li>
<li>output count</li>
<li>outputs hash</li>
<li>input index</li>
</ol>
<p>Several fields are infrequently modified. nVersion should change infrequently. nLockTime should
generally be fixed to 0 (in the case of a payment tree, only the <em>first</em> lock time is needed to
prevent fee-sniping the root). scriptSig hash should generally not be set at all.</p>
<p>Since there are many possible sequences hash for a given input count, the input count comes before
the sequences hash.</p>
<p>Since there are many possible outputs hashes for a given out count, the output count comes before
the outputs hash.</p>
<p>Since we're generally using a single input to many output design, we're more likely to modify the
outputs hash than the inputs hash.</p>
<p>We usually have just a single input on a CHECKTEMPLATEVERIFY script, which would suggest that it
does not make sense for input index to be the last field. However, given the desirability of being
able to express a &quot;don't care&quot; index easily (e.g., for decentralized kickstarter-type transactions),
this value is placed last.</p>
<h3>Design Tradeoffs and Risks</h3>
<p>CHECKTEMPLATEVERIFY's design limits script authors to relatively precise template matching. The
structure of CHECKTEMPLATEVERIFY template is such that most of the transaction details must be known
exactly at the time of construction, with the exception of the inputs.</p>
<p>CHECKTEMPLATEVERIFY can be nested -- that is, a transaction that is created by spending an output with a
<code>&lt;H&gt; OP_CHECKTEMPLATEVERIFY</code> restriction may create outputs with <code>&lt;X&gt; OP_CHECKTEMPLATEVERIFY</code> restrictions.
This expansion is inherently finite, as re-creating an output with a script containing the hash <code>&lt;H&gt;</code> from a transaction
spending an output with the hash <code>&lt;H&gt;</code> creates a hash cycle. This can also be thought of as each template hash <code>&lt;H&gt;</code> having
a &quot;path height&quot; of the longest chain of possible unbroken <code>OP_CHECKTEMPLATEVERIFY</code> verifying transactions, and the path height is
strictly decreasing.</p>
<p>Furthermore, templates are restricted to be spendable as a known number of inputs only and
at a specific input index, preventing unintentional introduction of the 'half spend' problem.</p>
<p>Templates, as restricted as they are, bear some risks.</p>
<h4>Denial of Service and Validation Costs</h4>
<p>CTV is designed to be able to be validated very cheaply without introducing DoS, either by checking a
precomputed hash or computing a hash of fixed length arguments (some of which may be cached from more
expensive computations).</p>
<p>In particular, CTV requires that clients cache the computation of a hash over all the scriptSigs, sequences,
and outputs. Before CTV, the hash of the scriptSigs was not required. CTV also requires that the presence of
any non-empty scriptSig be hashed, but this can be handled as a part of the scriptSigs hash.</p>
<p>As such, evaluating a CTV hash during consensus is always O(1) computation when the caches are available.
These caches usually must be available due to similar issues in CHECKSIG behavior. Computing the caches
is O(T) (the size of the transaction).</p>
<p>An example of a script that could experience a DoS issue without caching is:</p>
<pre><code>    &lt;H&gt; CTV CTV CTV... CTV
</code></pre>
<p>Such a script would cause the interpreter to compute hashes (supposing N CTV's) over O(N*T) data.
If the scriptSigs non-nullity is not cached, then the O(T) transaction could be scanned over O(N)
times as well (although cheaper than hashing, still a DoS). As such, CTV caches hashes and computations
over all variable length fields in a transaction.</p>
<p>For CTV, the Denial-of-Service exposure and validation costs are relatively clear. Implementers must be careful
to correctly code CTV to make use of existing caches and cache the (new for CTV) computations over scriptSigs.
Other more flexible proposals may have a more difficult time solving DoS issues as more complex template computations may
be less cacheable and expose issues around quadratic hashing, it is a tradeoff CTV makes in favor of cheap and secure
validation at the expense of flexibility. For example, if CTV allowed the hashing only select outputs by a bitmask,
caching of all combinations of outputs would not be possible and would cause a quadratic hashing DoS vulnerability.</p>
<h4>Permanently Unspendable Outputs</h4>
<p>The preimage argument passed to CHECKTEMPLATEVERIFY may be unknown or otherwise unsatisfiable.
However, requiring knowledge that an address is spendable from is incompatible with sender's ability
to spend to any address (especially, OP_RETURN). If a sender needs to know the template can be spent
from before sending, they may request a signature of a provably non-transaction challenge string
from the leaves of the CHECKTEMPLATEVERIFY tree.</p>
<h4>Forwarding Addresses</h4>
<p>Key-reuse with CHECKTEMPLATEVERIFY may be used as a form of &quot;forwarding address contract&quot;.
A forwarding address is an address which can automatically execute in a predefined way.
For example, an exchange's hot wallet might use an address which can automatically be moved to a cold
storage address after a relative timeout.</p>
<p>The issue is that reusing addresses in this way can lead to loss of funds.
Suppose one creates a template address which forwards 1 BTC to cold storage.
Creating an output to this address with less than 1 BTC will be frozen permanently.
Paying more than 1 BTC will lead to the funds in excess of 1BTC to be paid as a large miner fee.
CHECKTEMPLATEVERIFY could commit to the exact amount of bitcoin provided by the inputs/amount of fee
paid, but as this is a user error and not a malleability issue this is not done.
Future soft-forks could introduce opcodes which allow conditionalizing which template or script
branches may be used based on inspecting the amount of funds available in a transaction</p>
<p>As a general best practice, it is incumbent on Bitcoin users to not reuse any address unless you are
certain that the address is acceptable for the payment attempted. This limitation and risk is not
unique to CHECKTEMPLATEVERIFY. For example, atomic swap scripts are single use once the hash is
revealed. Future Taproot scripts may contain many logical branches that would be unsafe for being
spent to multiple times (e.g., a Hash Time Lock branch should be instantiated with unique hashes
each time it is used). Keys which have signed a SIGHASH_ANYPREVOUT transaction can similarly become
reuse-unsafe.</p>
<p>Because CHECKTEMPLATEVERIFY commits to the input index currently being spent, reused-keys are
guaranteed to execute in separate transactions which reduces the risk of &quot;half-spend&quot; type issues.</p>
<h4>NOP-Default and Recommended Standardness Rules</h4>
<p>If the argument length is not exactly 32, CHECKTEMPLATEVERIFY treats it as a NOP during
consensus validation. Implementations are recommended to fail in such circumstances during non-consensus
relaying and mempool validation. In particular, making an invalid-length argument a failure aids future
soft-forks upgrades to be able to rely on the tighter standard restrictions to safely loosen
the restrictions for standardness while tightening them for consensus with the upgrade's rules.</p>
<p>The standardness rules may lead an unscrupulous script developer to accidentally rely on the
stricter standardness rules to be enforced during consensus. Should that developer submit a
transaction directly to the network relying on standardness rejection, a standardness-invalid but
consensus-valid transaction may be caused, leading to a potential loss of funds.</p>
<h4>Feature Redundancy</h4>
<p>There are other opcodes that, if implemented, could make the CHECKTEMPLATEVERIFY's functionality redundant.
However, given CHECKTEMPLATEVERIFY's simple semantics and low on chain cost it's likely that it
would continue to be favored even if redundant with other capabilities. Or, in the case of opcodes
such as OP_VAULT, OP_CHECKCONTRACTVERIFY, and OP_TXHASH, OP_CHECKTEMPLATEVERIFY is a part of their
currently proposed implementations.</p>
<p>More powerful opcodes, like OP_COV proposed in MES16 or OP_TXHASH, would also bring some benefits in terms of
improving the ability to pay fees endogenously rather than relying on exogenous child-pays-for-parent or
other fee paying mechanisms such as transaction sponsors. However, these features come at substantially
increased complexity and room for behaviors unintended by the application developer.</p>
<p>Alternatively, SIGHASH_ANYPREVOUTANYSCRIPT can be used to implement something similar to templates,
via a scriptPubKey like:</p>
<pre><code>    &lt;sig of desired TX with PK and fixed nonce R || SIGHASH_ANYPREVOUTANYSCRIPT &lt;PK with public SK&gt; OP_CHECKSIG
</code></pre>
<p>SIGHASH_ANYPREVOUTANYSCRIPT capabilities
above are similar to what CHECKTEMPLATEVERIFY offers. The key functional
difference between SIGHASH_ANYPREVOUTANYSCRIPT and OP_CHECKTEMPLATEVERIFY is
that OP_CHECKTEMPLATEVERIFY restricts the number of additional inputs and
precludes dynamically determined change outputs while
SIGHASH_ANYPREVOUTANYSCRIPT can be combined with SIGHASH_SINGLE or
SIGHASH_ANYONECANPAY. For the additional inputs, OP_CHECKTEMPLATEVERIFY also
commits to the scriptsig and sequence, which allows for specifying specific P2SH
scripts (or segwit v0 P2SH) which have some use cases. Furthermore,
CHECKTEMPLATEVERIFY has benefits in terms of script size (depending on choice of
PK, SIGHASH_ANYPREVOUTANYSCRIPT may use about 2x-3x the bytes) and verification
speed, as OP_CHECKTEMPLATEVERIFY requires only hash computation rather than
signature operations. This can be significant when constructing large payment
trees or programmatic compilations. CHECKTEMPLATEVERIFY also has a feature-wise
benefit in that it provides a robust pathway for future template upgrades, as proposed
in OP_TXHASH.</p>
<p>OP_CHECKSIGFROMSTACKVERIFY along with OP_CAT may also be used to emulate
CHECKTEMPLATEVERIFY. However such constructions are more complicated to implement in application
scripts than CHECKTEMPLATEVERIFY, and encumber additional verification overhead absent
from CHECKTEMPLATEVERIFY.</p>
<p>Given the simplicity of this approach to implement and analyze, and the benefits realizable by user
applications, CHECKTEMPLATEVERIFY's single template based approach is proposed in lieu of a generalized
system for specifying transactions in script.</p>
<h4>Future Upgrades</h4>
<p>This section describes updates to OP_CHECKTEMPLATEVERIFY that are possible in
the future as well as synergies with other possible upgrades.</p>
<h5>CHECKTEMPLATEVERIFY Versions</h5>
<p>OP_CHECKTEMPLATEVERIFY currently only verifies properties of 32 byte arguments.
In the future, meaning could be ascribed to other length arguments. For
example, a 33-byte argument could just the last byte as a control program. In
that case, DefaultCheckTemplateVerifyHash could be computed when the flag byte
is set to CTVHASH_ALL. Other programs could be added similar to a SIGHASH_TYPE.
For example, CTVHASH_GROUP could read data from the Taproot Annex for
compatibility with SIGHASH_GROUP type proposals and allow dynamic malleability
of which indexes get hashed for bundling.</p>
<p>The work done for the OP_TXHASH pre-BIP details one approach to upgrading the
OP_CHECKTEMPLATEVERIFY semantics.</p>
<h5>OP_CHECKSIGFROMSTACKVERIFY</h5>
<p>Were both OP_CHECKTEMPLATEVERIFY and OP_CHECKSIGFROMSTACKVERIFY to be added to
Bitcoin, it would be possible to implement a variant of LN-Symmetry's floating
transactions using the following script:</p>
<pre><code>    witness(S+n): &lt;sig&gt; &lt;H(tx with nLockTime S+n paying to program(S+n))&gt;
    program(S): OP_CHECKTEMPLATEVERIFY &lt;musig_key(pk_update_a, pk_update_b)&gt; OP_CHECKSIGFROMSTACKVERIFY &lt;S+1&gt; OP_CHECKLOCKTIMEVERIFY
</code></pre>
<p>Compared to SIGHASH_ANYPREVOUTANYSCRIPT, because OP_CHECKTEMPLATEVERIFY does not
allow something similar to SIGHASH_ANYONECANPAY or SIGHASH_SINGLE, protocol
implementers might sign transactions with Ephemeral Anchors or additional Inputs
for paying fees or an alternative such as transaction sponsors might be considered.</p>
<p>Note that this use of OP_CHECKSIGFROMSTACKVERIFY and OP_CHECKTEMPLATEVERIFY, without the <code>&lt;S+1&gt; OP_CHECKLOCKTIMEVERIFY</code> ratchet,
enables a form of self-reproducing automata address with a one-time-trusted-setup, albeit with limited utility given the specifics
of OP_CHECKTEMPLATEVERIFY's DefaultCheckTemplateVerifyHash. In comparison, SIGHASH_ANYPREVOUT enables a more
powerful self-reproducing automata (colloquially called SpookChains), that uses a variety of combinations of SIGHASH flags
to be able to restrict state transitions based on amount.</p>
<h5>OP_AMOUNTVERIFY</h5>
<p>An opcode which verifies the exact amount that is being spent in the
transaction, the amount paid as fees, or made available in a given output could
be used to make safer OP_CHECKTEMPLATEVERIFY addresses. For instance, if the
OP_CHECKTEMPLATEVERIFY program P expects exactly S satoshis, sending S-1
satoshis would result in a frozen UTXO and sending S+n satoshis would result in
n satoshis being paid to fee. A range check could restrict the program to only
apply for expected values and default to a keypath otherwise, e.g.:</p>
<pre><code>    IF OP_AMOUNTVERIFY &lt;N&gt; OP_GREATER &lt;PK&gt; CHECKSIG ELSE &lt;H&gt; OP_CHECKTEMPLATEVERIFY
</code></pre>
<h5>OP_CAT/OP_SHA256STREAM</h5>
<p>OP_CHECKTEMPLATEVERIFY is (as described in the Ordering of Fields section)
efficient for specifying transactions dynamically from script should Bitcoin get enhanced
data manipulation opcodes.</p>
<p>As an example, the following code checks an input index argument and
concatenates it to the template and checks the template matches the transaction.</p>
<pre><code>    OP_SIZE 4 OP_EQUALVERIFY
    &lt;nVersion || nLockTime || input count || sequences hash || output count || outputs hash&gt;
    OP_SWAP OP_CAT OP_SHA256 OP_CHECKTEMPLATEVERIFY
</code></pre>
<p>Note that were OP_CAT to be introduced with a size limit, e.g. 520 bytes, one would be limited
to use it to introspect transactions with 12 inputs and 12 outputs (depending on script type).</p>
<h2> Backwards Compatibility </h2>
<p>OP_CHECKTEMPLATEVERIFY replaces a OP_NOP4 with stricter verification semantics. Therefore, scripts
which previously were valid will cease to be valid with this change. Stricter verification semantics
for an OP_NOP are a soft fork, so existing software will be fully functional without upgrade except
for mining and block validation. Similar soft forks for OP_CHECKSEQUENCEVERIFY and OP_CHECKLOCKTIMEVERIFY
(see BIP-0065 and BIP-0112) have similarly changed OP_NOP semantics without introducing compatibility issues.</p>
<p>In contrast to previous forks, OP_CHECKTEMPLATEVERIFY's reference implementation does not allow transactions with spending
scripts using it to be accepted to the mempool or relayed under standard policy until the new rule is active. Other implementations
are recommended to follow this rule as well, but not required.</p>
<p>Older wallet software will be able to accept spends from OP_CHECKTEMPLATEVERIFY outputs, but will
require an upgrade in order to treat PayToBareDefaultCheckTemplateVerifyHash chains with a confirmed ancestor as
being &quot;trusted&quot; (i.e., eligible for spending before the transaction is confirmed).</p>
<p>Backports of OP_CHECKTEMPLATEVERIFY can be trivially prepared (see the reference implementation)
for older node versions that can be patched but not upgraded to a newer major release.</p>
<h2> Script Compatibility </h2>
<p>OP_CHECKTEMPLATEVERIFY is made available in all script versions. Application developers should
note that P2SH and P2SH Segwit, which reveal the program in the scriptSig, may not use <code>&lt;H&gt; CTV</code>
like fragments in their program as the scriptSig commitment creates a hash cycle.</p>
<h2> References </h2>
<ul>
<li><a href="https://utxos.org" target="_blank">utxos.org informational site</a></li>
<li><a href="https://covenants.info" target="_blank">covenant informational site</a></li>
<li><a href="https://learn.sapio-lang.org" target="_blank">Sapio Bitcoin smart contract language</a></li>
<li><a href="https://rubin.io/advent21" target="_blank">27 Blog Posts on building smart contracts with Sapio and CTV, including examples described here.</a></li>
<li><a href="https://www.youtube.com/watch?v=YxsjdIl0034&t=2451" target="_blank">Scaling Bitcoin Presentation</a></li>
<li><a href="https://bitcoinops.org/en/newsletters/2019/05/29/" target="_blank">Optech Newsletter Covering OP_CHECKOUTPUTSHASHVERIFY</a></li>
<li><a href="https://rubin.io/public/pdfs/multi-txn-contracts.pdf" target="_blank">Structuring Multi Transaction Contracts in Bitcoin</a></li>
<li><a href="https://github.com/jeremyrubin/lazuli" target="_blank">Lazuli Notes (ECDSA based N-of-N Signatures for Certified Post-Dated UTXOs)</a></li>
<li><a href="https://web.archive.org/web/20220203124718/https://fc16.ifca.ai/bitcoin/papers/MES16.pdf" target="_blank">Bitcoin Covenants</a></li>
<li><a href="https://bitcointalk.org/index.php?topic=278122.0" target="_blank">CoinCovenants using SCIP signatures, an amusingly bad idea.</a></li>
<li><a href="https://fc17.ifca.ai/bitcoin/papers/bitcoin17-final28.pdf" target="_blank">Enhancing Bitcoin Transactions with Covenants</a></li>
<li><a href="https://github.com/jamesob/simple-ctv-vault" target="_blank">Simple CTV Vaults</a></li>
<li><a href="https://github.com/kanzure/python-vaults" target="_blank">Python Vaults</a></li>
<li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019808.html" target="_blank">CTV Dramatically Improves DLCs</a></li>
<li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020225.html" target="_blank">Calculus of Covenants</a></li>
<li><a href="https://rubin.io/bitcoin/2021/12/10/advent-13/" target="_blank">Payment Pools with CTV</a></li>
<li><a href="https://rubin.io/bitcoin/2021/12/11/advent-14/" target="_blank">Channels with CTV</a></li>
<li><a href="https://rubin.io/bitcoin/2021/12/09/advent-12/" target="_blank">Congestion Control with CTV</a></li>
<li><a href="https://rubin.io/bitcoin/2021/12/07/advent-10/" target="_blank">Building Vaults on Bitcoin</a></li>
<li><a href="https://arkdev.info/" target="_blank">(Ark Labs) Ark Documentation</a></li>
<li><a href="https://docs.second.tech/protocol/intro/" target="_blank">(Second) Ark Documentation</a></li>
<li><a href="https://rubin.io/bitcoin/2022/09/14/drivechain-apo/" target="_blank">SpookChains</a></li>
<li><a href="https://github.com/bitcoin/bips/pull/1500" target="_blank">OP_TXHASH</a></li>
</ul>
<h3>Note on Similar Alternatives</h3>
<p>An earlier version of CHECKTEMPLATEVERIFY, CHECKOUTPUTSHASHVERIFY, is withdrawn
in favor of CHECKTEMPLATEVERIFY. CHECKOUTPUTSHASHVERIFY did not commit to the
version or lock time and was thus insecure.</p>
<p>CHECKTEMPLATEVERIFY could also be implemented as an extension to Taproot, and was
proposed this way earlier. However, particular applications may want to use OP_CHECKTEMPLATEVERIFY
in bare legacy scripts to maximize efficiency.</p>
<p>CHECKTEMPLATEVERIFY has also been previously referred to as OP_SECURETHEBAG, which is mentioned here
to aid in searching and referencing discussion on this BIP.</p>
<h2>Copyright</h2>
<p>This document is licensed under the 3-clause BSD license.</p>

        </article>
    </div>


            <hr class="border-slate-700" />

            <div data-pagefind-ignore class="w-full flex flex-col items-center space-y-2 text-center">
                <div class="flex items-center space-x-2">
                    <p class="font-bold">Updated</p>
                    <p class="font-bold">2025-11-02</p>
                </div>
                <p>See an issue with rendering or formatting? Submit an issue on <a href="https://github.com/nickmonad/bips.dev" target="_blank">GitHub</a></p>
                <p>Do you find this site useful? Please consider <a href="https://buy.tryspeed.com/plink_live_lyek4a2yW2Sn2wfA" target="_blank">donating</a> some sats to support ongoing development.</p>
                <p><a href="/">bips.dev</a> is presented by <a href="https://nickmonad.blog" target="_blank">nickmonad</a></p>
                <p class="pt-4 text-sm">All content is owned and licensed by the respective author(s). This website makes no claim of ownership.</p>
            </div>
        </div>
    </div>
</body>
</html>
