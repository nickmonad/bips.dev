<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Read BIPs like a pro." />
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="og:title" content="BIP 345: OP_VAULT" />
    <meta property="og:description" content="Read BIPs like a pro." />
    <meta property="og:image" content="https://bips.dev/og-bips-dev.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="BIP 345: OP_VAULT" />
    <meta name="twitter:description" content="Read BIPs like a pro." />
    <meta name="twitter:creator" content="@nickmonad" />
    <meta name="twitter:image" content="https://bips.dev/og-bips-dev.png" />

    <title>BIP 345: OP_VAULT</title>

    
        <link rel="stylesheet" href="/style.css" />
    

    <link rel="stylesheet" href="/pagefind/pagefind-ui.css" />
    <script src="/pagefind/pagefind-ui.js"></script>

    <script defer data-domain="bips.dev" src="/js/script.js"></script>
    <script>
        // setup plausible function for custom events
        window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }

        // setup and initialize dark mode
        // https://tailwindcss.com/docs/dark-mode
        window.setTheme = function() {
            if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark')
            } else {
                document.documentElement.classList.remove('dark')
            }
        }
        window.setTheme();

        // searching via
        // https://pagefind.app
        window.addEventListener('DOMContentLoaded', function(event) {
            new PagefindUI({
                element: "#search",
                hightlightParam: "highlight",
                showImages: false,
                showSubResults: true,
                translations: {
                    placeholder: "Search BIPs"
                },
                processTerm: function(term) {
                    plausible('Search');
                    return term;
                }
            });
        });
    </script>

    <style>
        /* variables to override on pagefind */
        /* https://pagefind.app/docs/ui-usage/#customising-the-styles */
        /* values are from tailwind: https://tailwindcss.com/docs/customizing-colors */
        :root {
            --pagefind-ui-primary: #334155;
            --pagefind-ui-text: #334155;
            --pagefind-ui-background: #ffffff;
            --pagefind-ui-border-width: 1px;
            --pagefind-ui-border-radius: 4px;
        }

        html.dark {
            --pagefind-ui-primary: #d1d5db;
            --pagefind-ui-text: #d1d5db;
            --pagefind-ui-background: #18181b;
            --pagefind-ui-border: #152028;
        }

        mark {
            background-color: #ff9900 !important;
            color: #6b7280 !important;
        }
    </style>
</head>

<body class="bg-white dark:bg-zinc-900">
    <div class="container mx-auto flex justify-center">
        <div data-pagefind-body class="min-w-full max-w-full lg:min-w-[1000px] lg:max-w-[1000px] px-6 py-10 space-y-10 text-slate-700 dark:text-gray-300">
            
    <div class="flex flex-col space-y-4 pt-4 md:pt-8">
        <div class="flex justify-between">
            <a href="/">Back to BIPs</a>
            <div class="flex">
                <svg id="toggleDark_light" class="hidden dark:flex w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'light'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
                </svg>
                <svg id="toggleDark_dark" class="flex dark:hidden w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'dark'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
                </svg>
            </div>
        </div>
        <div class="flex flex-col space-y-2">
            <div data-pagefind-weight="10" class="text-2xl font-extrabold">BIP 345: OP_VAULT</div>
            <div class="flex justify-between">
                <div class="text-xl font-semibold">2023-02-03</div>
                <a href="https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;blob&#x2F;master&#x2F;bip-0345.mediawiki" target="_blank">View on GitHub</a>
            </div>
        </div>

        <article class="max-w-none prose prose-lg prose-zinc prose-p:leading-relaxed prose-a:font-bold prose-a:underline prose-a:decoration-2 prose-a:decoration-bitcoin prose-pre:bg-zinc-200 prose-pre:text-zinc-800 dark:prose-invert dark:prose-pre:bg-zinc-600 dark:prose-pre:text-white">
            <pre><code>  BIP: 345
  Layer: Consensus (soft fork)
  Title: OP_VAULT
  Author: James O&#x27;Beirne &lt;vaults@au92.org&gt;
          Greg Sanders &lt;gsanders87@gmail.com&gt;
  Comments-URI: https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;wiki&#x2F;Comments:BIP-0345
  Status: Withdrawn
  Type: Standards Track
  Created: 2023-02-03
  License: BSD-3-Clause
  Post-History: 2023-01-09: https:&#x2F;&#x2F;lists.linuxfoundation.org&#x2F;pipermail&#x2F;bitcoin-dev&#x2F;2023-January&#x2F;021318.html [bitcoin-dev] OP_VAULT announcement
                2023-03-01: https:&#x2F;&#x2F;lists.linuxfoundation.org&#x2F;pipermail&#x2F;bitcoin-dev&#x2F;2023-March&#x2F;021510.html [bitcoin-dev] BIP for OP_VAULT
  Superseded-By: 443
</code></pre>
<h2> Introduction </h2>
<p>This BIP proposes two new tapscript opcodes that add consensus support for a specialized
covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with
<code>OP_CHECKTEMPLATEVERIFY</code>
(<a href="/119" target="_blank">BIP-0119</a>),
allow users to enforce a delay period before designated coins may be spent to
an arbitrary destination, with the exception of a prespecified &quot;recovery&quot; path.
At any time prior to final withdrawal, the coins can be spent to the
recovery path.</p>
<h3> Copyright </h3>
<p>This document is licensed under the 3-clause BSD license.</p>
<h3> Motivation </h3>
<p>The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to
significant effort to secure their private keys, and hope that once provisioned
their custody system does not yield to any number of evolving and
persistent threats. Users have little means to intervene once a compromise is
detected. This proposal introduces a mechanism that significantly
mitigates the worst-case outcome of key compromise: coin loss.</p>
<p>Introducing a way to intervene during unexpected spends allows users to
incorporate highly secure key storage methods or unusual fallback strategies
that are only exercised in the worst case, and which may otherwise be
operationally prohibitive. The goal of this proposal is to make this strategy
usable for custodians of any size with minimal complication.</p>
<h4> Example uses </h4>
<p>A common configuration for an individual custodying Bitcoin is &quot;single
signature and passphrase&quot; using a hardware wallet. A user with such a
configuration might be concerned about the risk associated with relying on a
single manufacturer for key management, as well as physical access to the
hardware.</p>
<p>This individual can use <code>OP_VAULT</code> to make use of a highly secure
key as the unlikely recovery path, while using their existing signing procedure
as the withdrawal trigger key with a configured spend delay of e.g. 1 day.</p>
<p>The recovery path key can be of a highly secure nature that might otherwise
make it impractical for daily use. For example, the key could be generated in
some analog fashion, or on an old computer that is then destroyed, with the
private key replicated only in paper form. Or the key could be a 2-of-3
multisig using devices from different manufacturers. Perhaps the key is
geographically or socially distributed.</p>
<p>Since it can be any Bitcoin script policy, the recovery key can include a
number of spending conditions, e.g. a time-delayed fallback to an &quot;easier&quot;
recovery method, in case the highly secure key winds up being <em>too</em> highly
secure.</p>
<p>The user can run software on their mobile device that monitors the blockchain
for spends of the vault outpoints. If the vaulted coins move in an unexpected
way, the user can immediately sweep them to the recovery path, but spending the
coins on a daily basis works in the same way it did prior to vaulting (aside
from the spend delay).</p>
<p>Institutional custodians of Bitcoin may use vaults in similar fashion.</p>
<h5> Provable timelocks </h5>
<p>This proposal provides a mitigation to the
<a href="https://web.archive.org/web/20230210123933/https://xkcd.com/538/" target="_blank">&quot;$5 wrench attack.&quot;</a> By
setting the spend delay to, say, a week, and using as the recovery path a
script that enforces a longer relative timelock, the owner of the vault can
prove that he is unable to access its value immediately. To the author's
knowledge, this is the only way to configure this defense without rolling
timelocked coins for perpetuity or relying on a trusted third party.</p>
<h2> Goals </h2>
<img src="bip-0345/vaults-Basic.png" />
<p>Vaults in Bitcoin have been discussed formally since 2016
(<a href="https://crypto.news/app/uploads/2016/08/MES16.pdf" target="_blank">MES16</a>) and informally since <a href="https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0" target="_blank">2014</a>. The value of
having a configurable delay period with recovery capability in light of an
unexpected spend has been widely recognized.</p>
<p>The only way to implement vaults given the existing consensus rules, aside from
[https://github.com/revault emulating vaults with large multisig
configurations], is to use presigned transactions created with a one-time-use
key. This approach was first demonstrated
<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html" target="_blank">in 2020</a>.</p>
<p>Unfortunately, this approach has a number of practical shortcomings:</p>
<ul>
<li>generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,</li>
<li>amounts and withdrawal patterns must be precommitted to,</li>
<li>there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,</li>
<li>the particular fee management technique or wallet must be decided upon vault creation,</li>
<li>coin loss follows if a vault address is reused,</li>
<li>the transaction data that represents the &quot;bearer asset&quot; of the vault must be stored for perpetuity, otherwise value is lost, and</li>
<li>the vault creation ceremony must be performed each time a new balance is to be deposited.</li>
</ul>
<p>The deployment of a &quot;precomputed&quot; covenant mechanism like
<a href="/119" target="_blank">OP_CHECKTEMPLATEVERIFY</a> or
<a href="/118" target="_blank">SIGHASH_ANYPREVOUT</a>
would both remove the necessity to use an ephemeral key, since the
covenant is enforced on-chain, and lessen the burden of sensitive data storage,
since the necessary transactions can be generated from a set of compact
parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in
2022].</p>
<p>However, the limitations of precomputation still apply: amounts,
destinations, and fee management are all fixed. Funds must flow through a fixed
intermediary to their final destination. Batch operations, which may be vital
for successful recovery during fee spikes or short spend delay, are not possible.</p>
<img src="bip-0345/withdrawal-comparison.drawio.png" />
<p>Having a &quot;general&quot; covenant mechanism that can encode arbitrary transactional
state machines would allow us to solve these issues, but at the cost of complex
and large scripts that would probably be duplicated many times over in the
blockchain. The particular design and deployment timeline of such a general
framework is also uncertain. This approach was demonstrated
<a href="https://blog.blockstream.com/en-covenants-in-elements-alpha/" target="_blank">in 2016</a>.</p>
<p>This proposal intends to address the problems outlined above by
providing a delay period/recovery path use with minimal transactional and
operational overhead using a specialized covenant.</p>
<p>The design goals of the proposal are:</p>
<ul>
<li>
<p><strong>efficient reuse of an existing vault configuration.</strong><sup id="cite_ref_1"><a href="#cite_ref_1">1</a></sup> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits.</p>
</li>
<li>
<p><strong>batched operations</strong> for recovery and withdrawal to allow managing multiple vault coins efficiently.</p>
</li>
<li>
<p><strong>unbounded partial withdrawals</strong>, which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.</p>
</li>
<li>
<p><strong>dynamic unvault targets</strong>, which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.</p>
</li>
<li>
<p><strong>dynamic fee management</strong> that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.</p>
</li>
</ul>
<p>These goals are accompanied by basic safety considerations (e.g. not being
vulnerable to mempool pinning) and a desire for concision, both in terms of the number
of outputs created as well as script sizes.</p>
<p>This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html" target="_blank">transaction sponsors</a>) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html" target="_blank">v3 transaction relay</a> and <a href="https://github.com/instagibbs/bips/blob/527b007dbf5b9a89895017030183370e05468ae6/bip-ephemeralanchors.mediawiki" target="_blank">ephemeral anchors</a>.</p>
<h2> Design </h2>
<p>In typical usage, a vault is created by encumbering coins under a
taptree <a href="/341" target="_blank">(BIP-341)</a>
containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that
facilitates the expected withdrawal process, and another leaf with
<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered
at any time prior to withdrawal finalization.</p>
<p>The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible
withdrawal by allowing a spending transaction to replace the
<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for
some parameters to be set at spend (trigger) time. All other leaves in the
taptree must be unchanged in the destination output, which preserves the recovery path as well as any
other spending conditions originally included in the vault. This is similar to
the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed
<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html" target="_blank">in 2021</a>.</p>
<p>These tapleaf replacement rules, described more precisely below, ensure a
timelocked withdrawal, where the timelock is fixed by the original
<code>OP_VAULT</code> parameters, to a fixed set of outputs (via
<code>OP_CHECKTEMPLATEVERIFY</code><sup id="cite_ref_2"><a href="#cite_ref_2">2</a></sup>) which is chosen when the withdrawal
process is triggered.</p>
<p>While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the
preferred method to bind the proposed withdrawal to a particular set of final
outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to
facilitate other kinds of withdrawal processes.</p>
<img src="bip-0345/opvault.drawio.png" />
<h3> Transaction types </h3>
<p>The vault has a number of stages, some of them optional:</p>
<ul>
<li>
<p><strong>vault transaction</strong>: encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.</p>
</li>
<li>
<p><strong>trigger transaction</strong>: spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial &quot;revault,&quot; which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.</p>
</li>
<li>
<p><strong>withdrawal transaction</strong>: spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.</p>
</li>
<li>
<p><strong>recovery transaction</strong>: spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified <em>recovery authorization</em> script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.</p>
</li>
</ul>
<h3> Fee management </h3>
<p>A primary consideration of this proposal is how fee management is handled.
Providing dynamic fee management is critical to the operation of a vault, since</p>
<ul>
<li>precalculated fees are prone to making transactions unconfirmable in high fee environments, and</li>
<li>a fee wallet that is prespecified might be compromised or lost before use.</li>
</ul>
<p>But dynamic fee management can introduce
<a href="https://bitcoinops.org/en/topics/transaction-pinning/" target="_blank">pinning vectors</a>. Care
has been taken to avoid unnecessarily introducing these vectors when using the new
destination-based spending policies that this proposal introduces.</p>
<p>Originally, this proposal had a hard dependency on reformed transaction
nVersion=3 policies, including ephemeral anchors, but it has since been revised
to simply benefit from these changes in policy as well as other potential fee
management mechanisms.</p>
<h2> Specification </h2>
<p>The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and
<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules
to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,
respectively.</p>
<h3> <code>OP_VAULT</code> evaluation </h3>
<p>When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,
<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:</p>
<pre><code>&lt;leaf-update-script-body&gt;
&lt;push-count&gt;
[ &lt;push-count&gt; leaf-update script data items ... ]
&lt;trigger-vout-idx&gt;
&lt;revault-vout-idx&gt;
&lt;revault-amount&gt;
</code></pre>
<p>where</p>
<ul>
<li>
<p><code>&lt;leaf-update-script-body&gt;</code> is a minimally-encoded data push of a serialized script. <sup id="cite_ref_3"><a href="#cite_ref_3">3</a></sup></p>
<ul>
<li>Otherwise, script execution MUST fail and terminate immediately.</li>
</ul>
</li>
<li>
<p><code>&lt;push-count&gt;</code> is an up to 4-byte minimally encoded <code>CScriptNum</code> indicating how many leaf-update script items should be popped off the stack. <sup id="cite_ref_4"><a href="#cite_ref_4">4</a></sup></p>
<ul>
<li>If this value does not decode to a valid CScriptNum, script execution MUST fail and terminate immediately.</li>
<li>If this value is less than 0, script execution MUST fail and terminate immediately.</li>
<li>If there are fewer than 3 items following the <code>&lt;push-count&gt;</code> items on the stack, script execution MUST fail and terminate immediately. In other words, after popping <code>&lt;leaf-update-script-body&gt;</code>, there must be at least <code>3 + &lt;push-count&gt;</code> items remaining on the stack.</li>
</ul>
</li>
<li>
<p>The following <code>&lt;push-count&gt;</code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code>&lt;leaf-update-script-body&gt;</code> to construct the expected tapleaf replacement script.</p>
</li>
<li>
<p><code>&lt;trigger-vout-idx&gt;</code> is an up to 4-byte minimally encoded <code>CScriptNum</code> indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.</p>
<ul>
<li>If this value does not decode to a valid CScriptNum, script execution MUST fail and terminate immediately.</li>
<li>If this value is less than 0 or is greater than or equal to the number of outputs, script execution MUST fail and terminate immediately.</li>
</ul>
</li>
<li>
<p><code>&lt;revault-vout-idx&gt;</code> is an up to 4-byte minimally encoded <code>CScriptNum</code> optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.</p>
<ul>
<li>If this value does not decode to a valid CScriptNum, script execution MUST fail and terminate immediately.</li>
<li>If this value is greater than or equal to the number of outputs, script execution MUST fail and terminate immediately.</li>
<li>If this value is negative and not equal to -1, script execution MUST fail and terminate immediately.<sup id="cite_ref_5"><a href="#cite_ref_5">5</a></sup></li>
</ul>
</li>
<li>
<p><code>&lt;revault-amount&gt;</code> is an up to 7-byte minimally encoded CScriptNum indicating the number of satoshis being revaulted.</p>
<ul>
<li>If this value does not decode to a valid CScriptNum, script execution MUST fail and terminate immediately.</li>
<li>If this value is not greater than or equal to 0, script execution MUST fail and terminate immediately.</li>
<li>If this value is non-zero but <code>&lt;revault-vout-idx&gt;</code> is negative, script execution MUST fail and terminate immediately.</li>
<li>If this value is zero but <code>&lt;revault-vout-idx&gt;</code> is not -1, script execution MUST fail and terminate immediately.</li>
</ul>
</li>
</ul>
<p>After the stack is parsed, the following validation checks are performed:</p>
<ul>
<li>Decrement the per-script sigops budget (see <a href="/342" target="_blank">user-content-Resource_limits BIP-0342</a>) by 60<sup id="cite_ref_6"><a href="#cite_ref_6">6</a></sup>; if the budget is brought below zero, script execution MUST fail and terminate immediately.</li>
<li>Let the output designated by <code>&lt;trigger-vout-idx&gt;</code> be called <em>triggerOut</em>.</li>
<li>If the scriptPubKey of <em>triggerOut</em> is not a version 1 witness program, script execution MUST fail and terminate immediately.</li>
<li>Let the script constructed by taking the <code>&lt;leaf-update-script-body&gt;</code> and prefixing it with minimally-encoded data pushes of the <code>&lt;push-count&gt;</code> leaf-update script data items be called the <em>leaf-update-script</em>.</li>
<li>If the scriptPubKey of <em>triggerOut</em> does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for <em>leaf-update-script</em>, script execution MUST fail and terminate immediately.
<ul>
<li>Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.</li>
</ul>
</li>
<li>Let the output designated by <code>&lt;revault-vout-idx&gt;</code> (if the index value is non-negative) be called <em>revaultOut</em>.</li>
<li>If the scriptPubKey of <em>revaultOut</em> is not equal to the scriptPubKey of the input being spent, script execution MUST fail and terminate immediately.</li>
<li>Implementation recommendation: if the sum of the amounts of <em>triggerOut</em> and <em>revaultOut</em> (if any) are not greater than or equal to the value of this input, script execution SHOULD fail and terminate immediately. This ensures that (at a minimum) the vaulted value for this input is carried through.
<ul>
<li>Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.</li>
</ul>
</li>
<li>Queue a deferred check<sup id="cite_ref_7"><a href="#cite_ref_7">7</a></sup> that ensures the satoshis for this input's <code>nValue</code> minus <code>&lt;revault-amount&gt;</code> are included within the output <code>nValue</code> found at <code>&lt;trigger-vout-idx&gt;</code>.</li>
<li>Queue a deferred check that ensures <code>&lt;revault-amount&gt;</code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code>&lt;revault-vout-idx&gt;</code>.
<ul>
<li>These deferred checks could be characterized in terms of the pseudocode below (in <em>Deferred checks</em>) as<br /><code>TriggerCheck(input_amount, &lt;revault-amount&gt;, &lt;trigger-vout-idx&gt;, &lt;revault-vout-idx&gt;)</code>.</li>
</ul>
</li>
</ul>
<p>If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.</p>
<h3> <code>OP_VAULT_RECOVER</code> evaluation </h3>
<p>When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,
<code>0xbc</code>), the expected format of the stack, shown top to bottom, is:</p>
<pre><code>&lt;recovery-sPK-hash&gt;
&lt;recovery-vout-idx&gt;
</code></pre>
<p>where</p>
<ul>
<li><code>&lt;recovery-sPK-hash&gt;</code> is a 32-byte data push.
<ul>
<li>If this is not 32 bytes in length, script execution MUST fail and terminate immediately.</li>
</ul>
</li>
<li><code>&lt;recovery-vout-idx&gt;</code> is an up to 4-byte minimally encoded <code>CScriptNum</code> indicating the index of the recovery output.
<ul>
<li>If this value does not decode to a valid CScriptNum, script execution MUST fail and terminate immediately.</li>
<li>If this value is less than 0 or is greater than or equal to the number of outputs, script execution MUST fail and terminate immediately.</li>
</ul>
</li>
</ul>
<p>After the stack is parsed, the following validation checks are performed:</p>
<ul>
<li>Let the output at index <code>&lt;recovery-vout-idx&gt;</code> be called <em>recoveryOut</em>.</li>
<li>Compute the scriptPubKey tagged hash for <em>recoveryOut</em> as <code>output-sPK-hash = tagged_hash(&quot;VaultRecoverySPK&quot;, CompactSize(len(recoveryOut.scriptPubKey)) || recoveryOut.scriptPubKey)</code>, where <code>tagged_hash()</code> is from the <a href="https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py" target="_blank">BIP-0340 reference code</a>.</li>
<li>If the <em>recoveryOut</em> <code>output-sPK-hash</code> is not equal to <code>&lt;recovery-sPK-hash&gt;</code>, script execution MUST fail and terminate immediately.
<ul>
<li>Implementation recommendation: if <em>recoveryOut</em> does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.</li>
</ul>
</li>
<li>Queue a deferred check that ensures the <code>nValue</code> of <em>recoveryOut</em> contains the entire <code>nValue</code> of this input.<sup id="cite_ref_8"><a href="#cite_ref_8">8</a></sup>
<ul>
<li>This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(&lt;recovery-vout-idx&gt;, input_amount)</code>.</li>
</ul>
</li>
</ul>
<p>If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.</p>
<h3> Deferred check evaluation </h3>
<p>Once all inputs for a transaction are validated per the rules above, any
deferred checks queued MUST be evaluated.</p>
<p>The Python pseudocode for this is as follows:</p>
<pre><code>class TriggerCheck:
    &quot;&quot;&quot;Queued by evaluation of OP_VAULT (withdrawal trigger).&quot;&quot;&quot;
    input_amount: int
    revault_amount: int
    trigger_vout_idx: int
    revault_vout_idx: int


class RecoveryCheck:
    &quot;&quot;&quot;Queued by evaluation of OP_VAULT_RECOVER.&quot;&quot;&quot;
    input_amount: int
    vout_idx: int


def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -&gt; bool:
    &quot;&quot;&quot;
    Ensure that all value from vault inputs being triggered or recovered is preserved
    in suitable output nValues.
    &quot;&quot;&quot;
    # Map to hold expected output values.
    out_map: Dict[int, int] = defaultdict(lambda: 0)

    for c in checks:
        if isinstance(c, TriggerCheck):
            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)

            if c.revault_amount &gt; 0:
                out_map[c.revault_vout_idx] += c.revault_amount

        elif isinstance(c, RecoveryCheck):
            out_map[c.vout_idx] += c.input_amount

    for (vout_idx, amount_sats) in out_map.items():
        # Trigger&#x2F;recovery value can be greater than the constituent vault input
        # amounts.
        if tx.vout[vout_idx].nValue &lt; amount_sats:
            return False

    return True
</code></pre>
<p>If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate
immediately.</p>
<p>This ensures that all compatible vault inputs can be batched into shared
corresponding trigger or recovery outputs while preserving their entire input value.</p>
<h2> Policy changes </h2>
<p>In order to prevent possible pinning attacks, recovery transactions must be replaceable.</p>
<ul>
<li>When validating an <code>OP_VAULT_RECOVER</code> input being spent, the script MUST fail (by policy, not consensus) and terminate immediately if both<sup id="cite_ref_9"><a href="#cite_ref_9">9</a></sup></li>
<li>the input is not marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per <a href="/125" target="_blank">BIP-0125</a>, and</li>
<li>the version of the recovery transaction has an nVersion other than 3.</li>
</ul>
<p>If the script containing <code>OP_VAULT_RECOVER</code> is 34 bytes or less<sup id="cite_ref_10"><a href="#cite_ref_10">10</a></sup>, let
it be called &quot;unauthorized,&quot; because there is no script guarding the recovery
process. In order to prevent pinning attacks in the case of unauthorized
recovery - since the spend of the input (and the structure of the
transaction) is not authorized by a signed signature message - the output structure of
unauthorized recovery transaction is limited.</p>
<ul>
<li>If the recovery is unauthorized, the recovery transaction MUST (by policy) abide by the following constraints:
<ul>
<li>If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.</li>
<li>If the spending transaction has two outputs, and the output which is not <em>recoveryOut</em> is not an <a href="https://github.com/instagibbs/bips/blob/527b007dbf5b9a89895017030183370e05468ae6/bip-ephemeralanchors.mediawiki" target="_blank">ephemeral anchor</a>, the script MUST fail and terminate immediately.<sup id="cite_ref_11"><a href="#cite_ref_11">11</a></sup></li>
</ul>
</li>
</ul>
<h2> Implementation </h2>
<p>A sample implementation is available on bitcoin-inquisition <a href="https://github.com/jamesob/bitcoin/tree/2023-02-opvault-inq" target="_blank">here</a>, with an associated <a href="https://github.com/bitcoin-inquisition/bitcoin/pull/21" target="_blank">pull request</a>.</p>
<h2> Applications </h2>
<p>The specification above, perhaps surprisingly, does not specifically cover how a relative timelocked withdrawal process with a fixed target is implemented. The tapleaf update semantics specified in <code>OP_VAULT</code> as well as the output-based authorization enabled by <code>OP_VAULT_RECOVER</code> can be used to implement a vault, but they are incomplete without two other pieces:</p>
<ul>
<li>a way to enforce relative timelocks, like <code>OP_CHECKSEQUENCEVERIFY</code>, and</li>
<li>a way to enforce that proposed withdrawals are ultimately being spent to a precise set of outputs, like <code>OP_CHECKTEMPLATEVERIFY</code>.</li>
</ul>
<p>These two pieces are combined with the tapleaf update capabilities of
<code>OP_VAULT</code> to create a vault, described below.</p>
<h3> Creating a vault </h3>
<p>In order to vault coins, they can be spent into a witness v1 <code>scriptPubKey</code>
that contains a taptree of the form</p>
<pre><code>tr(&lt;internal-pubkey&gt;,
  leaves = {
    recover:
      &lt;recovery-sPK-hash&gt; OP_VAULT_RECOVER,

    trigger:
      &lt;trigger-auth-pubkey&gt; OP_CHECKSIGVERIFY                     (i)
      &lt;spend-delay&gt; 2 $leaf-update-script-body OP_VAULT,          (ii)

    ... [ possibly other leaves ]
  }
)
</code></pre>
<p>where</p>
<ul>
<li><code>$leaf-update-script-body</code> is, for example, <code>OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKTEMPLATEVERIFY</code>.
<ul>
<li>This is one example of a trigger script, but <em>any</em> script fragment can be used, allowing the creation of different types of vaults. For example, you could use <code>OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKSIG</code> to do a time-delayed transfer of the coins to another key. This also future-proofs <code>OP_VAULT</code> for future scripting capabilities.</li>
</ul>
</li>
<li>The script fragment in <code>(i)</code> is called the &quot;trigger authorization,&quot; because it gates triggering the withdrawal. This can be done in whatever manner the wallet designer would like.</li>
<li>The script fragment in <code>(ii)</code> is the incomplete <code>OP_VAULT</code> invocation - it will be completed once the rest of the parameters (the CTV target hash, trigger vout index, and revault vout index) are provided by the trigger transaction witness.</li>
</ul>
<p>Typically, the internal key for the vault taproot output will be specified so
that it is controlled by the same descriptor as the recovery path, which
facilitates another (though probably unused) means of recovering the vault
output to the recovery path. This has the potential advantage of recovering the
coin without ever revealing it was a vault.</p>
<p>Otherwise, the internal key can be chosen to be an unspendable NUMS point to
force execution of the taptree contents.</p>
<h3> Triggering a withdrawal </h3>
<p>To make use of the vault, and spend it towards some output, we construct a spend
of the above <code>tr()</code> output that simply replaces the &quot;trigger&quot; leaf with the
full leaf-update script (in this case, a timelocked CTV script):</p>
<pre><code>Witness stack:

- &lt;revault-amount&gt;
- &lt;revault-vout-idx&gt; (-1 if none)
- &lt;trigger-vout-idx&gt;
- &lt;target-CTV-hash&gt;
- &lt;trigger-auth-pubkey-signature&gt;
- [ &quot;trigger&quot; leaf script contents ]
- [ taproot control block prompting a script-path spend to &quot;trigger&quot; leaf ]

Output scripts:

[
  tr(&lt;internal-pubkey&gt;,
    leaves = {
      recover:
        &lt;recovery-sPK-hash&gt; OP_VAULT_RECOVER,               &lt;--  unchanged

      trigger:
        &lt;target-CTV-hash&gt; &lt;spend-delay&gt;
        OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKTEMPLATEVERIFY  &lt;--  changed per the
                                                                    leaf-update
                                                                    rules of OP_VAULT
       ... [ possibly other leaves ]
     }
   ),

   [ optional revault output with the
     same sPK as the original vault output ],
]
</code></pre>
<p><code>OP_VAULT</code> has allowed the taptree to be transformed so that the trigger leaf
becomes a timelocked CTV script, which is what actually facilitates the announced
withdrawal. The withdrawal is interruptible by the recovery path because the
&quot;recover&quot; leaf is preserved exactly from the original taptree.</p>
<p>Note that the CTV hash is specified at spend time using the witness stack, and
&quot;locked in&quot; via the <code>OP_VAULT</code> spend rules which assert its existence in the output.</p>
<p>The vault funds can be recovered at any time prior to the spend of the
timelocked CTV script by way of a script-path spend using the &quot;recover&quot; leaf.</p>
<h3> Recovery authorization </h3>
<p>When configuring a vault, the user must decide if they want to have the
recovery process gated by a script fragment prefixing the
<code>OP_VAULT_RECOVER</code> instruction in the &quot;recover&quot; leaf. Its use
entails trade-offs.</p>
<h4> Unauthorized recovery </h4>
<p>Unauthorized recovery simplifies vault use in that recovery never requires additional information aside from the location of the vault outpoints and the recovery path - the &quot;authorization&quot; is simply the reveal of the recovery path, i.e. the preimage of <code>&lt;recovery-sPK-hash&gt;</code>.</p>
<p>But because this reveal is the only authorization necessary to spend the vault coins to recovery, the user must expect to recover all such vaults at once, since an observer can replay this recovery (provided they know the outpoints).</p>
<p>Additionally, unauthorized recovery across multiple distinct recovery paths
cannot be done in the same transaction, and fee control is more constrained:
because the output structure is limited for unauthorized recovery, fee
management relies either on inputs which are completely spent to fees or the
use of the optional ephemeral anchor and package relay.</p>
<p>These limitations are to avoid pinning attacks.</p>
<h4> Authorized recovery </h4>
<p>With authorized recovery, the user must keep track of an additional piece of information: how to solve the recovery authorization script fragment when recovery is required.</p>
<p>If this key is lost, the user will be unable to initiate the recovery process for their coins. If an attacker obtains the recovery key, they may grief the user during the recovery process by constructing a low fee rate recovery transaction and broadcasting it (though they will not be able to pin because of the replaceability requirement on recovery transactions).</p>
<p>However, authorized recovery configurations have significant benefits. Batched recoveries are possible for vaults with otherwise incompatible recovery parameters. Fee management is much more flexible, since authorized recovery transactions are &quot;free form&quot; and unrelated inputs and outputs can be added, potentially to handle fees.</p>
<h4> Recommendation: use a simple, offline recovery authorization key seed </h4>
<p>The benefits of batching and fee management that authorized recovery provides are significant. If the recovery authorization key falls into the hands of an attacker, the outcome is not catastrophic, whereas if the user loses their recovery authorization key as well as their trigger key, the result is likely coin loss. Consequently, the author's recommendation is to use a simple seed for the recovery authorization key that can be written down offline and replicated.</p>
<p>Note that the recovery authorization key <strong>is not</strong> the recovery path key, and
this is <strong>much different</strong> than any recommendation on how to generate the
recovery path key itself.</p>
<h3> Address reuse and recovery </h3>
<p>When creating a vault, four factors affect the resulting P2TR address:</p>
<ol>
<li>The internal pubkey (likely belonging to the recovery wallet)</li>
<li>The recovery leaf</li>
<li>The trigger leaf</li>
<li>Any other leaves that exist in the taptree</li>
</ol>
<p>The end user has the option of varying certain contents along descriptors in
order to avoid reusing vault addresses without affecting key management, e.g.
the trigger authorization pubkeys.</p>
<p>Note that when using unauthorized recovery, the reveal of the
recovery scriptPubKey will allow any observer to initiate the recovery process
for any vault with matching recovery params, provided they are able to locate
the vault outpoints. As a result, it is recommended to expect that
<strong>all outputs sharing an identical unauthorized <code>&lt;recovery-sPK-hash&gt;</code> should be recovered together</strong>.</p>
<p>This situation can be avoided with a comparable key management model by varying
the generation of each vault's recovery scriptPubKey along a single descriptor,
but note that this will prevent recovering multiple separate vaults into a single
recovery output.</p>
<p>Varying the internal pubkey will prevent batching the trigger of multiple vault
inputs into a single trigger output; consequently it is recommended that users
instead vary some component of the trigger leaf script if address reuse is
undesirable. Users could vary the trigger pubkey along a descriptor, keeping
the recovery path and internal-pubkey the same, which both avoids reusing
addresses and allows batched trigger and recovery operations.</p>
<h4> Recommendation: generate new recovery addresses for new trigger keys </h4>
<p>If using unauthorized recovery, it is recommended that you do not share recovery scriptPubKeys
across separate trigger keys. If one trigger key is compromised, that will necessitate the (unauthorized)
recovery of all vaults with that trigger key, which will reveal the recovery path preimage. This
means that an observer might be able to initiate recovery for vaults controlled by an uncompromised
trigger key.</p>
<h4> Fee management </h4>
<p>Fees can be managed in a variety of ways, but it's worth noting that both
trigger and recovery transactions must preserve the total value of vault
inputs, so vaulted values cannot be repurposed to pay for fees. This does not
apply to the withdrawal transaction, which can allocate value arbitrarily.</p>
<p>In the case of vaults that use recovery authorization, all transactions can
&quot;bring their own fees&quot; in the form of unrelated inputs and outputs. These
transactions are also free to specify ephemeral anchors, once the related relay
policies are deployed. This means that vaults using recovery authorization have
no dependence on the deploy of v3 relay policy.</p>
<p>For vaults using unauthorized recovery, the recovery
transaction relies on the use of either fully-spent fee inputs or an ephemeral
anchor output. This means that vaults which do not use recovery authorization
are essentially dependent on v3 transaction relay policy being deployed.</p>
<h3> Batching </h3>
<h4> During trigger </h4>
<p><code>OP_VAULT</code> outputs with the same taptree, aside from slightly
different trigger leaves, can be batched together in the same withdrawal
process. Two &quot;trigger&quot; leaves are compatible if they have the same
<code>OP_VAULT</code> arguments.</p>
<p>Note that this allows the trigger authorization -- the script prefixing the
<code>OP_VAULT</code> invocation -- to differ while still allowing batching.</p>
<p>Trigger transactions can act on multiple incompatible <code>OP_VAULT</code>
input sets, provided each set has a suitable associated <em>triggerOut</em>
output.</p>
<p>Since <code>SIGHASH_DEFAULT</code> can be used to sign the trigger
authorization, unrelated inputs and outputs can be included, possibly to
facilitate fee management or the batch withdrawal of incompatible vaults.</p>
<h4> During withdrawal </h4>
<p>During final withdrawal, multiple trigger outputs can be used towards the same
withdrawal transaction provided that they share identical
<code>&lt;target-CTV-hash&gt;</code> parameters. This facilitates batched
withdrawals.</p>
<h4> During recovery </h4>
<p><code>OP_VAULT_RECOVER</code> outputs with the same <code>&lt;recovery-sPK-hash&gt;</code>
can be recovered into the same output.</p>
<p>Recovery-incompatible vaults which have authorized recovery can be recovered in
the same transaction, so long as each set (grouped by
<code>&lt;recovery-sPK-hash&gt;</code>) has an associated <em>recoveryOut</em>. This allows
unrelated recoveries to share common fee management.</p>
<h3> Watchtowers </h3>
<p>The value of vaults is contingent upon having monitoring in place that will
alert the owner when unexpected spends are taking place. This can be done in a
variety of ways, with varying degrees of automation and trust in the
watchtower.</p>
<p>In the maximum-trust case, the watchtower can be fully aware of all vaulted
coins and has the means to initiate the recovery process if spends are not
pre-reported to the watchtower.</p>
<p>In the minimum-trust case, the user can supply a probabilistic filter of which
coins they wish to monitor; the watchtower would then alert the user if any
coins matching the filter move, and the user would be responsible for ignoring
false positives and handling recovery initiation.</p>
<h3> Output descriptors </h3>
<p>Output descriptors for vault-related outputs will be covered in a subsequent BIP.</p>
<h2> Deployment </h2>
<p>Activation mechanism is to be determined.</p>
<p>This BIP should be deployed concurrently with BIP-0119 to enable full use of vaults.</p>
<h2> Backwards compatibility </h2>
<p><code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code> replace, respectively,
the witness v1-only opcodes OP_SUCCESS187 and OP_SUCCESS188 with stricter
verification semantics. Consequently, scripts using those opcodes which
previously were valid will cease to be valid with this change.</p>
<p>Stricter verification semantics for an OP_SUCCESSx opcode are a soft fork, so
existing software will be fully functional without upgrade except for mining
and block validation.</p>
<p>Backwards compatibility considerations are very comparable to previous
deployments for OP_CHECKSEQUENCEVERIFY and OP_CHECKLOCKTIMEVERIFY (see
<a href="/65" target="_blank">BIP-0065</a> and
<a href="/112" target="_blank">BIP-0112</a>).</p>
<h2> Rationale </h2>
<ol>
<li><a href="https://bips.dev/345/#cite_ref_1">^</a> <strong>Why does this support address reuse?</strong> The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</li>
<li><a href="https://bips.dev/345/#cite_ref_2">^</a> <strong>Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?</strong> During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code>&lt;leaf-update-script-body&gt;</code> with no changes.</li>
<li><a href="https://bips.dev/345/#cite_ref_3">^</a> In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</li>
<li><a href="https://bips.dev/345/#cite_ref_4">^</a> <strong>Why only prefix with data pushes?</strong> Prefixing the <code>leaf-update-script-body</code> with opcodes opens up the door to prefix OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</li>
<li><a href="https://bips.dev/345/#cite_ref_5">^</a> <strong>Why is -1 the only allowable negative value for revault-vout-idx?</strong> A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</li>
<li><a href="https://bips.dev/345/#cite_ref_6">^</a> <strong>Why is the sigops cost for OP_VAULT set to 60?</strong> To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</li>
<li><a href="https://bips.dev/345/#cite_ref_7">^</a> <strong>What is a deferred check and why does this proposal require them for correct script evaluation?</strong> A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an &quot;aggregating&quot; set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</li>
<li><a href="https://bips.dev/345/#cite_ref_8">^</a> <strong>How do recovery transactions pay for fees?</strong> If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</li>
<li><a href="https://bips.dev/345/#cite_ref_9">^</a> <strong>Why are recovery transactions required to be replaceable?</strong> In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a &quot;rebundled&quot; version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule  3 griefed in the process.</li>
<li><a href="https://bips.dev/345/#cite_ref_10">^</a> 34 bytes is the length of a recovery script that consists solely of <code>&lt;recovery-sPK-hash&gt; OP_VAULT_RECOVER</code>.</li>
<li><a href="https://bips.dev/345/#cite_ref_11">^</a> <strong>Why can unauthorized recoveries only process a single recovery path?</strong> Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</li>
</ol>
<h2> References </h2>
<ul>
<li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012470.html" target="_blank">[bitcoin-dev] Bitcoin Vaults (2016)</a></li>
<li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html" target="_blank">[bitcoin-dev] Simple lock/unlock mechanism (2018)</a></li>
<li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html" target="_blank">[bitcoin-dev] On-chain vaults prototype (2020)</a></li>
<li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html" target="_blank">[bitcoin-dev] TAPLEAF_UPDATE_VERIFY covenant opcode (2021)</a></li>
<li><a href="https://arxiv.org/abs/2005.11776" target="_blank">Custody Protocols Using Bitcoin Vaults (2020)</a></li>
<li><a href="https://jameso.be/vaults.pdf" target="_blank">Vaults and Covenants (2023)</a></li>
</ul>
<h2> Acknowledgements </h2>
<p>The author would like to thank</p>
<ul>
<li>AJ Towns and Greg Sanders for discussion, numerous suggestions that improved the proposal, and advice.</li>
<li>Jeremy Rubin for inspiration, advice, and mentorship.</li>
<li>BL for discussion and insight.</li>
<li>John Moffett for early feedback and a test case demonstrating a recursive script evaluation attack.</li>
<li>Johan Halseth for providing conceptual review and pointing out a pinning attack.</li>
<li>Pieter Wuille for implementation advice.</li>
</ul>

        </article>
    </div>


            <hr class="border-slate-700" />

            <div data-pagefind-ignore class="w-full flex flex-col items-center space-y-2 text-center">
                <div class="flex items-center space-x-2">
                    <p class="font-bold">Updated</p>
                    <p class="font-bold">2025-11-02</p>
                </div>
                <p>See an issue with rendering or formatting? Submit an issue on <a href="https://github.com/nickmonad/bips.dev" target="_blank">GitHub</a></p>
                <p>Do you find this site useful? Please consider <a href="https://buy.tryspeed.com/plink_live_lyek4a2yW2Sn2wfA" target="_blank">donating</a> some sats to support ongoing development.</p>
                <p><a href="/">bips.dev</a> is presented by <a href="https://nickmonad.blog" target="_blank">nickmonad</a></p>
                <p class="pt-4 text-sm">All content is owned and licensed by the respective author(s). This website makes no claim of ownership.</p>
            </div>
        </div>
    </div>
</body>
</html>
