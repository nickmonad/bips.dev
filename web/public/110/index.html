<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Read BIPs like a pro." />
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="og:title" content="BIP 110: Reduced Data Temporary Softfork" />
    <meta property="og:description" content="Read BIPs like a pro." />
    <meta property="og:image" content="https://bips.dev/og-bips-dev.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="BIP 110: Reduced Data Temporary Softfork" />
    <meta name="twitter:description" content="Read BIPs like a pro." />
    <meta name="twitter:creator" content="@nickmonad" />
    <meta name="twitter:image" content="https://bips.dev/og-bips-dev.png" />

    <title>BIP 110: Reduced Data Temporary Softfork</title>

    
        <link rel="stylesheet" href="/style.css" />
    

    <link rel="stylesheet" href="/pagefind/pagefind-ui.css" />
    <script src="/pagefind/pagefind-ui.js"></script>

    <script defer data-domain="bips.dev" src="/js/script.js"></script>
    <script>
        // setup plausible function for custom events
        window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }

        // setup and initialize dark mode
        // https://tailwindcss.com/docs/dark-mode
        window.setTheme = function() {
            if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark')
            } else {
                document.documentElement.classList.remove('dark')
            }
        }
        window.setTheme();

        // searching via
        // https://pagefind.app
        window.addEventListener('DOMContentLoaded', function(event) {
            new PagefindUI({
                element: "#search",
                hightlightParam: "highlight",
                showImages: false,
                showSubResults: true,
                translations: {
                    placeholder: "Search BIPs"
                },
                processTerm: function(term) {
                    plausible('Search');
                    return term;
                }
            });
        });
    </script>

    <style>
        /* variables to override on pagefind */
        /* https://pagefind.app/docs/ui-usage/#customising-the-styles */
        /* values are from tailwind: https://tailwindcss.com/docs/customizing-colors */
        :root {
            --pagefind-ui-primary: #334155;
            --pagefind-ui-text: #334155;
            --pagefind-ui-background: #ffffff;
            --pagefind-ui-border-width: 1px;
            --pagefind-ui-border-radius: 4px;
        }

        html.dark {
            --pagefind-ui-primary: #d1d5db;
            --pagefind-ui-text: #d1d5db;
            --pagefind-ui-background: #18181b;
            --pagefind-ui-border: #152028;
        }

        mark {
            background-color: #ff9900 !important;
            color: #6b7280 !important;
        }
    </style>
</head>

<body class="bg-white dark:bg-zinc-900">
    <div class="container mx-auto flex justify-center">
        <div data-pagefind-body class="min-w-full max-w-full lg:min-w-[1000px] lg:max-w-[1000px] px-6 py-10 space-y-10 text-slate-700 dark:text-gray-300">
            
    <div class="flex flex-col space-y-4 pt-4 md:pt-8">
        <div class="flex justify-between">
            <a href="/">Back to BIPs</a>
            <div class="flex">
                <svg id="toggleDark_light" class="hidden dark:flex w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'light'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
                </svg>
                <svg id="toggleDark_dark" class="flex dark:hidden w-6 h-6 hover:cursor-pointer" onclick="localStorage.theme = 'dark'; window.setTheme()"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
                </svg>
            </div>
        </div>
        <div class="flex flex-col space-y-2">
            <div data-pagefind-weight="10" class="text-2xl font-extrabold">BIP 110: Reduced Data Temporary Softfork</div>
            <div class="flex justify-between">
                <div class="text-xl font-semibold">2025-12-03</div>
                <a href="https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;blob&#x2F;master&#x2F;bip-0110.mediawiki" target="_blank">View on GitHub</a>
            </div>
        </div>

        <article class="max-w-none prose prose-lg prose-zinc prose-p:leading-relaxed prose-a:font-bold prose-a:underline prose-a:decoration-2 prose-a:decoration-bitcoin prose-pre:bg-zinc-200 prose-pre:text-zinc-800 dark:prose-invert dark:prose-pre:bg-zinc-600 dark:prose-pre:text-white">
            <pre><code>  BIP: 110
  Layer: Consensus (soft fork)
  Title: Reduced Data Temporary Softfork
  Authors: Dathon Ohm &lt;dathonohm+bip@proton.me&gt;
  Status: Draft
  Type: Specification
  Assigned: 2025-12-03
  License: BSD-3-Clause
  Discussion: https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;bitcoindev&#x2F;c&#x2F;nOZim6FbuF8
</code></pre>
<h2>Abstract</h2>
<p>Temporarily limit the size of data fields at the consensus level, in order to correct distorted incentives caused by standardizing support for arbitrary data, and to refocus priorities on improving Bitcoin as money.</p>
<h2>Copyright</h2>
<p>This document is licensed under the 3-clause BSD license.</p>
<h2>Specification</h2>
<p>Blocks during a temporary, one-year deployment are checked with these additional rules:</p>
<ol>
<li>New output scriptPubKeys exceeding 34 bytes are invalid, unless the first opcode is OP_RETURN, in which case up to 83 bytes are valid.</li>
<li>OP_PUSHDATA* payloads and witness stack elements exceeding 256 bytes are invalid, except for the redeemScript push in BIP16 scriptSigs.</li>
<li>Spending undefined witness (or Tapleaf) versions (ie, not Witness v0/BIP 141, Taproot/BIP 341, or P2A) is invalid. (Creating outputs with undefined witness versions is still valid.)</li>
<li>Witness stacks with a Taproot annex are invalid.</li>
<li>Taproot control blocks larger than 257 bytes (a merkle tree with 128 script leaves) are invalid.</li>
<li>Tapscripts including OP_SUCCESS* opcodes anywhere (even unexecuted) are invalid.</li>
<li>Tapscripts executing the OP_IF or OP_NOTIF instruction (regardless of result) are invalid.</li>
</ol>
<p>Inputs spending UTXOs that were created before the activation height are exempt from the new rules.
Once the softfork expires, UTXOs of all heights are once again unrestricted.</p>
<h2>Motivation</h2>
<p>In order to protect Bitcoin's intended function as the Internet's native money, the Bitcoin community has historically treated techniques for embedding arbitrary data into Bitcoin transactions with antagonism.</p>
<p>Such data embedding must be resisted at all times in order to ensure it doesn't become load-bearing and start to produce negative externalities, especially for node operators.</p>
<p>Starting with the &quot;inscription&quot; hack first exploited in 2022, a trend has emerged around embedding arbitrary data into Bitcoin transactions, creating significant unnecessary burdens on node operators and diverting development focus and incentives away from Bitcoin's fundamental purpose of being sound, permissionless, borderless money.</p>
<p>This BIP aims to set Bitcoin back on the path to becoming the world's money by rejecting the standardization of data storage as a supported use case at the consensus level.</p>
<p>It achieves this by temporarily invalidating several of the most harmful methods of data abuse by consensus, while preserving all known monetary use cases.</p>
<p>Specifically, this proposal invalidates all methods of embedding contiguous arbitrary data larger than 256 bytes; it also invalidates large scriptPubKey and Tapleaf formats that are abused almost exclusively for data embedding; and finally, it restores, in consensus, the long-established 83-byte policy limit on OP_RETURN outputs.</p>
<p>In software development, it is a common practice to disable unsupported use cases, because not doing so quickly becomes unsustainable and causes development to grind to a standstill.</p>
<p>Activation of these new rules thus sends a clear message that arbitrary data storage will continue to be actively resisted, and that such unsupported usage should not be permitted to derail network priorities.</p>
<p>It also reinforces Bitcoin's core function as a censorship-resistant payment system, because data storage competes unfairly with payments, making Bitcoin payments unnecessarily costly. This encourages reliance on third-party payment processors, making Bitcoin payments easier to censor.</p>
<p>Finally, it improves decentralization of the node network by re-establishing the long-held commitment towards minimizing the cost (financial or otherwise) of operating a node.</p>
<p>Bitcoin should &quot;do one thing, and do it well&quot;. By rejecting data storage, this BIP liberates Bitcoin developers from endless scope creep, enabling them to focus on what's really important: Bitcoin's success as money.</p>
<h2>Rationale</h2>
<h3>Specification nuance</h3>
<p><strong>Why limit scriptPubKeys to 34 bytes?</strong></p>
<p>Unspent scriptPubKeys (OP_RETURN excepted) must be stored indefinitely in the UTXO set, which nodes must store on fast media and cannot prune.
Fast storage (usually RAM) is much more costly per byte than slower, non-volatile storage, so as the UTXO set size increases, the burden on node operators increases, harming decentralization.
They are also a direct cost to the sender rather than the receiver.
For these reasons, modern usage is all 34 bytes or smaller in practice; actual spending conditions have been moved to the witness, and the scriptPubKey simply commits to them in advance with a hash.
Furthermore, large scriptPubKeys, in addition to being a data embedding vector, can be abused to create malicious transactions and blocks (&quot;poison blocks&quot;) that take a long time to validate.
Large scriptPubKeys, thus carrying a large abuse potential and no benefit, are invalidated by this BIP.</p>
<p><strong>What about OP_RETURN? Why not get rid of it entirely?</strong></p>
<p>OP_RETURN outputs are provably unspendable, and nodes do not need to store them in the UTXO set.
Historically, up to 83 bytes have been tolerated only to avoid unprovably unspendable spam in other output scripts, and with the possible exception of commitment schemes that use OP_RETURN in coinbase transaction outputs (notably Segwit), using OP_RETURN is not the optimal solution to any known use case.
With the advent of pay-to-contract and Taproot, it is now also possible to commit to external data in the Taptree, making even hypothetical use of OP_RETURN deprecated.
However, to avoid breaking legacy protocols that still include such outputs, this proposal allows these outputs.</p>
<p><strong>Why limit other data to 256/257 bytes?</strong></p>
<p>With modern compression, it is plausible to represent images in as few as 300-400 bytes. Images are likely the most harmful use case for data storage, as they have huge demand and supporting them can engender high fees and UTXO-set bloat, as well as content that a large majority of node operators might object to.</p>
<p>256 bytes (2048 bits) is also more than sufficient for reasonably large numbers that might be potentially needed in legitimate cryptography, reinforcing Bitcoin's intended purpose as a monetary network.</p>
<p><strong>Won't spammers just spread their data over multiple fields?</strong></p>
<p>While it is impossible to fully prevent steganography, limiting data sizes ensures such abuses are non-contiguous and obfuscated within another intended meaning (script code, structure, etc).
As far as Bitcoin is concerned, the data has some meaning other than the spammers' misinterpretation, and any external code to &quot;reassemble&quot; the unintended data is responsible for producing it
(it is possible to write code that transforms <em>any</em> data into any other data - what matters is that Bitcoin has a well-defined meaning that is distinct from the unsupported one).
Requiring users to divide their files into chunks of at most 256 bytes, raising the cost both in fees and in effort, sends a clear message that data storage abuses in general are unwelcome rather than sanctioned or supported.</p>
<p><strong>Why is there an exception for BIP16 redeemScripts?</strong></p>
<p>The content of redeemScripts are another script, which is then executed.
Its contents are then also subject to the same OP_PUSHDATA* restrictions.
Restricting it is not only unnecessary, but would reduce the ability to make use of the intended script capabilities, and could impact legitimate real-world usage.</p>
<p><strong>Why make spending undefined witness/Tapleaf versions invalid?</strong></p>
<p>Since they are undefined, witness stacks spending these versions are completely unlimited currently to allow maximum flexibility in future upgrades.
Any future upgrade, however, would need more than a year of coordination, so this softfork will not actually restrict it, and only safeguards against abuse in the meantime.</p>
<p><strong>Why not make it invalid to send to undefined witness versions?</strong></p>
<p>This would require the senders of transactions to check the witness version prior to sending, and require additional coordination when a new witness version is intended to become used.</p>
<p><strong>Why not allow spending undefined witness versions with an empty witness?</strong></p>
<p>This has no use case, but would require nodes to track these UTXOs in case of potential spending.
By making spending invalid, it is possible for nodes to store them instead in slow memory not needed until this softfork expires.
(With proper planning, it also makes it possible for a future softfork making use of these witness versions to allow users to receive with an upgraded wallet even prior to activation of the upgrade.)</p>
<p><strong>Why make the Taproot annex invalid?</strong></p>
<p>The annex is currently undefined data with unlimited size.
It exists for future upgrades, but has no legitimate usage today.
Any future upgrade, however, would need more than a year of coordination, so this softfork will not actually restrict it, and only safeguards against abuse in the meantime.</p>
<p><strong>Why is the Taproot control block limited to 257 bytes instead of 256?</strong></p>
<p>The control block is a series of hashes proving the Tapscript is part of the Taptree, plus a single byte with the leaf version and parity bit.
See BIP 341 for details.</p>
<p><em><em>Why make OP_SUCCESS</em> invalid?</em>*</p>
<p>OP_SUCCESS* is meant for future upgrades. See above regarding undefined witness versions.</p>
<p><strong>Why make OP_IF/OP_NOTIF invalid?</strong></p>
<p>OP_IF/OP_NOTIF originated in pre-Taproot Bitcoin script language as a way to execute different subscripts based on a condition.
With Taproot, the conditions can instead be evaluated off-chain, revealing only the intended verification execution path.
Furthermore, when the conditions are met, the intent is that the keypath spend path should be used instead, avoiding publishing any scripts at all.</p>
<p>OP_IF is not only redundant for Tapscript, it is also commonly abused today to inject spam that gets skipped at execution.
While it is impossible to fully prevent steganography, closing this gap eliminates one common abuse today basically for free, and sends a message that such abuses are not welcome.
There are some potential experimental use cases for OP_IF in Tapscript. See the Tradeoffs section for more details.</p>
<p><strong>Why is the proposal so simple?</strong></p>
<p>A more complicated proposal could be envisioned that better balances innovation with safety, but implementing this properly would require extensive refactoring and review, delaying deployment when the change is already urgent.
The rules proposed herein have been intentionally kept very simple to minimise review time and avoid unnecessary risks of overlooking unexpected side effects.</p>
<p><strong>Why is this softfork temporary?</strong></p>
<p>The impact of these restrictions would severely constrain future upgrades, potentially forcing them to be designed as a hardfork instead of a softfork.
Some restrictions are also not ideal, but an improved limit would be more complicated to develop and test -
by deploying these simpler restrictions now, we avoid making the perfect the enemy of the good enough, while still allowing for upgrading the limits to better variants in the future.</p>
<p>Over the next year, interested developers can implement and propose a longer-term solution to address the needs of the protocol without the tradeoffs or blunt/simplified changes.</p>
<h3>Tradeoffs</h3>
<p><strong>Are there any tradeoffs?</strong></p>
<p>Yes:</p>
<ol>
<li>Limiting Taproot control blocks to 257 bytes directly constrains the size of the on-chain, consensus-enforced script tree. This could complicate or possibly even impede advanced smart contracting like BitVM, which relies on a large number of executable scripts. In the worst case scenario, these use cases may just need to wait until this softfork expires. As they are still in early development, testnet and sidechains should be sufficient for the next year while a more scalable rule is implemented.</li>
<li>Upgrade hooks are not available for other softforks. As softforks adding new opcodes typically need at least a year to activate, this shouldn't be a practical issue.</li>
<li>Some wallet software such as Miniscript habitually creates Tapleaves containing OP_IF. To mitigate the risk of these funds being frozen for a year, this proposal exempts inputs that spend outputs that were created before activation, and provides a two-week grace period between lock-in and activation, to give users time to prepare.</li>
</ol>
<p><strong>Isn't the limit on Taproot control blocks too restrictive?</strong></p>
<p>Possibly.
The previous limit allows for 340,282,366,920,938,463,463,374,607,431,768,211,456 scripts, which is obviously way more than anyone could ever need.
257 bytes allows for 128 scripts, which is sufficient for modern and complex transactions.
However, it may prove too limiting for advanced off-chain functionality such as used by BitVM.
This is an unfortunate tradeoff that (if this softfork is accepted) we have chosen to accept in the short-term for the immediate benefits of this softfork.
The intent is to relax this restriction later, when this softfork expires, with a new approach allowing larger trees, yet to be developed.</p>
<p>Do note that non-script (or non-Bitcoin-L1 scripts) usage of the taptree does not have this same limitation:
just a single of the 128 leaves could very well be an extension of the merkle tree to greater depths than enforced by this softfork.</p>
<p><strong>Aren't Taptrees intended to be unbalanced?</strong></p>
<p>While it is true that optimal use of Taptrees may often be unbalanced to favour more-likely-executed scripts, this is optional, and the full capacity (in this case, 128 scripts) can still be used if needed.
Additionally, in ideal/ordinary circumstances, neither the Taptree nor a merkle branch through it is ever published:
all counterparties ought to evaluate the conditions for spending off-chain and rebroadcast the transaction using the keypath spending.
Tapscripts are designed to be used when one or more parties is unreachable or uncooperative; their existence mainly only serves to deter intentional non-cooperation by making it pointless.
An exception to this is protocols employing a NUMS point to restrict an output to only being spendable via the script path.</p>
<p><strong>Is there any risk of funds being frozen or lost?</strong></p>
<p>In theory, yes. This proposal goes to great pains to make sure it does not affect any known use cases, and it is reasonably certain that no one will be affected. However, there are a couple of experimental use cases involving pre-signed Taproot transactions that could end up being affected.</p>
<p>Specifically:</p>
<ul>
<li>The restriction on OP_IF/OP_NOTIF could temporarily invalidate some edge-case Tapleaves produced by the current version of the Miniscript compiler. There are no verified uses of these constructions currently in production, but there are some popular wallets that could, in theory, produce them.</li>
<li>The restriction on Taptree depth will invalidate any Tapleaves deeper than 7 levels. Since Taptrees are usually designed with the more common spending conditions positioned higher in the tree, any funds encumbered by such a Taptree will almost certainly be easily spendable by Tapleaves higher up in the tree.</li>
</ul>
<p>In both scenarios, funds are spendable either by other Tapleaves in the tree, or by the keypath (unless the keypath is provably invalidated using a NUMS point).</p>
<p>Funds in either scenario could end up being frozen or lost <em>only</em> if <em>all</em> of the following conditions are met:</p>
<ul>
<li>The UTXO is pay-to-Taproot (P2TR);</li>
<li>The UTXO is in a pre-signed transaction;</li>
<li>The UTXO being spent <em>must</em> be confirmed <em>and</em> spent during the temporary, one-year deployment of these new rules;</li>
<li>The Tapleaf the user selects to spend the UTXO contains an OP_IF/OP_NOTIF or exists at a depth greater than 7;</li>
<li>The keypath is unusable to spend the funds, AND there are no other suitable Tapleaves in the tree to spend the UTXO (in which case funds are frozen), OR there are other Tapleaves that <em>can</em> spend the UTXO in unexpected ways (in which case funds are lost).</li>
</ul>
<p>In other words, funds are completely unaffected if:</p>
<ul>
<li>They do not use Taproot;</li>
<li>They use Taproot in standard and well-supported ways;</li>
<li>UTXOs needed during the temporary deployment are confirmed before the fork activates;</li>
<li>UTXOs in pre-signed transactions do not lock funds using Tapleaves that violate the new rules;</li>
<li>UTXOs in pre-signed transactions that lock funds using Tapleaves that violate the new rules do not need to be confirmed <em>and</em> spent during the deployment;</li>
<li>UTXOs in pre-signed transactions that lock funds using Tapleaves that violate the new rules and need to be confirmed <em>and</em> spent during the deployment can be spent either via the keypath OR by other, expected Tapleaves in the tree.</li>
</ul>
<p>This proposal does everything possible to try to avoid funds being frozen or lost, but ultimately it is impossible to prove that absolutely no one will be affected.
It is therefore up to the Bitcoin community to activate these new rules only if they feel that rejecting data storage is worth this tradeoff.
To prepare for activation, it is recommended that users begin migrating any affected funds now.
In the event that these new rules are activated, there will be at least a two-week period between lock-in and activation, during which all users will have the chance to migrate any remaining funds.</p>
<h3>Alternatives / Alsos</h3>
<p><strong>Why not let the fee market manage data storage?</strong></p>
<p>The fee market is designed to prioritize transactions based on economic urgency.</p>
<p>However, the market for data storage on the blockchain is a completely different market from the market for payments, with completely different incentives.</p>
<p>Specifically, the fee for a monetary transaction incentivises a miner to include the transaction in a block, representing a one-time transfer of monetary value, i.e., a payment. The miner thus provides the one-time service of securing a payment, for a one-time fee.</p>
<p>Once the payment is secured, the payor does not receive any additional benefit from the Bitcoin network, besides the integrity of Bitcoin's transaction history (a service to which all node operators are happy to contribute, because Bitcoin would not function as money otherwise).</p>
<p>Conversely, the fee for a data storage transaction still goes only to the miner who includes the data in a block, but the burden of storing the data falls on all node operators, who never received even a part of the fee, yet are forced to continue downloading, storing, and serving the data forever.</p>
<p>In this case, the miner accepts a one-time fee, and in exchange, the priceless service of highly-available, uncensorable data storage is provided in perpetuity <em>for free</em> by node operators.</p>
<p>The problem becomes even worse when the data is objectionable to node operators, as this represents an even larger, unexpected cost for them.</p>
<p><strong>How about OP_RETURN2/&quot;blobspace&quot; making the data optional for nodes?</strong></p>
<p>This has been attempted multiple times in the past.
There is perhaps no harm in trying yet again, and this proposal does not prevent doing so,
but ultimately these schemes depend on the cooperation of the sender, who usually wants to explicitly force the content on non-consenting node operators
(or they would be using other existing distribution methods already).
These other ideas also do not solve the problem of objectionable content.</p>
<p><strong>Why not ban PUSHDATA opcodes/Eliminate the witness discount/Apply a length limit to the Annex rather than eliminating it/Add limits to overall witness or transaction sizes/Make the softfork permanent instead of temporary/Remove the witness discount/Make OP_RETURN cheaper?</strong></p>
<p>These are all interesting ideas, but they all increase the complexity of the implementation, and this proposal was optimized to be simple and easy to review for fast deployment. If the community decides to do any of these things, this proposal encourages them to do so once it expires.</p>
<p><strong>Why not eliminate one or more of the restrictions?</strong></p>
<p>This proposal, as is, represents the strongest possible rejection of the arbitrary data storage use case, while minimizing complexity. Loosening any of the rules would make it less effective at achieving this objective, for not much benefit.</p>
<p><strong>Shouldn't spam be fought in policy? Does this proposal affirm that policy is ineffective?</strong></p>
<p>It remains true that policy is still the best place to fight spam.
However, it is also true that policy cannot guarantee 100% effectiveness, particularly against bad actors who are mining.
This softfork minimises the impact of such malicious miners, closing the worst-case risks.</p>
<p><strong>Does this proposal solve spam completely?</strong></p>
<p>No.
It is impossible to solve spam completely, and typically spam is best fought with policy/filters, not consensus.
What this softfork does is require users wanting to store large unencrypted files in the blockchain to disguise the data as financial data and/or break it up into multiple data pushes. Obviously doing so is considered an abuse of bitcoin and should be avoided, but if it does happen, this BIP strengthens the argument that data storage is not a supported use case.</p>
<p><strong>Why doesn't this proposal address non-Bitcoin tokens?</strong></p>
<p>There are a wide variety of non-Bitcoin tokens, mostly scams, that a significant portion of the community considers spam.
However, these schemes are best countered in policy rather than consensus, and besides, this proposal does not aim to eliminate spam entirely.</p>
<p><strong>Is this a slippery slope? If we make rules against data today, will we start banning use cases we don't like tomorrow?</strong></p>
<p>No.
These rules may be new at the consensus level, but they are merely enshrining long-standing principles of Bitcoin, as necessary to address a threat to the decentralization of the network and its usability for monetary purposes.</p>
<p>This softfork does not attempt to impose restrictions on monetary activity or the validity of monetary transactions themselves.
By restricting the data storage use case as much as possible, this proposal reinforces Bitcoin's guarantee of sound, permissionless money for the long-term.
This clear distinction between mitigating a systemic risk from non-monetary data abuse and interfering with actual monetary use cases provides a strong barrier against future overreach.</p>
<p>The explicitly temporary nature of the softfork further reinforces that this is a targeted intervention to mitigate a specific crisis, not a commitment or proposal of a new direction of development.
If no further action is taken by you, it will expire in a year.
Even if a followup softfork is proposed for that time, you retain the right to reject it.</p>
<p><strong>Doesn't this proposal break user space?</strong>
Yes, this proposal intentionally breaks user space, specifically the data storage user space. This is necessary in order to communicate that data storage is not supported.
Pains have been taken to avoid breaking monetary use cases, and it is unlikely that any such use cases have been affected, but in theory they might be. See the Tradeoffs section for more details.</p>
<h2>Backwards compatibility</h2>
<p>There are a couple of very unlikely scenarios in which funds could theoretically be frozen or lost. See the Tradeoffs section for more details.</p>
<p>If this proposal activates, the Miniscript compiler will need to be modified not to produce scripts that violate the new rules, at least while the new rules are active.</p>
<p>Users storing arbitrary data in the Bitcoin blockchain should start looking for other places to store their data, such as Nostr, IPFS, BitTorrent, cloud storage, etc, as the Bitcoin network will not support this use case going forward.</p>
<p>All other known use cases are not affected.</p>
<h2>Reference implementation</h2>
<p>https://github.com/bitcoinknots/bitcoin/compare/29.x-knots...dathonohm:bitcoin:uasf-modified-bip9</p>
<h2>Deployment</h2>
<p>This deployment uses a modified version of BIP9 with the following parameters:</p>
<ul>
<li><strong>name</strong>: reduced_data</li>
<li><strong>bit</strong>: 4</li>
<li><strong>starttime</strong>: 1764547200 (~December 1, 2025)</li>
<li><strong>timeout</strong>: NO_TIMEOUT</li>
<li><strong>min_activation_height</strong>: 0</li>
<li><strong>max_activation_height</strong>: 965664 (~September 1, 2026)</li>
<li><strong>active_duration</strong>: 52416 blocks (~1 year after activation)</li>
<li><strong>threshold</strong>: 1109/2016 (55%)</li>
</ul>
<h3>Deviations from BIP9</h3>
<p>This deployment deviates from standard BIP9 in five ways:</p>
<p><strong>Reduced threshold (55% instead of 95%)</strong>: The standard BIP9 threshold of 95% is designed for permanent consensus changes where near-universal miner readiness is desirable. Since rejecting data storage is a matter of urgency, and since this softfork is temporary and expires after one year, a lower threshold is ideal.</p>
<p><strong>No timeout, using max_activation_height instead</strong>: Standard BIP9 uses a time-based timeout that transitions to FAILED if the threshold is not reached. This deployment sets timeout to NO_TIMEOUT and instead uses a BIP8-like, height-based max_activation_height. The deployment transitions to LOCKED_IN at height 963648 (one retarget period before max_activation_height), then to ACTIVE at height 965664.</p>
<p><strong>Mandatory signaling period</strong>: Similar to BIP8, this deployment enforces mandatory signaling during the retarget period immediately before mandatory lock-in (blocks 961632 to 963647; lock-in happens no later than block 963648). During this window, blocks that do not signal bit 4 are rejected as invalid. Mandatory signaling ends once the deployment reaches the LOCKED_IN state.</p>
<p><strong>Expiry via active_duration</strong>: Standard BIP9 deployments are permanent once ACTIVE. This proposal includes an active_duration of 52416 blocks (~1 year), making the deployment temporary rather than permanent. The state machine remains in ACTIVE, but consensus rule enforcement is conditional: rules are only enforced for blocks with height &lt; activation_height + active_duration. After 52416 blocks, the rules cease to be enforced and UTXOs are once again unrestricted.</p>
<p><strong>State transitions</strong>: The state machine follows this progression:</p>
<ol>
<li>DEFINED: Initial state until starttime</li>
<li>STARTED: After starttime; miners may signal with bit 4</li>
<li>LOCKED_IN: Entered at the start of the first retarget period where the threshold was reached in the previous period; mandatory signaling (blocks 961632-963647) ensures this happens no later than height 963648</li>
<li>ACTIVE: Entered one retarget period after LOCKED_IN; rules enforced for active_duration blocks</li>
</ol>
<p>The FAILED state is never reached because timeout is disabled. ACTIVE is the final state; there are no transitions after it. Miner signaling after expiry has no effect because the deployment is no longer in the STARTED state, and miner signaling only governs the STARTED â†’ LOCKED_IN transition. After active_duration blocks, the deployment remains in the ACTIVE state but rules are no longer enforced. There is no separate EXPIRED state in the state machine.</p>
<h2>Credits</h2>
<p>Original draft and advice: Luke-Jr</p>

        </article>
    </div>


            <hr class="border-slate-700" />

            <div data-pagefind-ignore class="w-full flex flex-col items-center space-y-2 text-center">
                <div class="flex items-center space-x-2">
                    <p class="font-bold">Updated</p>
                    <p class="font-bold">2026-02-12</p>
                </div>
                <p>See an issue with rendering or formatting? Submit an issue on <a href="https://github.com/nickmonad/bips.dev" target="_blank">GitHub</a></p>
                <p>Do you find this site useful? Please consider <a href="https://buy.tryspeed.com/plink_live_lyek4a2yW2Sn2wfA" target="_blank">donating</a> some sats to support ongoing development.</p>
                <p><a href="/">bips.dev</a> is presented by <a href="https://nickmonad.blog" target="_blank">nickmonad</a></p>
                <p class="pt-4 text-sm">All content is owned and licensed by the respective author(s). This website makes no claim of ownership.</p>
            </div>
        </div>
    </div>
</body>
</html>
